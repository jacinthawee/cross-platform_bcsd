sw,op,arch,func,file_name,response
openssl-101f,O0,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_arm_gcc_O0_extraction/asn1_bio_callback_ctrl@001220f0.c,"The function asn1_bio_callback_ctrl takes three parameters: param_1, param_2, and param_3. It checks if the value stored at the memory address pointed to by (param_1 + 0x24) is not null. If it is not null, then it calls the BIO_callback_ctrl function with the parameters *(BIO **)(param_1 + 0x24), param_2, and param_3. If the value stored at the memory address pointed to by (param_1 + 0x24) is null, then the function simply returns."
openssl-101f,O0,arm,asn1_bio_ctrl,./data/decomp/openssl-101f_arm_gcc_O0_extraction/asn1_bio_ctrl@00122124.c,"The function `asn1_bio_ctrl` takes in a BIO object, an integer, a long integer, and a pointer to an integer, and returns a long integer. The function checks if the ptr field of the BIO object is NULL, and returns 0 if it is. If the value of param_2 is 0x97, the function sets two fields of the ptr array (at indices 10 and 11) to the values pointed to by param_4 and param_4+1, respectively, and returns 1. If the value of param_2 is 0x99, the function sets the 15th element of the ptr array to the value pointed to by param_4, and returns 1."
openssl-101f,O0,arm,asn1_bio_free,./data/decomp/openssl-101f_arm_gcc_O0_extraction/asn1_bio_free@001220fc.c,"The function takes an integer parameter (param_1) and frees the memory allocated to a structure pointed to by a pointer stored at an offset of 0x20 from the start of the structure. If the pointer is not null, the function checks if another pointer stored at an offset of 4 from the first pointer is null. If it is not null, the memory allocated to that pointer is also freed. Then, the memory allocated to the first pointer is freed using CRYPTO_free function. Finally, the function sets some fields of the structure to zero and returns 1 if memory was freed successfully, otherwise it returns 0."
openssl-101f,O0,arm,asn1_bio_write,./data/decomp/openssl-101f_arm_gcc_O0_extraction/asn1_bio_write@001222c4.c,"The function takes in a BIO object, a data buffer, and the length of the data buffer. It returns a BIO object. The function checks if the data buffer is null and sets pbVar4 to 1 if it is. It then checks if pbVar4 is not null, if the next BIO object in the chain is null, or if the pointer in the BIO object is null. If any of these conditions are true, it returns the current BIO object. The function then enters a loop that switches on the method of the current BIO object. The possible methods are: 0x0. If the pointer in the BIO object is not null, it calls the function pointed to by the pointer, passing in the current BIO object, the number of bytes read, the number of bytes written, and some additional data. If the function returns 0, it clears the flags of the BIO object and returns null."
openssl-101f,O0,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BIO_asn1_get_suffix@00122540.c,"The function takes a BIO object, retrieves a suffix using BIO_ctrl, assigns it to a local variable, and returns its length. If the length is greater than 0, it assigns the suffix and suffix free values to pointers passed in as arguments."
openssl-101f,O0,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BIO_asn1_set_prefix@001224ec.c,"The function BIO_asn1_set_prefix takes in a BIO object pointer, a prefix pointer, and a prefix_free pointer. It declares two local variables and assigns them to the prefix and prefix_free pointers. It then calls the BIO_ctrl function with the control command 0x95 and passes in a pointer to the prefix variable. The return value of the BIO_ctrl function is returned by the BIO_asn1_set_prefix function. The purpose of this function is unclear without more context about the program and its use of BIO objects and ASN.1 encoding."
openssl-101f,O0,arm,BN_GF2m_add,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_add@0011f668.c,"The function BN_GF2m_add performs addition of two binary polynomials represented as BIGNUMs in GF(2^m) finite field. The function takes three parameters: param_1, param_2 and param_3, which are pointers to BIGNUMs representing the result, the first operand and the second operand, respectively. The function determines the size of the operands and expands the result BIGNUM if necessary. The actual addition is performed by XORing the corresponding words of the two operands and storing the result in the corresponding word of the result BIGNUM. The loop terminates when all significant words of the smaller operand have been processed. After the addition, the function removes any leading zero words from the result BIGNUM and updates its ""top"" field accordingly. Finally, the function returns."
openssl-101f,O0,arm,BN_GF2m_mod,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod@0011f940.c,"The function takes three parameters: param_1, param_2, and param_3. The first two are integers, while the third is a pointer to an integer array. The function first checks if the second parameter is equal to zero. If it is, the function sets an error and returns 0. Next, the function calculates the length of the third parameter array and subtracts 1 from it. If the result is less than 0, the function sets a pointer to a local array called aiStack_30. Otherwise, it loops through the elements of the array and checks if they are non-zero. If an element is non-zero, it calculates the index of the bit that is set and stores it in the aiStack_30 array. After the aiStack_30 array has been populated, the function calls another function called BN_GF2m_mod_arr with the first and second parameters and the aiStack_30 array. The result of this function call is returned."
openssl-101f,O0,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_arr@0011f71c.c,"The function BN_GF2m_mod_arr() takes three parameters: two BIGNUM pointers (param_1 and param_2) and a pointer to an unsigned integer (param_3). It returns an integer value. The function first checks if the value pointed to by param_3 is zero. If it is, it sets param_1 to zero and returns 1. If param_2 is equal to param_1, it sets puVar11 to param_1->d and iVar5 to param_1->top. Otherwise, it sets iVar5 to param_2->top and checks if param_1 has enough space to hold the value of param_2. If not, it expands param_1 to the required size. Then, it copies the value of param_2 to param_1 and sets param_1->top to iVar5. The function then enters a loop that iterates over the bits of param_3. For each non-zero bit."
openssl-101f,O0,arm,BN_GF2m_mod_div,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_div@001201f0.c,"The function BN_GF2m_mod_div performs modular division in a binary field (GF(2^m)) and takes five parameters. It starts a BN_CTX context, creates a new BIGNUM structure, and checks for null or zero return from BN_GF2m_mod_inv. It calculates the number of bits in the input BIGNUM structure and allocates memory for an array of integers. It iterates through the bits of the input BIGNUM structure, stores the positions of the set bits in the allocated array, and determines the number of elements in the array. The function returns 0 if memory allocation fails or if certain conditions are true."
openssl-101f,O0,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_div_arr@0012031c.c,"The function takes in four parameters and a BN_CTX pointer. It starts a BN_CTX context and creates a BIGNUM variable. It sets the value of the BIGNUM variable to 0 and initializes a variable to the first element of the fourth parameter. It enters a loop that continues until the variable is -1. Within the loop, it sets the bit at a certain position of the BIGNUM variable and increments the fourth parameter. It then updates the variable to the value of the new element pointed to by the fourth parameter. Once the loop terminates, it calls BN_GF2m_mod_div() with the parameters and stores the result."
openssl-101f,O0,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_mul@0011fc6c.c,"The function BN_GF2m_mod_mul() takes in five parameters: three undefined values, a pointer to a BIGNUM structure, and another undefined value. It determines the number of bits in the input BIGNUM using BN_num_bits() and allocates memory to store an array of integers. It iterates through the words of the BIGNUM, checks each bit to see if it is set to 1, and adds the index of that bit to the array of integers. After all the bits of the BIGNUM have been processed, the function pads the array with 0xffffffff values until it reaches the size determined earlier."
openssl-101f,O0,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_mul_arr@0011fb08.c,"The function BN_GF2m_mod_mul_arr() computes the product of two polynomials in GF(2^m) and reduces the result modulo a given irreducible polynomial. It takes in five parameters: an undefined integer, two arrays of integers, an undefined integer, and a BN_CTX structure. 

If the input arrays are the same, the function calls BN_GF2m_mod_sqr_arr() to compute the square of the polynomial. Otherwise, it initializes a new BIGNUM structure called ""a"" using BN_CTX_get() and expands it if necessary using bn_expand2(). 

The function then loops through the coefficients of the two input polynomials and multiplies them using bn_GF2m_mul_2x2() to obtain the product of each pair of coefficients. It then XORs this product with the corresponding coefficient of the result polynomial, which is stored in the ""a"" BIGNUM structure."
openssl-101f,O0,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_sqr@0011fd4c.c,"The function BN_GF2m_mod_sqr computes the square of a binary polynomial represented as a BIGNUM in GF(2^m) field by allocating memory, iterating over the bits of the input polynomial, counting leading zeroes, determining the number of words needed, calling BN_GF2m_mod_sqr_arr to compute the square of the polynomial, and freeing memory before returning the result. If there is an error, it sets an error code using the ERR_put_error function."
openssl-101f,O0,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_sqrt@0012057c.c,"The function BN_GF2m_mod_sqrt computes the square root of a given BIGNUM in the finite field GF(2^m) where m is a positive integer. It takes four parameters: a pointer to the BIGNUM where the result will be stored (param_1), an integer (param_2), a pointer to the modulus BIGNUM (param_3), and a pointer to a BN_CTX structure (param_4) used for temporary storage. The function first computes the number of bits in the modulus BIGNUM and allocates an array of integers to store the positions of the non-zero bits in the modulus. It then computes the number of non-zero bits in the modulus and uses this value to determine the degree of the field extension. If the degree is zero, the function sets the result BIGNUM to zero and returns 1. Otherwise, it computes the square root of the input BIGNUM using a polynomial basis representation of the finite field elements."
openssl-101f,O0,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_GF2m_mod_sqr_arr@0011f9e4.c,"The function BN_GF2m_mod_sqr_arr takes in four parameters: an integer, an integer array, an integer, and a BN_CTX pointer. It allocates memory for a BIGNUM struct using the BN_CTX_get function, expands the BIGNUM struct if necessary, performs a squaring operation on the input array using a precomputed table of values, trims leading zeros from the BIGNUM struct, computes the modulo 2m of the result using the BN_GF2m_mod_arr function, frees any memory used by the BN_CTX struct, and returns."
openssl-101f,O0,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101f_arm_gcc_O0_extraction/bn_GF2m_mul_2x2@00122700.c,"The `bn_GF2m_mul_2x2` function multiplies two polynomials of degree less than `m` in the finite field GF(2^m) using Karatsuba's algorithm. It uses either the `mul_1x1_neon` function or the `mul_1x1_ialu` function to perform the multiplication, depending on whether or not the CPU supports NEON instructions. The results are combined using Karatsuba's algorithm and returned as a `ulonglong`."
openssl-101f,O0,arm,BN_kronecker,./data/decomp/openssl-101f_arm_gcc_O0_extraction/BN_kronecker@0011ef30.c,"The function BN_kronecker computes the Kronecker symbol of two BIGNUMs a and b, which is a generalization of the Legendre symbol. It returns an integer value representing the Kronecker symbol of a and b. The function first initializes two BIGNUM variables a_00 and a_01 using BN_CTX_start and BN_CTX_get functions. It then copies the values of a and b into these variables using the BN_copy function. Next, the function checks if the top value of a_01 is equal to zero. If it is, the function checks if the top value of a_00 is equal to one and returns a value based on the count of leading zeroes of the first digit of a_00. If the top value of a_01 is not zero, the function checks if the top value of a_00 is less than one or greater than or equal to negative one. If it is, the function checks if the least significant bit of a."
openssl-101f,O0,arm,by_dir_entry_free,./data/decomp/openssl-101f_arm_gcc_O0_extraction/by_dir_entry_free@000cf7d4.c,"The function ""by_dir_entry_free"" frees memory pointed to by a pointer, a stack, and a hash table. It takes a pointer to a pointer as its parameter and checks if the value stored in the pointer is not null. If it's not null, the function frees the memory pointed to by the pointer using the ""CRYPTO_free"" function. It also checks if the value stored in the third element of the pointer (which is assumed to be a pointer to a stack) is not null. If it's not null, the function frees the memory occupied by the stack using the ""sk_pop_free"" function. The second parameter to this function is a pointer to a function ""by_dir_hash_free + 1"", which is presumably a function that frees the memory occupied by a hash table. Finally, the function frees the memory occupied by the original pointer using the ""CRYPTO_free"" function."
openssl-101f,O0,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_arm_gcc_O0_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0011b23c.c,"The ""d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS"" function converts DER encoded data to an internal representation of GOST client key exchange parameters. It takes three arguments: a pointer to an ASN1_VALUE, a double pointer to a uchar, and a long integer specifying the length of the encoded data. The function uses the ASN1_item_d2i() function and an ASN1_ITEM pointer to the structure defining the parameters. It does not have a return value."
openssl-101f,O0,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_arm_gcc_O0_extraction/d2i_GOST_KEY_PARAMS@0011b1dc.c,"The function takes in a pointer to an ASN1_VALUE, a double pointer to a uchar, and a long integer. It calls the ASN1_item_d2i function with these parameters, along with a pointer to an ASN1_ITEM structure representing the GOST_KEY_PARAMS type. The ASN1_item_d2i function decodes the binary data pointed to by param_2 into a GOST_KEY_PARAMS structure and stores it in the memory location pointed to by param_1. The function then returns without any explicit return value."
openssl-101f,O0,arm,decode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O0_extraction/decode_gost_algor_params@00119d30.c,"The function decodes the parameters for GOST algorithms from an EVP_PKEY and a X509_ALGOR structure. It extracts the algorithm parameters from the X509_ALGOR structure and checks if the algorithm is a GOST algorithm. If it is, the function decodes the parameters and sets them in the EVP_PKEY structure. 

If the algorithm is a GOST 2001 algorithm, the function creates a new EC_KEY structure if one does not already exist in the EVP_PKEY, and fills it with the decoded parameters. If the algorithm is a GOST 94 algorithm, the function creates a new DSA structure if one does not already exist in the EVP_PKEY, and fills it with the decoded parameters.

The function returns a pointer to an ASN1_OBJECT structure containing the decoded parameters, or NULL if an error occurs."
openssl-101f,O0,arm,DES_xcbc_encrypt,./data/decomp/openssl-101f_arm_gcc_O0_extraction/DES_xcbc_encrypt@0011e488.c,"Two functions are described. 

Function 1: 

The function takes in an input byte array, an output byte array, a length of the input array, a DES key schedule, an initialization vector (IV), two constant DES cblocks, and a flag indicating whether to encrypt or decrypt. 

If the flag is set to encrypt, the function first extracts certain values from the IV and the constant cblocks. It then processes the input array in blocks of 8 bytes, XORing the current block with the previous output block and the extracted values, performing a DES encryption on the result, and storing the encrypted block in the output array. 

If the length of the input array is not a multiple of 8, the function processes the remaining bytes by padding with zeros and performing another DES encryption. 

If the flag is set to decrypt, the function performs the same operations as for encryption, but in reverse order.

Function 2: 

The function takes in an input buffer, an output buffer, a length, and an initialization vector (ivec). It performs triple DES encryption on the input buffer using the provided key schedule and ivec. The output is written to the output buffer.

The function first checks if the length of the input buffer is less than 8 bytes. If so, it performs a single DES encryption on the input buffer and writes the output to the output buffer. It then updates the ivec with the output of the encryption.

If the length of the input buffer is greater than or equal to 8 bytes, the function performs triple DES encryption on the input buffer in blocks of 8 bytes. It updates the ivec after each block encryption. If there is a partial block at the end of the input buffer, the function performs single DES encryption on the partial block and writes the output to the output buffer.

The function returns the updated ivec."
openssl-101f,O0,arm,dgram_ctrl,./data/decomp/openssl-101f_arm_gcc_O0_extraction/dgram_ctrl@000a4f0c.c,"The functions `dgram_ctrl` and `pointer_switch` both use a switch statement to perform various actions based on input parameters. They also both initialize local variables and may set values in arrays or variables passed as parameters. `dgram_ctrl` takes four parameters while `pointer_switch` takes a pointer to a structure, a pointer to a buffer, and the size of the buffer. If an error occurs, `pointer_switch` calls `__stack_chk_fail`."
openssl-101f,O0,arm,dlfcn_bind_func,./data/decomp/openssl-101f_arm_gcc_O0_extraction/dlfcn_bind_func@00121a68.c,"The function takes two integer parameters, param_1 and param_2. If both parameters are not equal to zero, the function initializes a void pointer called pvVar4 to zero. It then checks if the number of elements in a stack pointed to by the value at the memory address param_1 + 4 is less than 1. If it is, an error is generated using the ERR_put_error function. If the number of elements in the stack is greater than or equal to 1, the function retrieves the last value in the stack and assigns it to pvVar4. If pvVar4 is equal to zero, an error is generated using the ERR_put_error function. Otherwise, the function calls the dlsym function with pvVar4 and param_2 as arguments and assigns the resulting value to pvVar4. If pvVar4 is equal to zero, an error is generated using the ERR_put_error function and the dlerror function is called to retrieve additional error."
openssl-101f,O0,arm,dlfcn_bind_var,./data/decomp/openssl-101f_arm_gcc_O0_extraction/dlfcn_bind_var@00121b3c.c,"The function `dlfcn_bind_var` takes in two parameters `param_1` and `param_2`. If both parameters are not equal to 0, it proceeds to initialize a variable `pvVar4` to NULL. It then checks the number of items in a stack pointed to by `param_1 + 4`. If the number of items is less than 1, it logs an error using the `ERR_put_error` function. Otherwise, it retrieves the last item from the stack and stores it in `pvVar4`. If `pvVar4` is NULL, it logs an error using the `ERR_put_error` function. If `pvVar4` is not NULL, it attempts to find the symbol with the name specified in `param_2` using the `dlsym` function. If the symbol is not found, it logs an error using `ERR_put_error` and retrieves the error."
openssl-101f,O0,arm,dlfcn_globallookup,./data/decomp/openssl-101f_arm_gcc_O0_extraction/dlfcn_globallookup@00121880.c,"The function uses the dlfcn library to dynamically load a shared library and look up a symbol within it. It takes four parameters, but only uses the first and third parameters. First, it calls dlopen() with a null pointer for the shared library name and a flag indicating that the library should be loaded into the global scope. If dlopen() succeeds, it returns a handle to the loaded library, which is stored in iVar1. Next, the function calls dlsym() with the handle to the loaded library (iVar1) and the symbol name (param_1) that it wants to look up. If dlsym() succeeds, it returns the address of the symbol, which is stored in iVar2. Finally, the function calls dlclose() with the handle to the loaded library (iVar1) to free the resources associated with the library. Then it returns the address of the symbol (iVar2) that was looked up with dlsym(). If either dlopen() or dlsym() fails, the function returns NULL."
openssl-101f,O0,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_mont_field_encode@00120c80.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. If ""mont"" is not null, the function computes the product of the second and third parameters using Montgomery multiplication with the Montgomery context ""mont"". It stores the result in the first parameter and returns 1. If ""mont"" is null, the function generates an error using the ERR_put_error function and returns 0. The function first dereferences a BN_MONT_CTX pointer from the integer parameter + 0xa0 offset and assigns it to a local variable named ""mont""."
openssl-101f,O0,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_mont_field_sqr@00120c48.c,"The function implements squaring in a Montgomery field for elliptic curve cryptography. It takes four parameters: an integer param_1, two BIGNUM parameters param_2 and param_3, and a BN_CTX parameter param_4. It first checks if a BN_MONT_CTX pointer is set in the context information (param_1 + 0xa0). If it is not NULL, it uses the BN_mod_mul_montgomery function to compute the square of param_3 in the Montgomery field using the Montgomery context, and stores the result in param_2. If the BN_MONT_CTX pointer is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101f,O0,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_mont_group_init@00120a24.c,"The function initializes a Montgomery elliptic curve group by calling ec_GFp_simple_group_init() to initialize a simple elliptic curve group. It sets two variables to zero, likely used to store parameters specific to the Montgomery curve, and returns."
openssl-101f,O0,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@00122b5c.c,"This function computes the J-projective coordinates of a point on an elliptic curve over a finite field. It takes as input the curve parameters, the x and y coordinates of the point, and optionally a z coordinate and a BN_CTX object. 

If the curve parameters have not been initialized, the function copies the x and y coordinates into the appropriate parameters, and optionally copies the z coordinate. If any of these copy operations fail, the function returns NULL. 

If the curve parameters have been initialized, the function computes the J-projective coordinates using the curve parameters and the x, y, and z coordinates. It stores the result in the appropriate parameters (if provided). If any of these computations fail, the function returns NULL."
openssl-101f,O0,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_group_check_discriminant@00122c6c.c,"The function checks if a given elliptic curve group has a valid discriminant. It takes an integer pointer and a BN_CTX pointer as input, and initializes BIGNUM variables using BN_CTX_get(). If the group has a custom discriminant calculation function, it uses that to compute the discriminant. Otherwise, it computes the discriminant using the standard formula. It then checks if the discriminant is non-zero, and returns 0 if it is zero (indicating an invalid group) or the discriminant if it is non-zero."
openssl-101f,O0,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_group_clear_finish@00122914.c,"The function `ec_GFp_simple_group_clear_finish` takes an integer `param_1` as input, which is likely a pointer to a structure representing an elliptic curve group. The function frees memory allocated for the group's parameters, such as the curve coefficients and order, by calling `BN_clear_free` on three `BIGNUM` pointers located at offsets `0x48`, `0x74`, and `0x88` from the beginning of the structure. The function then returns."
openssl-101f,O0,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_group_copy@001232e8.c,"The function copies the values of three BIGNUM structures from one EC_GROUP object to another. It takes two integer parameters representing the memory addresses of the two EC_GROUP objects and returns a pointer to a BIGNUM structure indicating success, or a null pointer if the copying failed. 

The first BN_copy() call copies the value of the prime modulus of the elliptic curve from the second EC_GROUP object to the first. The second BN_copy() call copies the value of the order of the base point of the elliptic curve from the second EC_GROUP object to the first. The third BN_copy() call copies the value of the cofactor of the elliptic curve from the second EC_GROUP object to the first. 

If all three copying operations are successful, the function sets a flag in the first EC_GROUP object to indicate that it has the same parameters as the second EC_GROUP object. The function then returns a pointer to a BIGNUM structure with the value 1."
openssl-101f,O0,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_group_get_degree@00122954.c,"The function takes an integer parameter `param_1`, extracts the order of the elliptic curve group, calculates its bit length using `BN_num_bits()` from the OpenSSL library, and returns the bit length as the degree of the curve."
openssl-101f,O0,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_group_set_curve@0012335c.c,"The function `ec_GFp_simple_group_set_curve` takes in five parameters: `param_1`, `param_2`, `param_3`, `param_4`, and `param_5`. `param_1` is a pointer to an array of integers, `param_2`, `param_3`, and `param_4` are pointers to `BIGNUM` structures, and `param_5` is a pointer to a `BN_CTX` structure. The function first checks if the number of bits in `param_2` is greater than or equal to 3, if `param_2` has at least one word, and if the most significant bit of the first word of `param_2` is not set. If any of these conditions are not met, an error is thrown and the function returns 0. If `param_5` is not provided, a new `BN_CTX` structure is created. If this fails, an error is thrown."
openssl-101f,O0,arm,ec_GFp_simple_invert,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_invert@00123a50.c,"The function takes in an EC_GROUP object and an EC_POINT object as parameters. It checks if the EC_POINT is at infinity or not using the EC_POINT_is_at_infinity() function. If the point is not at infinity and the y-coordinate of the point is not zero, it performs a subtraction of the EC_POINT's y-coordinate from the EC_GROUP's order using the BN_usub() function. The result of the subtraction is returned as the output of the function. If the point is at infinity or the y-coordinate is zero, the function returns 1."
openssl-101f,O0,arm,EC_GFp_simple_method,./data/decomp/openssl-101f_arm_gcc_O0_extraction/EC_GFp_simple_method@00124068.c,"The function returns a pointer to an EC_METHOD structure named ""ret_9588"" with an unknown calling convention. The parameter storage is locked, indicating the function may not modify input parameters."
openssl-101f,O0,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_point_copy@00123324.c,"The function ec_GFp_simple_point_copy copies the x, y, and z coordinates of an elliptic curve point represented by param_2 to the point represented by param_1. It uses BN_copy from OpenSSL's BigNumber library to copy the BIGNUM values. If all three calls to BN_copy succeed, the function sets the point format indicator in the destination point to match the source point and returns a pointer to a BIGNUM with value 1. If any of the calls to BN_copy fail, the function returns a null pointer."
openssl-101f,O0,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_point_finish@001228f4.c,"The function frees three BIGNUM structures located at specific offsets from an integer parameter representing an elliptic curve point, and does not return a value."
openssl-101f,O0,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_point_get_affine_coordinates@00122dd4.c,"The function takes an EC_POINT object and an EC_GROUP object as input and returns the affine coordinates of the point as BIGNUM objects. It checks if the point is at infinity and initializes a BN_CTX object if one is not provided. If the point is not at infinity, it calculates the inverse of the x-coordinate modulo the order of the curve and stores it in a BIGNUM object. It then calculates the square of the inverse and stores it in another BIGNUM object. If param_3 is not NULL, it sets it to the x-coordinate of the point."
openssl-101f,O0,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O0_extraction/ec_GFp_simple_point_set_affine_coordinates@0012347c.c,"The function takes an EC_GROUP object, an EC_POINT object, two BIGNUM objects representing affine coordinates, and a BN_CTX object for temporary storage. If both affine coordinates are not NULL, the function sets the J-projective coordinates of the point using the affine coordinates and returns the result of EC_POINT_set_Jprojective_coordinates_GFp. If either affine coordinate is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101f,O0,arm,encode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O0_extraction/encode_gost_algor_params@0011a494.c,"The function encodes GOST algorithm parameters into an ASN1_STRING structure by taking an EVP_PKEY structure as input. It creates a new ASN1_STRING structure and a new GOST_KEY_PARAMS structure, determines the type of key, extracts the curve name or parameter set, finds the corresponding OID, encodes the GOST_KEY_PARAMS structure into the ASN1_STRING structure, and sets the type to 0x10. If any allocation or encoding fails, it frees the structures and returns NULL."
openssl-101f,O0,arm,get_gost_engine_param,./data/decomp/openssl-101f_arm_gcc_O0_extraction/get_gost_engine_param@0011c1d4.c,"The function takes an integer parameter called ""param_1"" and returns a pointer to a character array (string). If ""param_1"" is not equal to zero, the function returns a null pointer. Otherwise, it checks if a global variable called ""gost_params"" is null. If it is, the function attempts to retrieve the value of the environment variable ""CRYPT_PARAMS"" using the getenv() function. If this environment variable is not set, the function returns a null pointer. Otherwise, it allocates memory for the ""gost_params"" variable using the BUF_strdup() function, which copies the value of the ""CRYPT_PARAMS"" environment variable into the newly allocated memory. Finally, the function returns a pointer to the ""gost_params"" variable."
openssl-101f,O0,arm,gost2001_param_encode,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost2001_param_encode@0011a024.c,The function extracts an EC_KEY object from an EVP_PKEY object and retrieves the associated EC_GROUP object. It then converts the curve name into an ASN1_OBJECT using the OBJ_nid2obj function and encodes it into a binary format using the i2d_ASN1_OBJECT function. The encoded parameters can be transmitted or stored as needed.
openssl-101f,O0,arm,gost_cipher_cleanup,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost_cipher_cleanup@0011b394.c,"The function takes an integer parameter and uses it to access specific memory addresses. It calls the gost_destroy function on a memory address calculated by adding 0xc to the value stored at the memory address (param_1 + 0x60). This likely cleans up and deallocates any resources used by the GOST cipher algorithm. It then sets the value at memory address (param_1 + 0x54) to 0, possibly indicating that the cleanup was successful. Finally, it returns the value 1."
openssl-101f,O0,arm,gost_cipher_ctl,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost_cipher_ctl@0011b7dc.c,"The `gost_cipher_ctl` function takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function calls the `RAND_bytes` function to generate random bytes and stores them in the memory location pointed to by `param_4`. If the function call to `RAND_bytes` is successful, the function returns 1. Otherwise, it calls the `ERR_GOST_error` function with error codes and returns -1. If `param_2` is equal to 7 and `param_4` is not NULL, the function sets the value at the memory location pointed to by `param_4` to 0x32a and returns 1. Otherwise, it returns 0. If `param_2` is not equal to 6 or 7, the function calls the `ERR_GOST_error` function with error codes and returns."
openssl-101f,O0,arm,gost_cipher_do_cnt,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost_cipher_do_cnt@0011b4ac.c,"The function implements the GOST cipher in CNT mode and takes four parameters: an integer, two pointers to unsigned integers, and a pointer to a byte array. It checks if the pointer to the byte array is null and sets a pointer to a default value if it is. If not, it checks if the pointer is within a certain range and sets a flag accordingly. It then XORs each byte of the byte array with a value from a specific location in memory and stores the result in the first unsigned integer array. If the end of the byte array is reached, the function updates a pointer to the next byte to be processed and returns 1. If the pointer to the byte array is not null and the loop in the previous step did not process the entire byte array, the function enters a second loop. This loop uses the GOST CNT mode to encrypt the remaining bytes in the byte array and store the result in the first unsigned integer array.

The function takes in four parameters: param_1, param_2, param_3, and param_4. Param_1 is a pointer to an array of bytes, param_2 is a pointer to another array of bytes, param_3 is a pointer to a third array of bytes, and param_4 is an integer. The function initializes some variables, including uVar10, which is set to 1. It enters a loop that will iterate through the bytes in the array pointed to by param_1. For each byte in the array, the function calculates the value of iVar1, which is equal to the current byte index plus 1. It then XORs the byte in the param_1 array at index (2 + iVar1) with the byte in the param_3 array at index iVar1. If the result of this XOR operation plus..."
openssl-101f,O0,arm,gost_cipher_init,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost_cipher_init@0011c020.c,"The `gost_cipher_init` function initializes a GOST cipher context by setting the cipher parameters, including the GOST cipher algorithm, mode, and parameters, and calling `gost_init` with these parameters. It takes in three parameters: `param_1`, a pointer to the `EVP_CIPHER_CTX` structure; `param_2`, the key length in bytes; and `param_3`, the initialization vector. The function also checks if the `app_data` field of the `EVP_CIPHER_CTX` structure is null and retrieves the GOST engine parameters to set the cipher parameters accordingly. If the engine parameters cannot be retrieved, the function sets the cipher parameters to default values. If a key is provided, the function sets the key by calling `gost_key`."
openssl-101f,O0,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O0_extraction/GOST_CIPHER_PARAMS_new@0011b224.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function. It uses the PTR_GOST_CIPHER_PARAMS_it_0011b22c ASN1 item and does not take any parameters or return anything.
openssl-101f,O0,arm,gost_imit_final,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost_imit_final@0011be3c.c,"The `gost_imit_final` function is used to finalize the MAC calculation for a given message in the GOST cryptography algorithm implementation. It takes two parameters, a pointer to a GOST context structure and a pointer to a buffer where the calculated MAC will be stored. The function retrieves variables from the GOST context structure, including the state of the algorithm and the MAC length. If the MAC length is zero, an error is thrown. If not, the function pads the message with zeros if it is less than 8 bytes long."
openssl-101f,O0,arm,gost_imit_init_cpa,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost_imit_init_cpa@0011b788.c,"The function initializes the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A. It takes four parameters but only uses the first one, which is a pointer to a structure containing the encryption context. The function clears the S-boxes used by the algorithm, sets some fields to 0 or 1, and sets the key schedule and initialization vector using the gost_init() function with the specified parameter set. It returns 1 to indicate success."
openssl-101f,O0,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O0_extraction/GOST_KEY_PARAMS_new@0011b1f4.c,The function creates a new instance of the GOST_KEY_PARAMS data structure using the ASN1_item_new function with a pointer to the ASN1_ITEM structure for the GOST_KEY_PARAMS type. It does not return any value.
openssl-101f,O0,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_arm_gcc_O0_extraction/GOST_KEY_TRANSPORT_free@0011b170.c,The function frees memory allocated to an ASN1_VALUE structure of the GOST_KEY_TRANSPORT_it type using the ASN1_item_free() function and returns.
openssl-101f,O0,arm,gost_param_free,./data/decomp/openssl-101f_arm_gcc_O0_extraction/gost_param_free@0011c17c.c,"The ""gost_param_free"" function checks if the global variable ""gost_params"" is not null and frees the allocated memory using ""CRYPTO_free"" function. It then sets ""gost_params"" to null and returns nothing. This function is used to free memory allocated to GOST parameters in the program."
openssl-101f,O0,arm,hash_step,./data/decomp/openssl-101f_arm_gcc_O0_extraction/hash_step@0011c248.c,"The first function, `hash_step`, takes in three parameters: an integer `param_1`, and two pointers to unsigned integers `param_2` and `param_3`. It initializes local variables, checks if the input pointers are aligned, performs XOR operations on arrays, and calls the `gost_enc_with_key` function with several parameters. It is likely part of a larger encryption or decryption algorithm, possibly using the GOST block cipher.

The second function takes in four parameters: a pointer to a 256-bit key, a pointer to a 64-byte input buffer, a pointer to a 64-byte output buffer, and a pointer to a 32-bit integer. It initializes local variables, performs some bitwise operations on them, calls the ""gost_enc_with_key"" function with several arguments, performs XOR operations on local variables and the output of the ""gost_enc_with_key"" function, XORs the result with the input buffer, and stores the result in the output buffer. It also checks for a specific value pointed to by the fourth parameter and returns an error if it does not match."
openssl-101f,O0,arm,hwcrhk_init,./data/decomp/openssl-101f_arm_gcc_O0_extraction/hwcrhk_init@000f3898.c,"1. Checks if hwcrhk_dso global variable is null and loads HWCryptoHook library using DSO_load function if it is.
2. Binds required functions using DSO_bind_func function if library is loaded successfully.
3. Sets HWCRHK_lib_error_code variable and puts an error using ERR_put_error function if any required functions are not found.
4. Sets function pointers to corresponding functions if all required functions are found.
5. Sets dynlock callbacks using CRYPTO_get_dynlock_create_callback, CRYPTO_get_dynlock_lock_callback, and CRYPTO_get_dynlock_destroy_callback functions if disable_mutex_callbacks is false.
6. Gets RSA key handle index using RSA_get_ex_new_index function.
7. Sets hndidx_rsa variable to RSA key handle index if context is not null.
8. No information provided."
openssl-101f,O0,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_arm_gcc_O0_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0011b1b8.c,The i2d_GOST_KEY_AGREEMENT_INFO function encodes an ASN1_VALUE struct using the ASN1_item_i2d function and stores the resulting DER-encoded uchar array in a memory location pointed to by a double pointer to an unsigned character array. The function returns without any value.
openssl-101f,O0,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_arm_gcc_O0_extraction/i2d_GOST_KEY_TRANSPORT@0011b158.c,"The function i2d_GOST_KEY_TRANSPORT takes two parameters, param_1 and param_2. Param_1 is a pointer to an ASN1_VALUE structure, and param_2 is a pointer to a pointer to an unsigned char (uchar). The function calls the ASN1_item_i2d function with the parameters param_1, param_2, and the GOST_KEY_TRANSPORT_it ASN1_ITEM structure. The ASN1_item_i2d function converts the ASN1_VALUE structure pointed to by param_1 into a DER-encoded byte stream and stores it in the memory pointed to by param_2. Finally, the function returns without any value."
openssl-101f,O0,arm,mul_1x1_ialu,./data/decomp/openssl-101f_arm_gcc_O0_extraction/mul_1x1_ialu@001225e0.c,"The function ""mul_1x1_ialu"" does not perform any operations and simply returns."
openssl-101f,O0,arm,param_copy_gost94,./data/decomp/openssl-101f_arm_gcc_O0_extraction/param_copy_gost94@0011a1e4.c,"The function takes in two EVP_PKEY pointers as parameters, param_1 and param_2. It gets the DSA key from param_1 and the parameter values from param_2 using EVP_PKEY_get0(). It checks if the base IDs of the two parameters match, and if not, it returns an error. If the base IDs match, the function copies the parameter values from param_2 to param_1. If the DSA key in param_1 is null, it creates a new one and assigns it to param_1. It then frees any existing parameter values in the DSA key and duplicates the parameter values from param_2 to the corresponding fields in the DSA key. Finally, if the private key component of the DSA key is not zero, it computes the public key using the gost94_compute_public() function and returns 1. Otherwise, it simply returns 1. If the parameter values in param_2 are null, it does not perform any action."
openssl-101f,O0,arm,param_print_gost01,./data/decomp/openssl-101f_arm_gcc_O0_extraction/param_print_gost01@0011ad54.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters and returns an integer value. It extracts an EC_KEY object from the EVP_PKEY object and gets the EC_GROUP object associated with it. It then gets the curve name of the EC_GROUP object and stores it in an integer variable. The function indents the output using the BIO_indent function and prints the long name of the curve to the BIO object using the BIO_printf function. It returns 1 if the indentation is successful, otherwise it returns 0."
openssl-101f,O0,arm,param_print_gost94,./data/decomp/openssl-101f_arm_gcc_O0_extraction/param_print_gost94@0011ace0.c,"The function takes a BIO object, an EVP_PKEY object, and an integer as input. It obtains the BIGNUM value from the EVP_PKEY object using EVP_PKEY_get0() and initializes an array of BIGNUM pointers. The function then loops through an array of integers representing the GOST R 34.10 parameter sets, converts each value to a BIGNUM using BN_dec2bn(), and compares it with the BIGNUM value obtained from the EVP_PKEY object using BN_cmp(). If the values match, it sets the integer variable iVar4 to the corresponding NID of the parameter set and jumps to a label called LAB_0011ad2e. If the values don't match, it moves on to the next value in the array. At LAB_0011ad2e, the function..."
openssl-101f,O0,arm,pkey_ctrl_gost,./data/decomp/openssl-101f_arm_gcc_O0_extraction/pkey_ctrl_gost@0011a70c.c,"The function takes in four parameters: an EVP_PKEY object, an integer value, a pointer to a X509_ALGOR object, and a pointer to a PKCS7_SIGNER_INFO object. It performs different actions based on the value of the integer parameter. 

If the integer parameter is 1, the function checks if the X509_ALGOR pointer is null. If it is not null, the function returns 1. Otherwise, it sets the local_1c[0] array to the value of the X509_ALGOR pointer and gets the algorithm information from the PKCS7_SIGNER_INFO object. 

If the integer parameter is 2, the function checks if the X509_ALGOR pointer is null. If it is not null, the function returns 1. Otherwise, it encodes GOST algorithm parameters and sets the local_1c[0] array to the value of the encoded parameters. 

If the integer parameter is 3, the..."
openssl-101f,O0,arm,priv_encode_gost,./data/decomp/openssl-101f_arm_gcc_O0_extraction/priv_encode_gost@0011a8d0.c,"The function takes in two parameters - a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure. First, it gets the base ID of the EVP_PKEY using the EVP_PKEY_base_id() function and converts it to an ASN1_OBJECT using the OBJ_nid2obj() function. Then, it calls the encode_gost_algor_params() function to encode the algorithm parameters of the EVP_PKEY. If the EVP_PKEY is of type EC or ECDH, it gets the private key using EC_KEY_get0_private_key() function and converts it to a BIGNUM. If the EVP_PKEY is of type DH, it gets the private key using EVP_PKEY_get0() function and converts it to a BIGNUM. It then converts the BIGNUM to an ASN1_INTEGER using the BN_to_ASN1_INTEGER() function and encodes it using the i2d_ASN1_INTEGER() function. Finally, it completes the function."
openssl-101f,O0,arm,pub_encode_gost94,./data/decomp/openssl-101f_arm_gcc_O0_extraction/pub_encode_gost94@0011a7fc.c,"The function encodes a GOST 94 public key into X.509 format. It retrieves the object identifier (OID) corresponding to the GOST 94 algorithm from the EVP_PKEY structure, checks if the public key has any parameters and encodes them if they exist. The GOST 94 public key is then converted from a BIGNUM to a byte array, reversed, and encoded using DER format as an ASN1_OCTET_STRING object. Finally, the function sets the OID, parameters (if any), and encoded public key in the X509_PUBKEY structure and returns 1 if successful or 0 if an error occurs."
openssl-101f,O0,arm,pub_print_gost94,./data/decomp/openssl-101f_arm_gcc_O0_extraction/pub_print_gost94@0011ad90.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It extracts the public key from the EVP_PKEY object and prints it to the BIO object. It then compares the parameter set of the public key to a list of predefined parameter sets and prints the name of the matching set to the BIO object. If no match is found, it returns 0. The function is used to print information about a public key, including its value and the name of the parameter set it belongs to."
openssl-101f,O0,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O0_extraction/RSA_padding_add_PKCS1_PSS@001213b0.c,"The function implements the padding scheme for RSA signatures using the Probabilistic Signature Scheme with message recovery (PSS) and the PKCS#1 v2.1 standard. It takes as input a RSA key object, a message hash, a hash function object, and an optional salt length. It first computes the size of the hash output and checks if it is valid. It then computes the size of the RSA key and the size of the salt based on the input salt length. If the salt length is not specified or is set to -1, the function uses a default value based on the RSA key size and hash output size. If the salt length is set to -2, the function uses the maximum possible value. If the salt length is invalid, the function returns an error. Next, the function generates a random salt of the specified length using a secure random number generator. It then computes the PSS padding for the message hash by concatenating the salt with some fixed."
openssl-101f,O0,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O0_extraction/RSA_verify_PKCS1_PSS@00120d3c.c,"The function RSA_verify_PKCS1_PSS verifies a signature using RSA and PKCS1 PSS padding scheme. It takes in an RSA key, message hash, hash function, signature, and signature length. The function initializes an EVP_MD_CTX structure for the hash function, checks the length of the signature and the first byte of the signature, and calculates the mask using PKCS1 MGF1 function. It then applies the mask to the signature to obtain the encoded message. The function checks the first byte of the encoded message to determine the length of the salt used in the padding and verifies that the remaining bytes of the encoded message match the hash of the input message and the salt. If successful, the function returns 1."
openssl-101f,O0,arm,sha_block_data_order,./data/decomp/openssl-101f_arm_gcc_O0_extraction/sha_block_data_order@0011d07c.c,"These function summaries all describe implementations of the SHA-1 hashing algorithm, which processes input data in 512-bit blocks and uses a series of bitwise and arithmetic operations to transform the input into a fixed-length output hash value. The specific operations used in each implementation may vary slightly, but they all involve initializing a set of variables with predefined values, processing the input data in blocks, and updating the variable values based on the operations performed on each block. The final output is a concatenation of the updated variable values. One of the summaries describes a function that simply reads input from the user and stores it in a buffer until a null byte is entered."
openssl-101f,O0,arm,SHA_Final,./data/decomp/openssl-101f_arm_gcc_O0_extraction/SHA_Final@0011e364.c,"The SHA_Final function is the final step in the SHA-1 hashing process. It takes in a message digest (md) and a SHA context (c) as inputs. First, it calculates the number of bytes in the message (c->num) and adds a padding byte (0x80) to the end of the message. If the message is less than 56 bytes, it adds enough zeros to make the message exactly 56 bytes long. Next, it adds the length of the message (in bits) to the end of the message (in little-endian format). It then performs one more SHA-1 block operation on the padded message. After the final block operation, the function retrieves the five hash values from the SHA context and stores them in the message digest (md) in big-endian format. Finally, the function clears the SHA context and returns 1."
openssl-101f,O0,arm,start_hash,./data/decomp/openssl-101f_arm_gcc_O0_extraction/start_hash@0011cbf0.c,"The function takes a pointer to an array of four 4-byte integers. If the third element of the array is not zero, it initializes the first four elements to zero and sets the first, second, and fourth elements to zero before returning 1. If the third element is already zero, it returns the value of the third element."
openssl-101f,O0,arm,sv_body,./data/decomp/openssl-101f_arm_gcc_O0_extraction/sv_body@00026534.c,These are two separate function summaries and cannot be consolidated.
openssl-101f,O0,arm,__aeabi_idivmod,./data/decomp/openssl-101f_arm_gcc_O0_extraction/__aeabi_idivmod@00124584.c,"The function performs integer division and modulus operation for ARM processors with two integer parameters. If the second parameter is zero, it returns without performing any operation. It sets the first parameter to the maximum positive or minimum negative value of a signed integer based on its sign. Finally, it calls the __aeabi_idiv0() function to perform the division operation."
openssl-101f,O0,arm,__libc_csu_init,./data/decomp/openssl-101f_arm_gcc_O0_extraction/__libc_csu_init@00124c94.c,"The function initializes the C runtime library by calling the _init() function and iterates through each function pointer stored in memory, calling the function with the given parameters. It is likely part of the program's initialization process."
openssl-101f,O0,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101f_arm_gcc_O0_extraction/__sha256_block_data_order_from_thumb@00124cf0.c,"The functions all implement the SHA-256 hashing algorithm to generate a 256-bit hash value. They all break the input data into 512-bit blocks and perform a series of bitwise and arithmetic operations on each block to update the hash value. They also use a set of constants and intermediate variables to store the results of these operations. The functions differ in their specific implementation details, such as the initialization of variables and constants, the number of rounds performed on each block, and the specific operations performed in each round."
openssl-101f,O0,arm,__udivdi3,./data/decomp/openssl-101f_arm_gcc_O0_extraction/__udivdi3@00124998.c,"The first function takes in four unsigned integers as parameters and returns the quotient of param_1:param_2:param_3:param_4 using a long division algorithm. It checks if param_4 is equal to 0 and if so, checks if param_3 is less than or equal to param_2 before performing the algorithm. It also uses several helper functions.

The second function takes in four parameters and performs various bitwise operations and arithmetic calculations to compute a 64-bit unsigned integer. It checks if param_3 is equal to 0 and if not, proceeds with the computation. It performs bitwise AND operations on param_3 and param_4 to obtain the lower 8 bits of each parameter before computing two intermediate values. It then uses these values and the other parameters to compute the final result."
openssl-101f,O0,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101f_arm_gcc_O0_extraction/___armv7_tick_from_thumb@00124cd8.c,"The function is a low-level implementation of a timer interrupt handler for ARMv7 processors. It takes in two parameters: an undefined 4-byte value and a 32-bit unsigned integer. The function first reads the value of a coprocessor register (Rt) and performs a vector round halving add operation on two double precision floating point values. It then uses the result to calculate a pointer to a memory location based on the second parameter passed in. The function checks if the processor has exclusive access to the memory location pointed to by the calculated pointer. If it does, it updates the value of a pointer stored in a register (Rt) to point to the calculated memory location. If the second parameter is less than 7, the function sets the memory location pointed to by the calculated pointer to zero. If the second parameter is greater than or equal to 7, the function sets the memory location pointed to by the calculated pointer and the next 3 memory locations to zero."
openssl-101f,O1,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_arm_gcc_O1_extraction/asn1_bio_callback_ctrl@001220f0.c,"The function takes two integers and a function pointer as parameters. It checks if the value at memory address (param_1 + 0x24) is not NULL. If it is not NULL, it calls the BIO_callback_ctrl function with the first parameter as the value at memory address (param_1 + 0x24), and the second and third parameters as param_2 and param_3 respectively. If the value at memory address (param_1 + 0x24) is NULL, the function returns without performing any action."
openssl-101f,O1,arm,asn1_bio_ctrl,./data/decomp/openssl-101f_arm_gcc_O1_extraction/asn1_bio_ctrl@00122124.c,"This function is an implementation of the ASN.1 BIO control function. It takes a BIO pointer, an integer parameter, a long parameter, and a pointer to an integer as input. The function checks if the pointer to the BIO object is null, and returns 0 if it is. If the integer parameter is 0x97, the function sets the 10th element of the BIO object's pointer to the value of the integer pointer, and the 11th element to the value of the second integer in the integer pointer, and returns 1. If the integer parameter is 0x95, the function sets the 8th element of the BIO object's pointer to the value of the integer pointer, and the 9th element to the value of the second integer in the integer pointer, and returns 1. If the integer parameter is greater than 0x97, the function checks if it is equal to 0x99. If it is, the function..."
openssl-101f,O1,arm,asn1_bio_free,./data/decomp/openssl-101f_arm_gcc_O1_extraction/asn1_bio_free@001220fc.c,"The function takes an integer parameter and attempts to free the memory associated with it. It checks for a null pointer and retrieves a pointer to the memory block from a specific offset within the parameter. If the memory block has a second pointer within it, it frees the memory block it points to using the CRYPTO_free function. Then, it frees the original memory block using the same function. Finally, it sets several offsets within the parameter to null and returns 1 to indicate success. If the original pointer was null, it simply returns 0 to indicate failure."
openssl-101f,O1,arm,asn1_bio_write,./data/decomp/openssl-101f_arm_gcc_O1_extraction/asn1_bio_write@001222c4.c,"The function checks for a NULL void pointer and sets pbVar4 to 1 if it is. It checks if the next_bio or ptr fields of the BIO object are NULL and returns the corresponding value if they are. If the BIO object has a method, it performs a switch statement based on the method value. If the method is NULL, it checks if the ptr field is not NULL and calls the function pointed to by ptr with the appropriate parameters. If the function returns 0, it clears the flags and returns NULL. If the num_write field is less than 1, it sets the method to 2. If the method is 1, it writes data to the next BIO object until the num_write field is less than 1. If the next_bio field is not NULL, it calls the next_bio function with the appropriate parameters."
openssl-101f,O1,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BIO_asn1_get_suffix@00122540.c,"The function takes in a BIO object, a pointer to a suffix variable, and a pointer to a suffix free variable. It calls the BIO_ctrl function with a control command of 0x98 and a parameter of 0. If the result of the call is greater than 0, it assigns the value of the local_18 variable to the psuffix pointer and the value of the puStack_14 variable to the psuffix_free pointer. Finally, it returns the result of the BIO_ctrl call."
openssl-101f,O1,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BIO_asn1_set_prefix@001224ec.c,"The function sets a prefix for a BIO stream by assigning the prefix and prefix_free pointers to local variables and using the BIO_ctrl function to perform the actual prefix setting with the control command value 0x95. The function returns the value returned by the BIO_ctrl function. It takes three parameters: a BIO structure pointer, a pointer to an undefined type prefix, and a pointer to an undefined type prefix_free."
openssl-101f,O1,arm,BN_GF2m_add,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_add@0011f668.c,The function BN_GF2m_add performs an addition operation between two binary field elements represented as BIGNUM structures. It takes three parameters: the output BIGNUM structure and the two input BIGNUM structures to be added. The function checks the size of the input BIGNUM structures and expands the size of the output BIGNUM structure if necessary. It performs the addition operation by XORing the corresponding words of their data arrays and stores the result in the data array of the output BIGNUM structure. The function trims any leading zero words in the output BIGNUM structure and returns 1 to indicate success.
openssl-101f,O1,arm,BN_GF2m_mod,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod@0011f940.c,"This function takes three parameters: param_1, param_2, and param_3. It first checks if the second element of param_3 is equal to 0, and if so, it returns 0. Otherwise, it calculates the number of words in param_3 (by subtracting 1 from the second element) and uses this to iterate through each word in param_3. For each word, it checks each bit to see if it is set, and if so, it adds the corresponding bit position to an array called aiStack_30. Once all words have been processed, it checks the size of aiStack_30 and if it is greater than 6, it returns 0. Otherwise, it sets the last element of aiStack_30 to -1 and calls another function called BN_GF2m_mod_arr with param_1, param_2, and aiStack_30 as arguments. The result of this function call is then returned."
openssl-101f,O1,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_arr@0011f71c.c,"The function BN_GF2m_mod_arr() takes two BIGNUM pointers and a uint pointer as parameters and returns an integer value. It first checks if the third parameter is zero, and if so, sets the first parameter to 0 and returns 1. Otherwise, it proceeds with the computation. If the second parameter is the same as the first parameter, it sets a pointer to the data array of the first parameter and the length of the data array to a variable. Otherwise, it expands the data array of the first parameter if necessary and copies the data array of the second parameter to the first parameter's data array. It also sets the length of the data array of the first parameter to the length of the data array of the second parameter. The function then performs a bitwise reduction of the first parameter's data array by the second parameter's data array using a loop to iterate through the data array of the first parameter from the highest index to the lowest index."
openssl-101f,O1,arm,BN_GF2m_mod_div,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_div@001201f0.c,"The function BN_GF2m_mod_div performs binary polynomial division in a GF(2^m) field. It takes in five parameters: param_1, param_2, param_3, param_4, and param_5. param_1 and param_2 are BIGNUMs representing the dividend and divisor polynomials respectively. param_3 is a BIGNUM representing the modulus polynomial. param_4 is a BIGNUM representing the result of the division operation. param_5 is a BN_CTX object used for temporary storage. The function starts by initializing the BN_CTX object and creating a new BIGNUM object pBVar1 using BN_CTX_get(). If pBVar1 is not created successfully or BN_GF2m_mod_inv() function returns 0, the function returns 0. The function then calculates the number of bits in the dividend polynomial and allocates memory for the temporary variables."
openssl-101f,O1,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_div_arr@0012031c.c,"The function takes four parameters: param_1, param_2, param_3, and param_4, as well as a BN_CTX object called param_5. It starts a BN_CTX object and creates a BIGNUM object called a. If a is not NULL, it sets a to 0. The function then iterates over the elements in the array pointed to by param_4, setting the corresponding bit in a. Once the loop is finished, the function calls BN_GF2m_mod_div(param_1,param_2,param_3,a,param_5) to perform a GF(2^m) modular."
openssl-101f,O1,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_mul@0011fc6c.c,"The function BN_GF2m_mod_mul performs multiplication on two BIGNUMs (param_4 and param_5) in the Galois Field GF(2^m). It calculates the number of bits in param_4 and allocates memory for an array of size (number of bits in param_4 + 1) * 4. It calculates the positions of the set bits in param_4 and stores them in the allocated array. The function then calculates the leading zeros in the array and checks if the number of bits in the array is less than the allocated size. If so, it sets the remaining bits to 1. It calls the BN_GF2m_mod_mul_arr function with the allocated array and returns the result. Finally, it frees the allocated memory."
openssl-101f,O1,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_mul_arr@0011fb08.c,"The function BN_GF2m_mod_mul_arr performs multiplication of two arrays of integers modulo a given polynomial in GF(2^m) field. If the two arrays are the same, it performs squaring instead of multiplication. The function first initializes a BIGNUM variable and checks if it can be expanded to the required size. Then, it performs the multiplication using the bn_GF2m_mul_2x2 function and stores the result in the BIGNUM variable. Finally, it reduces the result modulo the given polynomial using the BN_GF2m_mod_arr function. If the operation is successful, the function returns 0, otherwise it returns 1. The function uses a BN_CTX structure for temporary variables and memory management."
openssl-101f,O1,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_sqr@0011fd4c.c,"The OpenSSL library's BN_GF2m_mod_sqr function performs modular squaring on a binary polynomial represented as a BIGNUM structure. It calculates the number of bits in the input polynomial, allocates memory for the result, iterates over the input polynomial to identify non-zero coefficients, determines the number of leading zeroes, calls the BN_GF2m_mod_sqr_arr function to perform the squaring operation, frees the allocated memory, and returns the result."
openssl-101f,O1,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_sqrt@0012057c.c,"The function BN_GF2m_mod_sqrt takes in four parameters: a BIGNUM pointer (param_1), an integer (param_2), another BIGNUM pointer (param_3), and a BN_CTX pointer (param_4). The function calculates the number of bits in param_3 and allocates memory for an array of integers with size equal to the number of bits plus one. It then determines the positions of the set bits in param_3 and stores them in the array. Next, it calculates the number of leading zeroes in the array and sets a flag (uVar5) based on whether the number of set bits is odd or even. If there are no set bits in param_3, the function sets param_1 to zero and returns 1. If there is at least one set bit in param_3, the function uses BN_GF2m_mod_exp_arr to calculate the square root of param_2 modulo param_3."
openssl-101f,O1,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_GF2m_mod_sqr_arr@0011f9e4.c,"This function initializes a BIGNUM variable 'a' and expands it if necessary. It then calculates the square of an input array using a precomputed table, sets the top value of 'a' to the size of the calculated square, reduces 'a' modulo 'param_3' using BN_GF2m_mod_arr() function, and returns 1 if the reduction is successful, 0 otherwise."
openssl-101f,O1,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101f_arm_gcc_O1_extraction/bn_GF2m_mul_2x2@00122700.c,"The function `bn_GF2m_mul_2x2` multiplies two 2x2 matrices over the field GF(2^m) and returns the resulting matrix. It takes five parameters, the first being a pointer to an array of four uints representing the first matrix, and the remaining four being the elements of the second matrix. The function first checks if the processor supports NEON instructions by checking a flag in memory. If NEON is supported, it uses the `mul_1x1_neon` function to perform the multiplication. Otherwise, it uses the `mul_1x1_ialu` function to perform the multiplication using integer arithmetic. After the multiplication is performed, the function computes the XOR of the two resulting matrices and stores it in `uVar6`. It then shifts the XOR result left by 32 bits and right by 32 bits, and XORs the two shifted results with `uVar4` to obtain two uints."
openssl-101f,O1,arm,BN_kronecker,./data/decomp/openssl-101f_arm_gcc_O1_extraction/BN_kronecker@0011ef30.c,"The function BN_kronecker computes the Kronecker symbol of two BIGNUMs a and b. It starts by allocating two BIGNUMs a_00 and a_01 using BN_CTX_start and BN_CTX_get. If a_01 is NULL, it returns -2. Then, it copies a into a_00 and b into a_01 using BN_copy. If a_01 is zero, it checks if a_00 is odd or even and returns the appropriate value. Otherwise, it checks if a_00 is negative or zero. If it is, it checks if b is odd or even and returns the appropriate value. If a_00 is positive, it computes the Kronecker symbol using a binary algorithm. It finds the highest bit in a_01 and shifts a_01 right by that many bits. It then uses a lookup table to compute the Kronecker symbol for the current bit and multiplies it with the accumulated value."
openssl-101f,O1,arm,by_dir_entry_free,./data/decomp/openssl-101f_arm_gcc_O1_extraction/by_dir_entry_free@000cf7d4.c,"The function takes a pointer to a pointer (param_1) as input. It first checks if the value pointed to by param_1 is not equal to NULL. If it is not NULL, it frees the memory pointed to by param_1 using the CRYPTO_free function. Next, it checks if the value of the third element in the array pointed to by param_1 (param_1[2]) is not equal to NULL. If it is not NULL, it frees the memory pointed to by param_1[2] using the sk_pop_free function, which also calls the by_dir_hash_free function. Finally, it frees the memory pointed to by param_1 using the CRYPTO_free function and returns."
openssl-101f,O1,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_arm_gcc_O1_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0011b23c.c,"The function converts ASN1 encoded data into a GOST_CLIENT_KEY_EXCHANGE_PARAMS structure. It takes in three parameters: a pointer to the resulting structure, a pointer to the ASN1 encoded data, and the length of the data. The function calls the ASN1_item_d2i function to convert the data and populates the resulting structure. There is no explicit return value."
openssl-101f,O1,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_arm_gcc_O1_extraction/d2i_GOST_KEY_PARAMS@0011b1dc.c,"The function takes in three parameters: a pointer to an ASN1_VALUE object, a double pointer to a uchar object, and a long integer. It uses the ASN1_item_d2i function to decode the data pointed to by the uchar object and store the result in the ASN1_VALUE object. The decoding is done using the ASN1_ITEM structure pointed to by PTR_GOST_KEY_PARAMS_it_0011b1e4. The function returns without any explicit return value."
openssl-101f,O1,arm,decode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O1_extraction/decode_gost_algor_params@00119d30.c,"The function extracts algorithm parameters from a X509_ALGOR object and decodes them based on the algorithm identifier in the ASN1_OBJECT object. If the algorithm is GOST R 34.10-2001, it fills in the EC_KEY object in the EVP_PKEY with the appropriate parameters using the fill_GOST2001_params function. If the algorithm is GOST R 34.10-94, it fills in the DSA object in the EVP_PKEY with the appropriate parameters using the fill_GOST94_params function. If the algorithm is neither of these, it returns a pointer to a NULL ASN1_OBJECT."
openssl-101f,O1,arm,DES_xcbc_encrypt,./data/decomp/openssl-101f_arm_gcc_O1_extraction/DES_xcbc_encrypt@0011e488.c,"The function `DES_xcbc_encrypt` is an implementation of the XCBC algorithm in DES. It performs encryption or decryption on an input byte array using a key schedule, initialization vector, input and output words, and constant DES cblocks. 

The function is also an implementation of the CBC mode of the DES algorithm. It takes in a key schedule, initialization vector, input message, and its length, and produces an output message by encrypting the input message using DES in CBC mode. It XORs each block with the previous ciphertext block before encrypting it, and stores the output ciphertext blocks in the output message. The function updates the initialization vector to be the last ciphertext block produced and returns it."
openssl-101f,O1,arm,dgram_ctrl,./data/decomp/openssl-101f_arm_gcc_O1_extraction/dgram_ctrl@000a4f0c.c,"The function `dgram_ctrl` takes four parameters and performs different actions based on the value of `param_2`. If `param_2` is 8, it sets `param_3` to the value at the address `(param_1 + 0x10)`. If `param_2` is 9, it sets the value at the address `(param_1 + 0x10)` to `param_3`. If `param_2` is 0xb or 0xc, it goes to a specific case. If `param_2` is 0x1f or 0x2c, it checks if the first element of `param_4` is 2 or 10. If it's not, it goes to a specific case, otherwise it sets some values in `__src`.

The function takes in several parameters including a pointer to a structure, a pointer to a source buffer, a size parameter, and a pointer to an output buffer. The function then performs a switch statement based on the first byte of the source buffer. Depending on the case, it performs various operations such as setting a parameter to 0 or 1, copying data from the source buffer to the output buffer, or setting a socket option. If the function reaches the end of the switch statement and the local variable ""local_24"" is equal to ""__TMC_END__"", the function returns. Otherwise, it calls the ""__stack_chk_fail"" function with the parameter ""param_3""."
openssl-101f,O1,arm,dlfcn_bind_func,./data/decomp/openssl-101f_arm_gcc_O1_extraction/dlfcn_bind_func@00121a68.c,"The function takes two integer parameters: param_1 and param_2. It returns a void pointer. If both parameters are not equal to zero, the function proceeds to retrieve the last value from a stack (pointed to by the value at offset 4 of the memory location pointed to by param_1) and stores it in pvVar4. If the stack is empty, an error is thrown. If pvVar4 is not equal to zero, the function attempts to retrieve the symbol specified by param_2 using dlsym() and stores it in pvVar4. If the symbol cannot be found, an error is thrown and the error message is added to the error data. If either param_1 or param_2 is equal to zero, an error is thrown. Finally, the function returns the value stored in pvVar4."
openssl-101f,O1,arm,dlfcn_bind_var,./data/decomp/openssl-101f_arm_gcc_O1_extraction/dlfcn_bind_var@00121b3c.c,"The function dlfcn_bind_var takes two parameters, param_1 and param_2. It checks if both parameters are not equal to zero and initializes a void pointer pvVar4 to NULL. It then checks the number of items in the stack pointed to by the value at the memory address param_1 + 4. If the number of items is less than 1, it calls ERR_put_error with error code 0x25, subcode 0x65, and reason code 0x69, with the file name and line number where the error occurred. If the number of items is greater than or equal to 1, it retrieves the last item from the stack and assigns it to pvVar4. If pvVar4 is NULL, it calls ERR_put_error with error code 0x25, subcode 0x65, and reason code 0x68, with the file name and line number where the error occurred."
openssl-101f,O1,arm,dlfcn_globallookup,./data/decomp/openssl-101f_arm_gcc_O1_extraction/dlfcn_globallookup@00121880.c,"The function uses the dlfcn library to dynamically load a shared object file and look up a symbol within it. It takes four parameters, but only uses the first and third. First, it calls the dlopen function with a null pointer for the shared object file name, and flags set to 1 (which means the shared object will be loaded in a way that allows symbols to be subsequently looked up with dlsym). If dlopen is successful, the function then calls dlsym with the handle and the first parameter passed to the function. This attempts to look up the symbol with the given name in the shared object. If dlsym is successful, the function then calls dlclose on the handle to the shared object, and returns the pointer to the symbol. If either dlopen or dlsym fails, the function returns nothing."
openssl-101f,O1,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_mont_field_encode@00120c80.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The integer parameter is used to access a BN_MONT_CTX pointer stored at offset 0xa0. If the BN_MONT_CTX pointer is not NULL, the function computes the product of the two BIGNUMs mod the BN_MONT_CTX's RR value using the BN_mod_mul_montgomery function, and returns the result. If the BN_MONT_CTX pointer is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101f,O1,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_mont_field_sqr@00120c48.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. If the BN_MONT_CTX pointer stored at offset 0xa0 in the integer parameter is not NULL, the function performs a modular multiplication of the second BIGNUM parameter with itself, using the BN_mod_mul_montgomery function and the BN_MONT_CTX pointer, and stores the result in the first BIGNUM parameter. If the BN_MONT_CTX pointer is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101f,O1,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_mont_group_init@00120a24.c,"The `ec_GFp_mont_group_init` function initializes a Montgomery elliptic curve group by calling `ec_GFp_simple_group_init` to initialize a generic elliptic curve group, setting two variables to zero, and returning."
openssl-101f,O1,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@00122b5c.c,"This function takes in six parameters, including a pointer to an elliptic curve group structure and BIGNUM pointers for storing the J-projective coordinates of a point on the curve. If the curve group structure has not been initialized, the function copies the x, y, and z coordinates of a point to the corresponding output parameters and returns 1. If any of the output parameters are NULL or the copy operation fails, the function returns 0. Otherwise, the function computes the J-projective coordinates of the point using the curve group structure's method and stores them in the output parameters (if they are not NULL), returning 1. If any of the output parameters are NULL or the computation fails, the function returns 0."
openssl-101f,O1,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_group_check_discriminant@00122c6c.c,"The function checks the discriminant of an elliptic curve group defined by the input parameters. It initializes a BN_CTX for temporary variables, extracts the curve parameters a and a_00, and computes the discriminant using the formula 4*a^3 + 27*a_00^2. If the discriminant is non-zero, the function returns 1, indicating that the curve is valid. Otherwise, it returns 0, indicating that the curve is invalid. The function handles error cases where the input parameters are invalid or the temporary variables cannot be allocated."
openssl-101f,O1,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_group_clear_finish@00122914.c,"The function takes an integer parameter, likely a pointer to a structure representing an elliptic curve group. It clears and frees three big integers within the structure, located at offsets 0x48, 0x74, and 0x88, which likely represent important parameters of the group. The function then returns."
openssl-101f,O1,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_group_copy@001232e8.c,"The ec_GFp_simple_group_copy function copies the values of three BIGNUM members from one elliptic curve group structure to another using the BN_copy function. If successful, it sets the value of the fourth member of the first structure to the value of the fourth member of the second structure and returns 1. If unsuccessful, it returns 0."
openssl-101f,O1,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_group_get_degree@00122954.c,"The function calculates the degree of an elliptic curve group using the BN_num_bits function from the OpenSSL library, taking an integer parameter as input. The result is not returned but is likely used elsewhere in the program."
openssl-101f,O1,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_group_set_curve@0012335c.c,"The function `ec_GFp_simple_group_set_curve` sets the parameters of an elliptic curve group based on the input parameters `param_2`, `param_3`, and `param_4`. It checks if `param_2` is a valid BIGNUM value and initializes a BN_CTX object to be used for temporary BIGNUM variables. It copies the value of `param_2` to a BIGNUM variable `a` and sets its sign to positive. It then takes the modulus of `param_3` with `param_2` and stores the result in `r`. If the modulus operation is successful, it calculates the modulus of `param`. If `param_5` is null, it creates a new BN_CTX object."
openssl-101f,O1,arm,ec_GFp_simple_invert,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_invert@00123a50.c,"This function takes an EC_GROUP pointer and an EC_POINT pointer as parameters. It checks if the EC_POINT is at infinity and subtracts the BIGNUM stored in the EC_POINT's memory address + 0x18 from the BIGNUM stored in the EC_GROUP's memory address + 0x48 and stores the result in the EC_POINT's memory address + 0x18 if it is not. If the EC_POINT is at infinity or if the subtraction fails, it returns 1."
openssl-101f,O1,arm,EC_GFp_simple_method,./data/decomp/openssl-101f_arm_gcc_O1_extraction/EC_GFp_simple_method@00124068.c,"The function returns a pointer to an EC_METHOD structure, containing information about the elliptic curve cryptography algorithm to be used. The specific algorithm is EC_GFp_simple_method, a simple implementation over a finite field. The function does not specify a calling convention for its parameters, and parameter storage is unclear."
openssl-101f,O1,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_point_copy@00123324.c,"This function takes two integer parameters representing pointers to two EC_POINT structures. It copies the X and Y coordinates of the second EC_POINT to the first EC_POINT using BN_copy, and sets a flag if all three copies are successful. The function also copies the point format from the second EC_POINT to the first EC_POINT. It returns a pointer to the first EC_POINT if successful, or a null pointer if any of the BN_copy operations fail."
openssl-101f,O1,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_point_finish@001228f4.c,"The function ec_GFp_simple_point_finish() frees memory allocated to three BIGNUM objects within a data structure representing a point on an elliptic curve (likely x, y, and z coordinates) and returns. It takes an integer parameter assumed to be a pointer to the data structure."
openssl-101f,O1,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_point_get_affine_coordinates@00122dd4.c,"The function takes an elliptic curve point as input and returns its affine coordinates as BIGNUMs. It checks if the point is at infinity and initializes a BN_CTX object if not provided. It initializes several BIGNUM variables and checks if the point is the identity point. If not, it computes the modular inverse of the y-coordinate with respect to the curve's order and computes the x-coordinate using a formula."
openssl-101f,O1,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O1_extraction/ec_GFp_simple_point_set_affine_coordinates@0012347c.c,"The function sets the affine coordinates of an EC_POINT object using two BIGNUM objects and an EC_GROUP object. If both BIGNUM objects are not NULL, a new BIGNUM object is created with the value of one, and then the EC_POINT_set_Jprojective_coordinates_GFp function is called with the provided parameters and the newly created BIGNUM object. The return value of this function is then returned by the current function. If either of the BIGNUM objects is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101f,O1,arm,encode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O1_extraction/encode_gost_algor_params@0011a494.c,"The function encodes an EVP_PKEY parameter into an ASN1_STRING format using the GOST algorithm. It creates a new ASN1_STRING object and a GOST_KEY_PARAMS object, and determines the type of the EVP_PKEY parameter. If the objects cannot be created or the encoding is unsuccessful, an error is thrown and the function returns NULL. The GOST_KEY_PARAMS object is set with the appropriate curve or parameter set and encoded into the ASN1_STRING object. The type of the ASN1_STRING object is set to 0x10 (GOST algorithm). The GOST_KEY_PARAMS object is freed and the encoded value is returned."
openssl-101f,O1,arm,get_gost_engine_param,./data/decomp/openssl-101f_arm_gcc_O1_extraction/get_gost_engine_param@0011c1d4.c,"The function ""get_gost_engine_param"" takes an integer parameter ""param_1"". If ""param_1"" is not equal to zero, the function returns a null pointer. Otherwise, it checks if the global variable ""gost_params"" is null. If ""gost_params"" is null, the function tries to get the value of the environment variable ""CRYPT_PARAMS"" using the ""getenv"" function. If ""CRYPT_PARAMS"" is not set, the function returns a null pointer. If ""CRYPT_PARAMS"" is set, the function allocates memory for ""gost_params"" using the ""BUF_strdup"" function and duplicates the string pointed to by ""str"". The function then returns the value of ""gost_params"". In summary, the function retrieves the value of the ""CRYPT_PARAMS"" environment variable and returns it as a string. If the variable is not set or the parameter passed to the function is not zero, the function returns a null pointer."
openssl-101f,O1,arm,gost2001_param_encode,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost2001_param_encode@0011a024.c,"The function encodes the parameters of an elliptic curve used in a public key algorithm according to the GOST 2001 standard. It does this by extracting an EC_KEY object from an EVP_PKEY object, retrieving the EC_GROUP object associated with the EC_KEY, getting the curve name from the EC_GROUP object, converting it to an ASN1_OBJECT structure, encoding the ASN1_OBJECT structure into a binary format using the i2d_ASN1_OBJECT() function, and storing the result in a uchar pointer."
openssl-101f,O1,arm,gost_cipher_cleanup,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost_cipher_cleanup@0011b394.c,"The function takes an integer parameter and performs two actions. First, it adds 12 to the integer value stored at an offset of 0x60 from the parameter value and calls the function gost_destroy() on the resulting value. Second, it sets the value at an offset of 0x54 from the parameter value to 0. The function then returns 1. It is likely used to clean up memory allocated for the GOST cipher."
openssl-101f,O1,arm,gost_cipher_ctl,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost_cipher_ctl@0011b7dc.c,"The `gost_cipher_ctl` function takes in four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function generates random bytes and stores them in the memory pointed to by `param_4`. If the random bytes are generated successfully, the function returns 1. Otherwise, it calls the `ERR_GOST_error` function with error code 0x6f and 0x7b and returns -1. If `param_2` is equal to 7, the function checks if `param_4` is not equal to NULL. If it is not NULL, the function stores the value 0x32a in the memory pointed to by `param_4` and returns 1. Otherwise, it returns 0. If `param_2` is not equal to 6 or 7, the function calls the `ERR_G` function."
openssl-101f,O1,arm,gost_cipher_do_cnt,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost_cipher_do_cnt@0011b4ac.c,"The first function implements the GOST cipher in counter mode, taking a key, counter value, plaintext message, and length of the plaintext as input, and outputting the encrypted ciphertext message. It checks for remaining data from a previous encryption operation, XORs it with the keystream generated from counter mode encryption, and outputs the resulting ciphertext. It then encrypts the remaining plaintext using counter mode encryption, generates a keystream using counter mode, XORs it with the plaintext to produce ciphertext, and updates the counter value for the next encryption operation.

The second function takes four parameters and checks if the first parameter is null. If it is, it returns 0. If not, it initializes some variables and enters a loop that iterates from 0 to param_4 - 1. Within the loop, it checks if i is less than 2 and sets iVar1 to i. It then calculates a value by XORing two bytes: one from the memory location at param_1 + iVar1 + 0x30 and one from the memory location at param_3 + iVar1. If i is less than param_4 - 2, it also calculates a second value by XORing two bytes: one from the memory location at param_1 + iVar7 + 0x30."
openssl-101f,O1,arm,gost_cipher_init,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost_cipher_init@0011c020.c,"The `gost_cipher_init` function initializes the GOST cipher context with the specified parameters. It takes in three parameters: `param_1` is a pointer to the `EVP_CIPHER_CTX` structure that holds the cipher context, `param_2` is the key length, and `param_3` is the initialization vector (IV). The function checks if the `app_data` field of the `EVP_CIPHER_CTX` structure is null. If it is, it retrieves the GOST engine parameter from the system and initializes the cipher context accordingly. If the parameter is not found or is empty, it uses the default GOST 28147-89 cipher and CryptoPro parameter set A. Otherwise, it looks up the parameter set based on the parameter name using the `OBJ_txt2nid` function, and initializes the cipher context with the corresponding parameter set. The cipher context is initialized by setting the `cipher_data` field to an array of integers, where the first."
openssl-101f,O1,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O1_extraction/GOST_CIPHER_PARAMS_new@0011b224.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using ASN1_item_new and PTR_GOST_CIPHER_PARAMS_it_0011b22c. No value is returned.
openssl-101f,O1,arm,gost_imit_final,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost_imit_final@0011be3c.c,"The function `gost_imit_final` takes two parameters, an integer `param_1` and an undefined 4-byte value `param_2`. It retrieves two integers `iVar1` and `iVar2` from memory addresses based on the `param_1` input. If `iVar1` is equal to zero, it calls the `ERR_GOST_error` function with error code `0x8c` and message ""gost_crypt.c"" at line number `0x240` and jumps to the end of the function. If `iVar1` is not equal to zero, the function checks if another integer `iVar1` is equal to zero. If `iVar1` is zero, the function checks if another integer at a memory address based on `iVar2` plus `0x1038` is not zero. If it is not zero, the function creates two local integers `local_24`."
openssl-101f,O1,arm,gost_imit_init_cpa,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost_imit_init_cpa@0011b788.c,"The function initializes the GOST 28147-89 cipher in imitation mode for CPA (chosen plaintext attack) using the first parameter. It retrieves an integer value stored at the memory location pointed to by the first parameter, sets certain bytes and values to 0, and calls the `gost_init` function with the retrieved integer value, a predefined parameter set, a pointer to a specific offset, and the fourth parameter passed to the function. The `gost_init` function initializes the GOST 28147-89 cipher with the specified parameters. The function returns 1 upon completion."
openssl-101f,O1,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O1_extraction/GOST_KEY_PARAMS_new@0011b1f4.c,The function creates a new instance of the GOST_KEY_PARAMS data structure using the ASN1_item_new function and immediately returns.
openssl-101f,O1,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_arm_gcc_O1_extraction/GOST_KEY_TRANSPORT_free@0011b170.c,The function frees memory allocated for a GOST key transport structure represented by an ASN1_VALUE pointer using the GOST_KEY_TRANSPORT_it ASN1_ITEM as a reference.
openssl-101f,O1,arm,gost_param_free,./data/decomp/openssl-101f_arm_gcc_O1_extraction/gost_param_free@0011c17c.c,"The ""gost_param_free"" function frees memory allocated to the ""gost_params"" variable by checking if it is not equal to NULL and using the ""CRYPTO_free"" function to free the memory. It sets the ""gost_params"" variable to NULL and returns without any value."
openssl-101f,O1,arm,hash_step,./data/decomp/openssl-101f_arm_gcc_O1_extraction/hash_step@0011c248.c,"The functions described are all related to the GOST encryption algorithm. 

The first function, `hash_step`, takes in three parameters and performs operations on them to update local variables. It performs a bitwise XOR operation on specific elements of the parameters if the least significant two bits of `param_2` and `param_3` are both zero, otherwise it copies the data byte by byte. 

The second function is performing a GOST encryption operation with a given key on a given input data. It initializes local variables and uses the key to encrypt the input data in two separate rounds, XORing the input data with some other values calculated based on the previous round's output and some other local variables. The output of the second round is returned as the encrypted data. 

The third function is an implementation of the GOST block cipher algorithm. It takes in a 256-bit key, a 64-bit IV, and a 64-bit block of plaintext, and outputs a 64-bit block of ciphertext. It initializes local variables, performs XOR operations, calls the `gost_enc_with_key` function with the key, IV, plaintext block, and some other parameters, performs a series of XOR and memmove operations, and then another loop of XOR operations. Finally, it returns the ciphertext block."
openssl-101f,O1,arm,hwcrhk_init,./data/decomp/openssl-101f_arm_gcc_O1_extraction/hwcrhk_init@000f3898.c,"The function initializes the hardware crypto hook library by loading the library file and binding its functions. It sets up dynamic locking callbacks for thread safety and creates a new RSA key handle index. If initialization fails, it sets an error code and returns 0. If the library is already loaded, it sets an error code and returns 0. Finally, it frees the library and resets the function pointers. The necessary functions for RSA encryption and decryption, modular exponentiation, and random number generation are also bound."
openssl-101f,O1,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_arm_gcc_O1_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0011b1b8.c,The function converts an ASN1_VALUE structure to binary format using the ASN1_ITEM structure PTR_GOST_KEY_AGREEMENT_INFO_it_0011b1c0 and stores it in memory pointed to by a double pointer to an unsigned character. It takes in two parameters - a pointer to the ASN1_VALUE structure and a double pointer to an unsigned character. The function does not return any value.
openssl-101f,O1,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_arm_gcc_O1_extraction/i2d_GOST_KEY_TRANSPORT@0011b158.c,The function encodes an ASN1_VALUE into binary format using the GOST_KEY_TRANSPORT_it parameter and stores it in a uchar buffer. It takes in a pointer to the ASN1_VALUE and a double pointer to the uchar buffer as parameters and returns nothing.
openssl-101f,O1,arm,mul_1x1_ialu,./data/decomp/openssl-101f_arm_gcc_O1_extraction/mul_1x1_ialu@001225e0.c,"The function ""mul_1x1_ialu"" is empty and does not perform any operations."
openssl-101f,O1,arm,param_copy_gost94,./data/decomp/openssl-101f_arm_gcc_O1_extraction/param_copy_gost94@0011a1e4.c,"The function takes two EVP_PKEY pointers as input parameters, param_1 and param_2. It retrieves the DSA key from param_1 and corresponding parameters from param_2. If the base IDs of the two parameters match, it copies the parameters from param_2 to param_1. If the DSA key in param_1 is null, it creates a new DSA key and assigns it to param_1. It then copies the three BIGNUM parameters (p, q, and g) from param_2 to the corresponding fields in the DSA key in param_1. Finally, if the private key component of the DSA key in param_1 is not null, the function computes the public key component using the private key and the copied parameters, and returns 1. Otherwise, it simply returns 1. If the base IDs of the two parameters do not match, it raises an error and returns 0."
openssl-101f,O1,arm,param_print_gost01,./data/decomp/openssl-101f_arm_gcc_O1_extraction/param_print_gost01@0011ad54.c,"The function takes in three parameters: a BIO object, an EVP_PKEY object, and an integer value. It extracts an EC_KEY object from the EVP_PKEY object and gets the EC_GROUP object associated with it. Next, it gets the curve name of the EC_GROUP object and stores it in the variable 'n'. Then, it indents the output of the BIO object by the value of 'param_3' and checks if the indentation was successful. If the indentation was successful, it converts the curve name from 'n' to a string representation using the OBJ_nid2ln() function and prints it out along with the text ""Parameter set: "" using the BIO_printf() function. Finally, it returns a value of 1 to indicate that the function executed successfully."
openssl-101f,O1,arm,param_print_gost94,./data/decomp/openssl-101f_arm_gcc_O1_extraction/param_print_gost94@0011ace0.c,"The function takes a BIO object, an EVP_PKEY object, and an integer as parameters. It initializes a local array of BIGNUM pointers called local_1c and obtains the BIGNUM value from the EVP_PKEY object using EVP_PKEY_get0() function. It then iterates through an array called R3410_paramset, which contains a list of BIGNUM values in string format. For each value, it converts the string to a BIGNUM using BN_dec2bn() function and compares it with the BIGNUM value obtained from the EVP_PKEY object using BN_cmp() function. If the two values are equal, it frees the local BIGNUM pointer and returns the corresponding parameter set's NID (numeric identifier). If the loop reaches the end of the array without finding a matching value, it frees the local BIGNUM pointer and returns 1. Finally, it prints the NID and the corresponding parameter set's name."
openssl-101f,O1,arm,pkey_ctrl_gost,./data/decomp/openssl-101f_arm_gcc_O1_extraction/pkey_ctrl_gost@0011a70c.c,"The `pkey_ctrl_gost` function takes in four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. It checks the value of `param_2` and performs different actions based on its value. If `param_2` is 1 or 5, the function sets the algorithm parameters for the signature or encryption algorithm. If `param_2` is 2 or 7, the function sets the algorithm parameters for the recipient key transport algorithm. If `param_3` is not `NULL`, the function returns an error code. Otherwise, the function retrieves the signature or encryption algorithm and recipient key transport algorithm from `param_4` and sets the algorithm parameters using `encode_gost_al`."
openssl-101f,O1,arm,priv_encode_gost,./data/decomp/openssl-101f_arm_gcc_O1_extraction/priv_encode_gost@0011a8d0.c,"The function takes in two parameters - a PKCS8_PRIV_KEY_INFO structure pointer and an EVP_PKEY structure pointer. It encodes the GOST algorithm parameters using the encode_gost_algor_params function and stores the result in the pval variable. If the EVP_PKEY structure is of type EC or GOST, it retrieves the private key from the EVP_PKEY structure and stores it in the bn variable. Next, the function converts the bn variable to an ASN1_INTEGER using the BN_to_ASN1_INTEGER function and stores the result in the a variable. Then, the function encodes the ASN1_INTEGER using the i2d_ASN1_INTEGER function and stores the result in the local_1c variable. Finally, the function sets the PKCS8_PRIV_KEY_INFO structure fields using the PKCS8_pkey_set0 function, passing in the ASN1_OBJECT, pval, and local_1c variables along with their respective sizes as parameters."
openssl-101f,O1,arm,pub_encode_gost94,./data/decomp/openssl-101f_arm_gcc_O1_extraction/pub_encode_gost94@0011a7fc.c,"The function extracts public key information from an EVP_PKEY and encodes it using the GOST 94 algorithm. It also encodes algorithm parameters and creates an ASN1_OBJECT to represent the algorithm. The encoded public key and algorithm parameters are set into an X509_PUBKEY structure, and the function returns the status of the operation."
openssl-101f,O1,arm,pub_print_gost94,./data/decomp/openssl-101f_arm_gcc_O1_extraction/pub_print_gost94@0011ad90.c,"The function pub_print_gost94 takes in a BIO object, an EVP_PKEY object, and an integer parameter. It extracts the public key from the EVP_PKEY object and prints it using BN_print. It compares the public key with a list of predefined parameter sets (stored in R3410_paramset) to determine which parameter set was used to generate the key. Once a match is found, it prints the name of the parameter set using OBJ_nid2ln and returns 1."
openssl-101f,O1,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O1_extraction/RSA_padding_add_PKCS1_PSS@001213b0.c,"The function RSA_padding_add_PKCS1_PSS adds PKCS#1 PSS padding to a given message digest. It computes the size of the digest, checks its validity, computes the size of the RSA key, and the number of padding bytes needed to make the message of the same length as the key. It generates a random salt of the desired length, computes the masked digest using the MGF1 function, XORs the masked digest with the salt and the padding bytes to form the final padded message. If the padding is successful, the function returns 1. Otherwise, it returns 0."
openssl-101f,O1,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O1_extraction/RSA_verify_PKCS1_PSS@00120d3c.c,"The function verifies a signature using the RSA-PSS algorithm. It takes a RSA key, message hash, hash algorithm, encoded signature, and signature length as inputs. It initializes an EVP_MD_CTX object, checks the length and first byte of the signature, and proceeds with the verification process if valid. It calculates the RSA key size, checks the padding byte, applies PKCS1 MGF1 function to generate the mask, XORs the mask with the encoded signature to obtain the maskedDB value. It extracts the salt value from maskedDB, calculates the hash of the concatenated message and salt, and compares it to the hash value."
openssl-101f,O1,arm,sha_block_data_order,./data/decomp/openssl-101f_arm_gcc_O1_extraction/sha_block_data_order@0011d07c.c,"These function summaries describe various implementations of the SHA-1 hashing algorithm, which takes in a message as input and produces a 160-bit hash value as output. The algorithm processes the message in 512-bit blocks, with each block consisting of 16 32-bit words. The specific operations performed on the message data depend on the current state of the hashing process, which is updated with each block of message data.

Some of the functions take in additional parameters, such as a pointer to an array of unsigned integers or a block of data, and perform a series of bitwise operations, logical operations, and arithmetic operations on the input data. The exact purpose of these functions is not clear without additional context, but they appear to be part of a larger cryptographic algorithm.

One function takes in a single argument, a pointer to an array of integers, and performs a series of checks and operations on the values in the array. The function prints out the value of a local variable and decrements a loop counter until it reaches 0."
openssl-101f,O1,arm,SHA_Final,./data/decomp/openssl-101f_arm_gcc_O1_extraction/SHA_Final@0011e364.c,"The SHA_Final function is the final step in the SHA-1 hash function algorithm. It takes the final block of data, adds padding, and then performs the final hash computation to produce the resulting message digest. The function retrieves the number of bytes in the current block of data, adds padding, and adds the length of the message in bits in the last 8 bytes of the block. After processing, the resulting hash values are stored in the md buffer in big-endian order. The function then resets the SHA_CTX structure and clears the data."
openssl-101f,O1,arm,start_hash,./data/decomp/openssl-101f_arm_gcc_O1_extraction/start_hash@0011cbf0.c,"The function takes in a pointer to an array of four 32-bit integers as its parameter. It checks if the value of the third integer in the array (at index 2) is not equal to 0. If it is not 0, the function initializes the first four integers in the array to specific values and clears the next 32 bytes of memory starting from the fifth integer in the array (at index 4) and the thirteenth integer in the array (at index 0xc) using the memset() function. Finally, it sets the value of the first integer in the array (at index 0) to 0, the value of the second integer in the array (at index 1) to 0, and the value of the fourth integer in the array (at index 3) to 0. The function then returns the value of the third integer in the array (at index 2)."
openssl-101f,O1,arm,sv_body,./data/decomp/openssl-101f_arm_gcc_O1_extraction/sv_body@00026534.c,"The functions `sv_body` and `SSL server handler` both handle SSL connections with clients. `sv_body` allocates a buffer, creates an SSL object, sets options and callbacks based on command line arguments, creates a datagram BIO object for TLS 1.3 or a socket BIO object otherwise, waits for input from the client or standard input, and reads input into the SSL object using SSL_read. `SSL server handler` initializes the SSL context, sets up the server certificate and private key, creates a listening socket, performs the SSL/TLS handshake with the client using SSL_accept, enters a loop where it reads data from the client using SSL_read and writes data back to the client using SSL_write, and handles special commands sent by the client. If an error occurs during the SSL/TLS handshake or data transfer, both functions print an error message."
openssl-101f,O1,arm,__aeabi_idivmod,./data/decomp/openssl-101f_arm_gcc_O1_extraction/__aeabi_idivmod@00124584.c,"The function __aeabi_idivmod takes two integer parameters, param_1 and param_2. If param_2 is not equal to zero, it calls the _divsi3_skip_div0_test function and returns. If param_2 is equal to zero, it sets param_1 to the maximum or minimum integer value depending on its sign and calls the __aeabi_idiv0 function with the modified param_1 value."
openssl-101f,O1,arm,__libc_csu_init,./data/decomp/openssl-101f_arm_gcc_O1_extraction/__libc_csu_init@00124c94.c,"The __libc_csu_init function initializes the C runtime environment by calling a series of function pointers with given parameters. It first initializes the _init function and calculates the number of function pointers to be called. If there are any function pointers, it iterates through them and calls each one before returning."
openssl-101f,O1,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101f_arm_gcc_O1_extraction/__sha256_block_data_order_from_thumb@00124cf0.c,"These functions all implement various cryptographic or hashing algorithms, using a combination of bitwise operations, additions, rotations, and logical operations. They typically take in input data and output a hash value, using a series of loops and variables to process the data. Some of the functions use specific constants and arrays to perform the operations, while others take in additional parameters to customize the hashing process. Overall, these functions are designed to generate secure hash values for use in various applications."
openssl-101f,O1,arm,__udivdi3,./data/decomp/openssl-101f_arm_gcc_O1_extraction/__udivdi3@00124998.c,"The first function implements unsigned integer division for 64-bit integers, taking four parameters representing the dividend and divisor. It checks for a zero divisor and returns a special value if it is, otherwise it performs the division using bitwise and arithmetic operations.

The second function takes four parameters and performs arithmetic operations to calculate a 64-bit integer result. It checks for zero parameters and returns specific values, otherwise it calculates intermediate 32-bit integers before performing further calculations to determine the final result."
openssl-101f,O1,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101f_arm_gcc_O1_extraction/___armv7_tick_from_thumb@00124cd8.c,"The function takes in two parameters, an undefined4 and a uint. It reads the value of a coprocessor register and stores it in piVar1. It performs some calculations using VectorRoundHalvingAdd and stores the result in uVar8. 

The function then enters a loop where it checks for exclusive access to a memory location pointed to by piVar1. If it has exclusive access, it sets the value of piVar1 to the memory location pointed to by piVar6 (calculated using piVar1 and the second parameter). It continues to perform calculations using VectorRoundHalvingAdd and checks if the second parameter is less than 7. 

If the second parameter is less than 7, the function checks if the least significant bit of the in_lr register is 0. If it is, the function returns. If it isn't, the function performs more calculations using VectorRoundHalvingAdd."
openssl-101f,O2,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_arm_gcc_O2_extraction/asn1_bio_callback_ctrl@001220f0.c,"The function takes in two integers and a function pointer. If the value stored at memory location `param_1 + 0x24` is not equal to zero, the function `BIO_callback_ctrl` is called with the parameters `*(BIO **)(param_1 + 0x24)`, `param_2`, and `param_3`. If it is zero, the function returns without doing anything."
openssl-101f,O2,arm,asn1_bio_ctrl,./data/decomp/openssl-101f_arm_gcc_O2_extraction/asn1_bio_ctrl@00122124.c,"The function `asn1_bio_ctrl` takes in a `BIO` struct pointer, an integer, a long integer, and a pointer to an integer. It checks if the `ptr` field of the `BIO` struct is null, and returns 0 if it is. If the second parameter is equal to 0x97, the function sets the 10th and 11th elements of the `ptr` field to the first and second elements of the pointer parameter, respectively, and returns 1. If the second parameter is greater than 0x97, the function checks if it is equal to 0x99. If it is, the function sets the 15th element of the `ptr` field to the value of the pointer parameter and returns 1."
openssl-101f,O2,arm,asn1_bio_free,./data/decomp/openssl-101f_arm_gcc_O2_extraction/asn1_bio_free@001220fc.c,"The function frees memory allocated in a previous call to a related function by retrieving a pointer to the memory allocated, checking if there is a second pointer, freeing that memory first if it exists, and then freeing the memory allocated by the related function. It also sets integer values at specific offsets to 0 and returns 1 if the memory was freed successfully or 0 if the pointer was already null."
openssl-101f,O2,arm,asn1_bio_write,./data/decomp/openssl-101f_arm_gcc_O2_extraction/asn1_bio_write@001222c4.c,"The `asn1_bio_write` function from the OpenSSL library writes data to a BIO object using an ASN.1 encoding format. It takes three parameters: a pointer to the BIO object, a pointer to the data to be written, and the length of the data. The function checks for a null `param_2` pointer or a BIO object without a next BIO or pointer, returning the corresponding pointer if true. The function then enters a loop that performs different actions depending on the current state of the BIO object, continuing until the state is set to ""2"". If the BIO object's method is null, the function calls a function pointed to by the BIO object's `ptr` member to write data to the BIO object. The function returns 0 if this function call returns 0."
openssl-101f,O2,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BIO_asn1_get_suffix@00122540.c,"The function BIO_asn1_get_suffix() takes a BIO object as input along with two pointers to undefined1 data type. It returns a long value. Inside the function, the BIO_ctrl() function is called with three arguments: the BIO object, the integer value 0x98, and the integer value 0. This function is used to control the operation of a BIO object. The value 0x98 specifies the control command that is being passed to BIO_ctrl(), and it is not clear what this command does without further context. The result of BIO_ctrl() is stored in the variable lVar1. If lVar1 is greater than 0, the pointer to the undefined1 data type local_18 is assigned to the pointer psuffix, and the pointer to the undefined1 data type puStack_14 is assigned to the pointer psuffix_free. Finally, the function returns the value of lVar1."
openssl-101f,O2,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BIO_asn1_set_prefix@001224ec.c,"The function sets the prefix string for a BIO object using the control code 0x95 and returns the result of the BIO_ctrl function. It takes in a BIO object, a prefix string, and a prefix_free string as parameters, but the prefix_free string is not used in the function."
openssl-101f,O2,arm,BN_GF2m_add,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_add@0011f668.c,"The function BN_GF2m_add takes three BIGNUM pointers as input parameters. It first checks the size of the second and third parameters and assigns them to variables iVar6 and iVar3 respectively. It then compares these variables to determine which one is larger and assigns the larger one to a variable named pBVar2. It also assigns the smaller one to a variable named param_3. If the size of the first parameter is less than the size of pBVar2, it expands the size of the first parameter using the bn_expand2 function. If this function returns NULL, the function returns 0. The function then performs a bitwise XOR operation on the data in the param_3 and pBVar2 BIGNUMs, and stores the result in the data of the first parameter. Finally, the function removes any leading zero bytes from the resulting BIGNUM and returns 1."
openssl-101f,O2,arm,BN_GF2m_mod,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod@0011f940.c,"The function takes in three parameters: param_1, param_2, and param_3. If the second element of param_3 is 0, it calls an error function and returns 0. Otherwise, it creates an array called aiStack_30 and sets the value of iVar10 to the second element of param_3 minus 1. If iVar10 is less than 0, it sets piVar7 to aiStack_30. Otherwise, it iterates through a loop that sets the value of puVar9 to the address of the first element of param_3 plus the size of the second element of param_3 multiplied by 4, and then iterates through another loop that checks each bit of each element of puVar9 and sets the corresponding index of aiStack_30 to the position of the bit if the bit is 1."
openssl-101f,O2,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_arr@0011f71c.c,"The function BN_GF2m_mod_arr takes in three parameters: a BIGNUM pointer param_1, a BIGNUM pointer param_2, and a uint pointer param_3. It returns an integer value. The function first checks if the value of the uint pointer param_3 is 0. If it is, it sets the value of the BIGNUM pointer param_1 to 0 and returns 1. If the value of param_3 is not 0, the function checks if param_2 and param_1 are the same. If they are, it sets a pointer puVar11 to the data of param_1 and sets iVar5 to the top value of param_1. Otherwise, it sets iVar5 to the top value of param_2 and checks if the data of param_1 is large enough to hold the data of param_2. If it is not, it expands the data of param_1 using the bn_expand2 function."
openssl-101f,O2,arm,BN_GF2m_mod_div,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_div@001201f0.c,"The function BN_GF2m_mod_div takes in five parameters: three undefined 4-byte parameters (which are likely pointers), a BIGNUM pointer param_4, and a BN_CTX pointer param_5. The function computes the inverse of param_4 modulo param_3 and returns 0 if it is NULL or if the inverse computation fails. If the inverse computation succeeds, the function allocates a block of memory based on the number of bits in param_4, adds 1 to it, and computes the number of 32. If the allocation fails, the function returns 0."
openssl-101f,O2,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_div_arr@0012031c.c,"The function takes in four parameters and a BN_CTX object, initializes the BN_CTX object, creates a BIGNUM object, sets it to 0 if it's not NULL, iterates through the values in one of the parameters until it encounters a value of -1, sets a bit in the BIGNUM object at the index specified by the current value in the parameter, and then calls BN_GF2m_mod_div."
openssl-101f,O2,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_mul@0011fc6c.c,"The function BN_GF2m_mod_mul performs a multiplication of two binary polynomials in GF(2^m) field and returns the result as a BIGNUM. It takes five parameters - three undefined, a pointer to a BIGNUM and another undefined parameter. The function first calculates the number of bits in the input BIGNUM and allocates memory for an array of integers to hold the positions of the set bits in the binary representation of the polynomial. It then iterates over the limbs (32-bit chunks) of the input BIGNUM, checks which bits are set and adds their position to the array. After the array is populated, the function determines the highest set bit and calculates the number of 32-bit chunks needed to store the array. If the array size is less than the number of bits in the input BIGNUM, the function pads it with 0xffffffff. The function then calls BN_GF2m_mod_mul_arr with the array and other parameters to perform."
openssl-101f,O2,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_mul_arr@0011fb08.c,"The function BN_GF2m_mod_mul_arr performs a modular multiplication operation on two arrays of binary polynomials (represented as integers) using a given modulus. If the two arrays are the same, the function calls BN_GF2m_mod_sqr_arr to perform a modular squaring operation instead. The function first initializes a BIGNUM variable ""a"" using the BN_CTX_get function, which allocates memory for a new BIGNUM object from the given BN_CTX structure. If memory allocation fails for ""a"", the function returns 0. Otherwise, the function sets the size of ""a"" to be the sum of the sizes of the two input arrays plus 4, and initializes all elements of ""a"" to 0. The function then loops through the elements of the two input arrays and performs a polynomial multiplication operation on each pair of elements using the bn_GF2m_mul_2x2 function. The result is XORed with the corresponding element in ""a""."
openssl-101f,O2,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_sqr@0011fd4c.c,"The function BN_GF2m_mod_sqr computes the square of a binary polynomial represented by a BIGNUM structure in GF(2^m) finite field. It calculates the number of bits in the input polynomial and allocates memory for an array of integers to store the positions of the non-zero bits in the polynomial. It then iterates over the words in the input polynomial, and for each non-zero bit, it adds the position of the bit to the array. The function then computes the number of leading zeroes in the array and uses it to determine whether to use a faster algorithm for squaring the polynomial. If the number of leading zeroes is zero, it calls the function BN_GF2m_mod_sqr_arr to compute the square using a standard algorithm. Otherwise, it uses a faster algorithm specific to GF(2^m) finite fields. Finally, the function frees the memory allocated for the array and returns the result of the squaring operation."
openssl-101f,O2,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_sqrt@0012057c.c,"The function BN_GF2m_mod_sqrt calculates the square root of a binary polynomial over GF(2^m) using a modified version of the Tonelli-Shanks algorithm. It takes as input a BIGNUM pointer param_1 to store the result, an integer param_2 representing the exponent, a BIGNUM pointer param_3 representing the binary polynomial, and a BN_CTX pointer param_4 for temporary storage. The function first calculates the number of bits in the binary polynomial and allocates memory for an array of integers to store the positions of the non-zero bits. It then iterates over the binary polynomial and stores the positions of the non-zero bits in the array. Next, it calculates the number of leading zeroes in the array and sets a flag indicating whether the number of non-zero bits is odd or even. If the number of non-zero bits is even, the function returns 0. If the number of non-zero bits is odd, the function uses the modified Tonelli-Shanks algorithm to calculate the square root."
openssl-101f,O2,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_GF2m_mod_sqr_arr@0011f9e4.c,"The function takes in four parameters: an integer, an integer array, another integer, and a BN_CTX pointer. It initializes a BIGNUM variable ""a"" using BN_CTX_get() and expands ""a"" if necessary. It then iterates through the elements of ""param_2"" and squares each element using a lookup table called ""SQR_tb"". After the squaring is complete, the function sets the ""top"" field of ""a"" to be twice the size of ""iVar2"" and removes any leading zero elements from ""a"". If ""a"" is NULL, the function returns 0."
openssl-101f,O2,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101f_arm_gcc_O2_extraction/bn_GF2m_mul_2x2@00122700.c,"The function bn_GF2m_mul_2x2 performs multiplication on two 2x2 matrices in the Galois field GF(2^m). It takes in five parameters: param_1, param_2, param_3, param_4, and param_5. If the least significant bit of a value stored in memory location DAT_00122820 + 0x12270c is set, the function uses the NEON instruction set to perform the multiplication. Otherwise, it uses integer arithmetic to perform the multiplication. If integer arithmetic is used, the function first performs two 1x1 multiplications using the function mul_1x1_ialu. It then performs an XOR operation on the results and performs another 1x1 multiplication on the result. The final result is stored in param_1. If NEON instructions are used, the function first performs two 1x1 multiplications using the function mul_1x1_neon."
openssl-101f,O2,arm,BN_kronecker,./data/decomp/openssl-101f_arm_gcc_O2_extraction/BN_kronecker@0011ef30.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs a and b. It initializes two BIGNUMs a_00 and a_01 using BN_CTX_get and copies the values of a and b into a_00 and a_01 using BN_copy. The function then checks if a_01 is equal to zero. If it is, it calculates the Kronecker symbol of a_00 and returns the result. If a_00 is less than 1 or a_00 is negative, it returns 0. If a_01 is not equal to zero, the function calculates the Kronecker symbol of a_00 and a_01 using a loop that calculates the greatest common divisor of a_00 and a_01 and uses this to calculate the Kronecker symbol. The function returns the Kronecker symbol as an integer."
openssl-101f,O2,arm,by_dir_entry_free,./data/decomp/openssl-101f_arm_gcc_O2_extraction/by_dir_entry_free@000cf7d4.c,"The function takes a pointer to a pointer (param_1) as its argument. It checks if the value pointed to by param_1 is not equal to NULL (0x0). If it is not NULL, it calls the CRYPTO_free() function to free the memory allocated to the pointer. Next, it checks if the value of the third element (index 2) of the array pointed to by param_1 is not equal to NULL. If it is not NULL, it calls the sk_pop_free() function to free the memory allocated to the stack object pointed to by the third element of the array. The sk_pop_free() function takes two arguments: a pointer to the stack object and a pointer to a function that frees the memory allocated to each element of the stack. In this case, the function passed to sk_pop_free() is by_dir_hash_free + 1, which is presumably a function that frees the memory allocated to a hash object."
openssl-101f,O2,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_arm_gcc_O2_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0011b23c.c,"The function takes in a pointer to an ASN1_VALUE, a double pointer to a uchar, and a long integer. It calls the function ASN1_item_d2i with these parameters and a pointer to an ASN1_ITEM structure called PTR_GOST_CLIENT_KEY_EXCHANGE_PARAMS_it_0011b244. This function decodes the binary data pointed to by param_2 into an ASN1 structure and stores the result in *param_1. The function returns without any explicit return value."
openssl-101f,O2,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_arm_gcc_O2_extraction/d2i_GOST_KEY_PARAMS@0011b1dc.c,"The function ""d2i_GOST_KEY_PARAMS"" converts a byte array into an ASN.1 data structure for the ""GOST_KEY_PARAMS"" item using the ""ASN1_item_d2i"" function. It takes in a pointer to an ASN1_VALUE, a pointer to an unsigned character (byte array), and a long integer (length of byte array). The resulting data structure is stored in the memory location pointed to by the first argument, and the function returns without any value."
openssl-101f,O2,arm,decode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O2_extraction/decode_gost_algor_params@00119d30.c,"The function `decode_gost_algor_params` takes in an `EVP_PKEY` object and an `X509_ALGOR` object, and returns a pointer to an `ASN1_OBJECT` object. It extracts the algorithm parameters from the `X509_ALGOR` object, determines the type of the algorithm, creates a new `DSA` or `EC_KEY` object, assigns it to the `EVP_PKEY` object, fills in the algorithm parameters using either `fill_GOST2001_params` or `fill_GOST94_params`, and finally returns a pointer to an `ASN1_OBJECT` object."
openssl-101f,O2,arm,DES_xcbc_encrypt,./data/decomp/openssl-101f_arm_gcc_O2_extraction/DES_xcbc_encrypt@0011e488.c,"The functions DES_xcbc_encrypt and CBC mode encryption both use the DES algorithm to encrypt data. They take in input and output buffers, a key schedule, and an initialization vector. DES_xcbc_encrypt also takes in two constant cblocks and a flag indicating whether to encrypt or decrypt. Both functions handle input that is not a multiple of 8 bytes separately. CBC mode uses the output of the previous block as the input to the current block."
openssl-101f,O2,arm,dgram_ctrl,./data/decomp/openssl-101f_arm_gcc_O2_extraction/dgram_ctrl@000a4f0c.c,"The functions `dgram_ctrl` and the unnamed function both use switch statements to determine what action to take based on the value of a parameter. `dgram_ctrl` takes four parameters, including an integer, an undefined 4-byte value, a size_t, and a pointer to an undefined 4-byte value. Depending on the value of the second parameter, it either sets or retrieves the integer stored at a specific address, or jumps to a label that sets the size_t parameter to 1. The unnamed function takes a pointer to a buffer, a length parameter, and a pointer to another buffer. Depending on the value of the first byte in the buffer, it performs different actions such as setting the length parameter or copying bytes from one buffer to another."
openssl-101f,O2,arm,dlfcn_bind_func,./data/decomp/openssl-101f_arm_gcc_O2_extraction/dlfcn_bind_func@00121a68.c,"The function takes in two parameters, param_1 and param_2. If both parameters are not equal to zero, it retrieves the last element in the stack pointed to by the value at the memory location (param_1 + 4) and stores it in a void pointer, pvVar4. If pvVar4 is equal to 0, it calls the ERR_put_error function with error code 0x25, subcode 100, and error message ""dso_dlfcn.c"" at line 0x11b. If the number of elements in the stack is less than 1, it calls the ERR_put_error function with error code 0x25, subcode 100, and error message ""dso_dlfcn.c"" at line 0x115."
openssl-101f,O2,arm,dlfcn_bind_var,./data/decomp/openssl-101f_arm_gcc_O2_extraction/dlfcn_bind_var@00121b3c.c,"The function takes two parameters, param_1 and param_2. If both parameters are not equal to zero, it proceeds to retrieve the last element of a stack pointed to by param_1. It then attempts to find the symbol specified by param_2 using dlsym() function and returns its address. If dlsym() fails to find the symbol, it logs an error message using ERR_put_error() and dlerror() functions. If either param_1 or param_2 is equal to zero, it logs an error message and returns NULL."
openssl-101f,O2,arm,dlfcn_globallookup,./data/decomp/openssl-101f_arm_gcc_O2_extraction/dlfcn_globallookup@00121880.c,"The function uses the dlfcn library to dynamically load a shared library and look up a symbol within it. It takes four parameters, but only the first and third are used. The first parameter is the name of the symbol to look up, and the third parameter is the flags to use when opening the shared library. The function calls dlopen() with a NULL filename, indicating that the library should be searched for in the default search path. The second parameter is not used. The third and fourth parameters are passed to dlopen() as flags. If dlopen() succeeds in loading the shared library, the function calls dlsym() to look up the specified symbol within the library. If dlsym() succeeds, the function returns the address of the symbol. Finally, the function calls dlclose() to unload the shared library and free up any resources associated with it."
openssl-101f,O2,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_mont_field_encode@00120c80.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It returns an integer value. The function first retrieves a BN_MONT_CTX pointer from the integer parameter's field offset 0xa0. If the BN_MONT_CTX pointer is not null, the function performs a modular multiplication of the second and third parameters, using the BN_MONT_CTX pointer and the BN_CTX pointer. The result is stored in the first parameter. If the BN_MONT_CTX pointer is null, the function generates an error message and returns 0."
openssl-101f,O2,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_mont_field_sqr@00120c48.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The integer parameter is used to access a BN_MONT_CTX pointer stored at a specific offset. 

If the BN_MONT_CTX pointer is not null, the function calls the BN_mod_mul_montgomery function to compute the square of the second BIGNUM parameter using the Montgomery multiplication algorithm and stores the result in the first BIGNUM parameter. This is done using the BN_MONT_CTX pointer stored in the integer parameter and the BN_CTX pointer passed as a parameter.

If the BN_MONT_CTX pointer is null, the function generates an error using the ERR_put_error function and returns 0."
openssl-101f,O2,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_mont_group_init@00120a24.c,"The function initializes a Montgomery group for elliptic curve cryptography by setting up basic parameters of the group using ec_GFp_simple_group_init(), setting two variables to zero at memory locations given by the input parameter, and returning. These variables are used to store precomputed values needed for the Montgomery multiplication algorithm."
openssl-101f,O2,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@00122b5c.c,"The function takes in six parameters: an integer pointer, an integer, and four BIGNUM pointers. It returns a BIGNUM pointer. 

If a specific field of the integer pointer is equal to zero, the function copies the second and third BIGNUM pointers to the fourth and fifth BIGNUM pointers, respectively. If the fifth BIGNUM pointer is not null, it also copies the fourth field of the integer pointer to it. If any of the copies fail, the function returns null. Otherwise, it returns 1. 

If the specific field of the integer pointer is not zero, the function creates a new BN_CTX object and assigns it to the sixth BIGNUM pointer. If the sixth BIGNUM pointer is null, the function returns null. Otherwise, it calls a function pointer stored in the integer pointer's 0x94 field twice: once with the second and fourth BIGNUM pointers, and once with the third and fifth B."
openssl-101f,O2,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_group_check_discriminant@00122c6c.c,"The `ec_GFp_simple_group_check_discriminant` function checks if the discriminant of a given elliptic curve group is non-zero. It takes two parameters: `param_1`, which is a pointer to the elliptic curve group, and `param_2`, which is a BN_CTX object used for temporary storage of BIGNUM values. 

The function first checks if `param_2` is null and creates a new BN_CTX object if it is. It then uses `BN_CTX_start` to initialize the temporary storage and gets four BIGNUM values (`a`, `a_00`, `r`, and `r_00`) from the context using `BN_CTX_get`. It also gets a fifth BIGNUM value `pBVar1` from the context, which will be used later.

If `pBVar1` is not null, the function checks if the elliptic curve group has a function pointer at offset `0x94` (which corresponds to a function that computes the discriminant)."
openssl-101f,O2,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_group_clear_finish@00122914.c,The function ec_GFp_simple_group_clear_finish takes an integer parameter and clears and frees three BIGNUM variables stored at specific offsets. It does not return anything.
openssl-101f,O2,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_group_copy@001232e8.c,"The function ec_GFp_simple_group_copy takes two parameters, param_1 and param_2, which are pointers to structures representing elliptic curve groups. The function returns a pointer to a BIGNUM structure. The function first copies the values of the BIGNUM structures at offsets 0x48, 0x74, and 0x88 from the second parameter (param_2) to the corresponding offsets in the first parameter (param_1). If any of these copy operations fail, the function returns a null pointer. If all three copy operations succeed, the function sets the value at offset 0x9c in the first parameter to the value at offset 0x9c in the second parameter and returns a pointer to a BIGNUM structure with the value 1."
openssl-101f,O2,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_group_get_degree@00122954.c,"The function takes an integer parameter, likely a pointer to a structure representing an elliptic curve group, and retrieves the degree of the group using the OpenSSL library function BN_num_bits() on the BIGNUM structure located at offset 0x48 within the group structure. The degree of the group represents the number of bits in the order of the group, which is a prime number that determines the size of the group. The function does not return any value."
openssl-101f,O2,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_group_set_curve@0012335c.c,"The `ec_GFp_simple_group_set_curve` function sets the curve parameters for an elliptic curve group over a prime field. It takes four input parameters: `param_1`, `param_2`, `param_3`, and `param_4`, which are pointers to integers or BIGNUMs (big integers) representing the curve parameters. It also takes a BN_CTX (big number context) pointer as the fifth parameter. The function checks if the bit length of `param_2` (which represents the prime field modulus) is at least 3 and its value is positive. If not, it sets an error flag and returns 0. If the input parameters are valid, the function initializes a BN_CTX object if it is not already provided. It then allocates a BIGNUM object `r` from the BN_CTX object and computes the value of `r` as `param_3 mod param_2`. If the curve equation is y^2 = x^3 + `param_1` * x + `r`, the function sets the curve parameters and returns 1. Otherwise, it sets an error flag and returns 0."
openssl-101f,O2,arm,ec_GFp_simple_invert,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_invert@00123a50.c,"The function takes an elliptic curve group parameter and an elliptic curve point as input. It returns the inverse of the input point in the group by subtracting its x-coordinate from the order of the curve, unless the point is at infinity or has a zero x-coordinate, in which case it returns 1."
openssl-101f,O2,arm,EC_GFp_simple_method,./data/decomp/openssl-101f_arm_gcc_O2_extraction/EC_GFp_simple_method@00124068.c,The locked function EC_GFp_simple_method() returns a pointer to a specific EC_METHOD structure stored at memory address ret_9588. The calling convention used by this function is unknown and its parameters cannot be modified.
openssl-101f,O2,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_point_copy@00123324.c,"The function takes in two integer parameters representing memory addresses of structs representing elliptic curve points. It uses the BN_copy function to copy the x, y, and z coordinates of the second point to the first point. If all copies are successful, it sets a flag in the first struct to the same value as the flag in the second struct. The function returns a pointer to the first struct if all copies were successful, or a null pointer if any of the copies failed."
openssl-101f,O2,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_point_finish@001228f4.c,The function frees memory allocated for three BIGNUM variables within a structure representing an elliptic curve point using OpenSSL's BN_free function. It takes an integer parameter assumed to be a pointer to the structure and returns when the memory is released. The function is typically called when the elliptic curve point is no longer needed.
openssl-101f,O2,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_point_get_affine_coordinates@00122dd4.c,"The function takes an integer pointer, an EC_POINT pointer, two BIGNUM pointers, and a BN_CTX pointer as input and returns a BIGNUM pointer. It checks if the EC_POINT is at infinity and returns NULL if it is. If a BN_CTX pointer is not provided, it creates a new one. The function initializes four BIGNUM variables using the BN_CTX and returns NULL if any of them are NULL. If the EC_POINT is the point at infinity, the function sets the affine coordinates to (0,0) and returns 1. Otherwise, it calculates the inverse of the x-coordinate of the point modulo the order of the curve and calculates the y-coordinate using the inverse and the equation of the curve. Finally, the function sets the affine coordinates to the calculated x and y coordinates and returns 1."
openssl-101f,O2,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O2_extraction/ec_GFp_simple_point_set_affine_coordinates@0012347c.c,"The function takes an EC_GROUP object, an EC_POINT object, two BIGNUM objects (param_3 and param_4), and a BN_CTX object (param_5) as input. If both param_3 and param_4 are not NULL, the function sets the affine coordinates of the EC_POINT object using the Jacobian projective coordinates specified by param_3 and param_4, by calling the EC_POINT_set_Jprojective_coordinates_GFp function with input parameters and a BIGNUM object z set to 1. If either param_3 or param_4 is NULL, the function adds an error message to the error queue using the ERR_put_error function and returns 0. The function returns an integer value indicating success (1) or failure (0)."
openssl-101f,O2,arm,encode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O2_extraction/encode_gost_algor_params@0011a494.c,"The function encodes the parameters of an EVP_PKEY object in GOST format. It creates a new ASN1_STRING object and a new GOST_KEY_PARAMS object, determines the type of the input key (either EC or GOST), extracts the necessary information from it, sets the appropriate values in the GOST_KEY_PARAMS object, serializes the GOST_KEY_PARAMS object using the i2d_GOST_KEY_PARAMS function, sets the resulting byte string as the data for the ASN1_STRING object, sets the type of the ASN1_STRING object to indicate that it contains GOST parameters, frees the GOST_KEY_PARAMS object, and returns the ASN1_STRING object. If either the ASN1_STRING object or the GOST_KEY_PARAMS object cannot be created, the function returns NULL."
openssl-101f,O2,arm,get_gost_engine_param,./data/decomp/openssl-101f_arm_gcc_O2_extraction/get_gost_engine_param@0011c1d4.c,"The function takes an integer parameter called ""param_1"" and returns a character pointer (i.e., a string). If the value of ""param_1"" is not equal to zero, the function returns a null pointer (i.e., 0x0). If the global variable ""gost_params"" is not initialized (i.e., it's equal to a null pointer), the function tries to get the value of the environment variable ""CRYPT_PARAMS"" using the ""getenv"" function. If the ""getenv"" function returns a null pointer, the function returns a null pointer. Otherwise, the function allocates memory for a new string using the ""BUF_strdup"" function and assigns the value of the ""CRYPT_PARAMS"" environment variable to that string. Finally, the function returns the value of ""gost_params"", which is either the newly allocated string or the previously initialized string if ""gost_params"" was not null."
openssl-101f,O2,arm,gost2001_param_encode,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost2001_param_encode@0011a024.c,"The function extracts elliptic curve parameters from an EVP_PKEY object in accordance with the GOST R 34.10-2001 standard. It determines the curve name and converts it to an ASN1_OBJECT using the EC_GROUP_get_curve_name() and OBJ_nid2obj() functions, respectively. The resulting encoded data is stored in the memory pointed to by the param_2 pointer using the i2d_ASN1_OBJECT() function."
openssl-101f,O2,arm,gost_cipher_cleanup,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost_cipher_cleanup@0011b394.c,The function takes an integer parameter `param_1` and cleans up resources used by a GOST cipher implementation by calling the `gost_destroy` function with an argument obtained by adding the value stored at memory location `param_1 + 0x60` to 12. It then sets the value at memory location `param_1 + 0x54` to 0 and returns the value 1.
openssl-101f,O2,arm,gost_cipher_ctl,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost_cipher_ctl@0011b7dc.c,"The function gost_cipher_ctl takes four parameters: param_1, param_2, param_3, and param_4. If param_2 is equal to 6, the function generates a random byte string of length specified by the integer value stored at offset 0x58 in param_1 and stores it in the memory location pointed to by param_4. If the random byte generation is successful, the function returns 1. If not, it calls the ERR_GOST_error function with error code 0x6f and 0x7b and returns 0xffffffff. If param_2 is equal to 7, the function checks if param_4 is not equal to NULL. If it is not NULL, it stores the value 0x32a in the memory location pointed to by param_4 and returns 1. If param_4 is NULL, the function returns 0. If param_2 is neither 6 nor 7, the function does not perform any actions."
openssl-101f,O2,arm,gost_cipher_do_cnt,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost_cipher_do_cnt@0011b4ac.c,"The function performs encryption using the GOST cipher in CNT mode. It takes in four parameters: an integer, two pointers to unsigned integers, and a pointer to a byte array. The integer parameter is used to access certain variables stored in memory. It first checks if the byte array pointer stored in memory is null. If it is, it sets a pointer to a default byte array. If it is not null, it checks if the byte array is longer than 7 bytes. If it is, it sets a flag to 0. If it is not, it sets the flag to 1. Next, the function performs the encryption by setting a pointer to the byte array at the integer parameter plus 0x50, checking if it is null, and computing XOR values within a loop. Finally, it sets a value in param_1 at an offset of 0x50 to a variable called uVar10. If param_4 is less than or equal to 2, the function returns 0. Otherwise, it sets a variable uVar10 to 0 and enters a loop that iterates from 0 to param_4 - 2. Within the loop, it computes XOR values and stores them in param_2 at specific offsets."
openssl-101f,O2,arm,gost_cipher_init,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost_cipher_init@0011c020.c,"The `gost_cipher_init` function initializes a GOST cipher context with the provided parameters. It checks if the `app_data` field of the `EVP_CIPHER_CTX` structure is NULL and retrieves the GOST engine parameters by calling `get_gost_engine_param()`. If the retrieved string is empty, it sets the cipher parameters to the default values defined in the `DAT_00195a9c` and `PTR_Gost28147_CryptoProParamSetA_00195aa0` variables. Otherwise, it converts the string to an object identifier (OID) using `OBJ_txt2nid()`. If the conversion fails, it prints an error message and returns 0. If the conversion succeeds, it searches for the corresponding cipher parameters in the `gost_cipher_list` linked list."
openssl-101f,O2,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O2_extraction/GOST_CIPHER_PARAMS_new@0011b224.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function with the ASN1_ITEM pointer PTR_GOST_CIPHER_PARAMS_it_0011b22c. It does not take any input parameters and does not return anything.
openssl-101f,O2,arm,gost_imit_final,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost_imit_final@0011be3c.c,"The function `gost_imit_final` takes in two parameters, an integer `param_1` and an undefined 4-byte value `param_2`. It retrieves two integer variables `iVar1` and `iVar2` from the memory address `param_1 + 0xc` and `iVar2 + 0x103c`, respectively. If `iVar1` is equal to 0, it calls the function `ERR_GOST_error` with the error code 0x8c and the message ""gost_crypt.c"" and jumps to the end of the function. If `iVar1` is not equal to 0, the function checks if another integer variable `iVar1` is equal to 0. If it is, it checks if another integer variable `iVar2 + 0x1038` is not equal to 0. If it is not equal to 0, it sets two integer variables `local_24`."
openssl-101f,O2,arm,gost_imit_init_cpa,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost_imit_init_cpa@0011b788.c,"The function initializes variables in a structure and calls the gost_init() function with the structure pointer, a predefined parameter set, and a pointer to a buffer in the structure. It only uses the first parameter and returns 1 indicating success."
openssl-101f,O2,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O2_extraction/GOST_KEY_PARAMS_new@0011b1f4.c,The function creates a new instance of the GOST_KEY_PARAMS data structure using the ASN1_item_new function and a pointer to an ASN1_ITEM object. It then returns without any further action.
openssl-101f,O2,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_arm_gcc_O2_extraction/GOST_KEY_TRANSPORT_free@0011b170.c,The function frees memory allocated to a GOST key transport object represented by an ASN1_VALUE structure pointed to by param_1. This is done by calling the ASN1_item_free() function with param_1 and a pointer to the ASN1_ITEM structure for the GOST_KEY_TRANSPORT object type. The function then returns.
openssl-101f,O2,arm,gost_param_free,./data/decomp/openssl-101f_arm_gcc_O2_extraction/gost_param_free@0011c17c.c,"The `gost_param_free` function frees the memory allocated for the GOST parameters by checking if `gost_params` is not equal to null, deallocating the memory using `CRYPTO_free`, setting `gost_params` to null, and returning."
openssl-101f,O2,arm,hash_step,./data/decomp/openssl-101f_arm_gcc_O2_extraction/hash_step@0011c248.c,"1. The first function takes in three parameters: an integer and two pointers to unsigned integers. It performs some bitwise operations on the values pointed to by the two pointers and stores the results in local variables. If the pointers are not aligned to 4 bytes, it copies the values byte by byte instead. Next, it initializes a bunch of local variables with undefined values. It then calls another function called gost_enc_with_key with some of the local variables and the two pointers as parameters. After that, it performs some more bitwise operations on the values pointed to by the two pointers and stores the results in more local variables. It then copies some of these values to other local variables and performs some more bitwise operations. Finally, it calls the memmove function to copy some values from one local variable to another and performs some more bitwise operations on the copied values. It then returns without returning any values.

2. The second function takes in three parameters: a pointer to a 256-bit key, a pointer to a 64-byte input block, and a pointer to a 64-byte output block. It first initializes some local variables and performs some bitwise operations on them. It then calls the ""gost_enc_with_key"" function with the key, input block, and a pointer to another local variable. It then performs some more bitwise operations on the local variables and calls the ""gost_enc_with_key"" function again with the key, the previous output block, and another local variable. Finally, it performs some more bitwise operations on the local variables and stores them in the output block pointer. Overall, it seems like this function is performing some sort of encryption or decryption using the GOST cipher algorithm.

3. The third function has six steps: It sets up some local variables and copies some values from the input parameters. It performs some bitwise operations on the local variables. It calls the `gost_enc_with_key` function with some of the local variables as parameters. It performs some more bitwise operations on the local variables. It XORs some of the local variables with the input parameters and copies the result to the output parameter. It checks if a certain value matches a value stored in memory and if not, it throws an error."
openssl-101f,O2,arm,hwcrhk_init,./data/decomp/openssl-101f_arm_gcc_O2_extraction/hwcrhk_init@000f3898.c,"The `hwcrhk_init` function initializes the ""nfhwcrhk"" hardware cryptographic library by loading it with `DSO_load`. It binds various functions from the library using `DSO_bind_func`, including `HWCryptoHook_Init`, `HWCryptoHook_Finish`, `HWCryptoHook_ModExp`, `HWCryptoHook_RSA`, `HWCryptoHook_RSALoadKey`, `HWCryptoHook_RSAGetPublicKey`, `HWCryptoHook_RSAUnloadKey`, `HWCryptoHook_RandomBytes`, and `HWCryptoHook_ModExpCRT`. If any of these functions are not found, an error is raised with `ERR_put_error`. Additionally, if `disable_mutex_callbacks` is not set, the function sets up dynamic locking callbacks with `CRYPTO_get_dynlock_create_callback`, `CRYPTO_get_dynlock_lock_callback`, and `CRYPTO_get_dynlock_destroy_callback`."
openssl-101f,O2,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_arm_gcc_O2_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0011b1b8.c,The function converts an ASN1_VALUE structure into a binary format using ASN1_item_i2d() function and stores it in a buffer pointed to by the second parameter. It takes two parameters - a pointer to an ASN1_VALUE structure and a pointer to a pointer to an unsigned char. It uses an ASN1_ITEM structure (PTR_GOST_KEY_AGREEMENT_INFO_it_0011b1c0) in the conversion process. The function does not return any value.
openssl-101f,O2,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_arm_gcc_O2_extraction/i2d_GOST_KEY_TRANSPORT@0011b158.c,The i2d_GOST_KEY_TRANSPORT function encodes an ASN1_VALUE structure into a byte array using the GOST_KEY_TRANSPORT_it ASN1_ITEM template. It takes two parameters: a pointer to the ASN1_VALUE structure and a pointer to a pointer to an unsigned character (byte array). The resulting byte array is stored in the memory location pointed to by the second parameter. The function does not return any value.
openssl-101f,O2,arm,mul_1x1_ialu,./data/decomp/openssl-101f_arm_gcc_O2_extraction/mul_1x1_ialu@001225e0.c,"The function ""mul_1x1_ialu"" appears to not perform any specific task and simply returns without doing anything."
openssl-101f,O2,arm,param_copy_gost94,./data/decomp/openssl-101f_arm_gcc_O2_extraction/param_copy_gost94@0011a1e4.c,"The `param_copy_gost94` function takes in two `EVP_PKEY` pointers representing the public key and parameters of a GOST R 34.10-94 digital signature algorithm. It retrieves the DSA key and parameters, checks if the base IDs match, and copies the three BIGNUM values from the parameters to the DSA key. If the private key is present, the function computes the public key. It returns an integer value, and if the base IDs do not match, an error is thrown and the function returns 0."
openssl-101f,O2,arm,param_print_gost01,./data/decomp/openssl-101f_arm_gcc_O2_extraction/param_print_gost01@0011ad54.c,"This function takes a BIO object, an EVP_PKEY object, and an integer value as parameters. It extracts an EC_KEY object from the EVP_PKEY object and an EC_GROUP object from the EC_KEY object. It gets the curve name of the EC_GROUP object and indents the output of the BIO object by the value of the third parameter. It prints the parameter set information to the BIO object using the curve name obtained in step 4. It returns 1 if the indentation was successful, or 0 otherwise."
openssl-101f,O2,arm,param_print_gost94,./data/decomp/openssl-101f_arm_gcc_O2_extraction/param_print_gost94@0011ace0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It iterates through the R3410_paramset array, which contains a list of predefined parameter sets for the GOST 94 algorithm. For each parameter set in the array, it converts the corresponding string representation to a BIGNUM and compares it to the BIGNUM value of the EVP_PKEY object. If the values match, the function sets the variable iVar4 to the corresponding NID (numeric identifier) of the parameter set and frees the local_1c BIGNUM object. If the values do not match, the function continues iterating through the R3410_paramset array. Once it has checked all parameter sets in the array, the function prints the NID of the parameter set that matches the EVP."
openssl-101f,O2,arm,pkey_ctrl_gost,./data/decomp/openssl-101f_arm_gcc_O2_extraction/pkey_ctrl_gost@0011a70c.c,"The `pkey_ctrl_gost` function takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. It checks the value of `param_2` and performs different actions based on its value. If `param_2` is 1 or 5, it gets the algorithm information from either `PKCS7_SIGNER_INFO` or `CMS_SignerInfo` structures respectively and sets the algorithm information in `param_3` using `X509_ALGOR_set0` function. If `param_2` is 2 or 7, it encodes the GOST algorithm parameters using `encode_gost_algor_params` function and sets the algorithm information in `param_3` using `X509_ALGOR_set0` function. If `param_2` is 3, it sets the version of `param_4` to `0x329`."
openssl-101f,O2,arm,priv_encode_gost,./data/decomp/openssl-101f_arm_gcc_O2_extraction/priv_encode_gost@0011a8d0.c,"The function takes in two parameters: a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure. It determines the algorithm used in the EVP_PKEY structure and encodes its parameters using encode_gost_algor_params. It also extracts the private key from the EVP_PKEY structure for ECDSA and EdDSA keys and stores it in a BIGNUM pointer called bn. Finally, it converts the private key from BIGNUM format."
openssl-101f,O2,arm,pub_encode_gost94,./data/decomp/openssl-101f_arm_gcc_O2_extraction/pub_encode_gost94@0011a7fc.c,"This function encodes a public key using the GOST R 34.10-94 algorithm. It takes in two parameters: a pointer to an X509_PUBKEY structure and a pointer to an EVP_PKEY structure. The function retrieves the public key and its algorithm parameters from the EVP_PKEY structure. It then encodes the algorithm parameters using the encode_gost_algor_params function, if they exist. Next, the function converts the public key into a binary format and stores it in an ASN1_OCTET_STRING structure. It then encodes this structure into a bit string using i2d_ASN1_OCTET_STRING. Finally, the function sets the algorithm identifier, algorithm parameters, and public key bit string in the X509_PUBKEY structure using the X509_PUBKEY_set0_param function. The function returns 1 on success and 0 on failure."
openssl-101f,O2,arm,pub_print_gost94,./data/decomp/openssl-101f_arm_gcc_O2_extraction/pub_print_gost94@0011ad90.c,"The function takes a BIO object, EVP_PKEY object, and an integer parameter. It extracts the public key from the EVP_PKEY object and prints it to the BIO object. It iterates through a pre-defined list of parameter sets for the GOST R 34.10-94 algorithm and compares them to the parameter set used in the public key. It prints the name of the parameter set to the BIO object once it finds a match and returns 1."
openssl-101f,O2,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O2_extraction/RSA_padding_add_PKCS1_PSS@001213b0.c,"The function adds padding to a message using PKCS1-PSS scheme for RSA encryption. It takes in the RSA key, message hash, hash function used, and salt length (if specified). It calculates the hash size and RSA key size, determines the number of padding bits required, and adds a null byte if necessary. If a salt length is specified, it uses that value, otherwise it calculates the maximum possible length of the salt. It generates a random salt if a salt length is specified, and initializes an EVP message digest context using the specified hash function, updating it with the message hash and salt."
openssl-101f,O2,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O2_extraction/RSA_verify_PKCS1_PSS@00120d3c.c,"The function RSA_verify_PKCS1_PSS verifies a signature using the RSA-PSS algorithm. It takes as input the RSA key, a message hash, the hash function used to generate the hash, the encoded message, and the length of the encoded message. The function initializes an EVP_MD_CTX structure to hold the hash function context, calculates the size of the hash and checks that it is valid, and checks that the length of the encoded message is valid. It also calculates the number of bits in the RSA modulus and the size of the RSA key, checks that the first byte of the encoded message is valid, and adjusts the size of the encoded message if necessary. The function then calculates the number of padding bytes in the signature and checks that it is valid. It generates a mask using PKCS1_MGF1, which is a mask generation function that uses the hash function, and applies the mask to the encoded message to recover the original message."
openssl-101f,O2,arm,sha_block_data_order,./data/decomp/openssl-101f_arm_gcc_O2_extraction/sha_block_data_order@0011d07c.c,"The functions all implement the SHA-1 hash algorithm to process a block or message of data. They use a series of bitwise, logical, and arithmetic operations to transform the input data and update the hash state. The specific operations used are defined by the SHA-1 algorithm specification. The final output hash is stored in an array or returned as a fixed-size output hash. One function takes in a character array and integer value, and checks if the value of the integer is not equal to 0, decrements it, and checks if the character at the current index of the character array is equal to the null character. It then returns. The specific purpose or context of this function is unclear."
openssl-101f,O2,arm,SHA_Final,./data/decomp/openssl-101f_arm_gcc_O2_extraction/SHA_Final@0011e364.c,"The SHA_Final function is the final step in the SHA-1 hashing algorithm. It takes in a pointer to a buffer (md) where the final hash value will be stored, and a pointer to a SHA_CTX structure (c) which contains the intermediate hash values and other state information. The function first calculates the number of bytes in the current block (c->num) and adds a padding byte (0x80) to the end of the block. If the block is not big enough to hold the padding byte and the length of the message, it is filled with zeros and a new block is started. The function then sets the last 8 bytes of the block to the length of the message, in bits. This is done by storing the high and low 32 bits of the length in c->Nh and c->Nl respectively, and then copying the bytes into the block in little-endian order. The final step is to process the last block using the sha_block_data_order."
openssl-101f,O2,arm,start_hash,./data/decomp/openssl-101f_arm_gcc_O2_extraction/start_hash@0011cbf0.c,"The function takes a pointer to an array of 4 undefined 4-byte integers. It retrieves the value of the third element in the array and checks if it is not equal to zero. If it is not zero, the function initializes the first 4 elements of the array with zeros and sets the value of the first element to zero, the second element to zero, the fourth element to zero, and returns 1. If the third element is already zero, the function simply returns the value of the third element."
openssl-101f,O2,arm,sv_body,./data/decomp/openssl-101f_arm_gcc_O2_extraction/sv_body@00026534.c,"The function `sv_body` is the main body of the `s_server` program, which is a simple SSL/TLS server. It allocates a buffer of size 0x4000, sets the non-blocking I/O mode if `s_nbio` is enabled, creates a new SSL context, sets various options and callbacks, and initializes the SSL connection. It creates a new BIO object using either the `BIO_new_dgram` or `BIO_new_socket` function, depending on the SSL version, sets the BIO object as the I/O channel for the SSL object using the `SSL_set_bio` function, and sets the SSL object to the accept state using `SSL_set_accept_state`. It then enters a loop where it waits for input on the socket or stdin, reads it into the buffer using the `raw` function, and performs SSL/TLS operations using OpenSSL library functions such as SSL_accept(), SSL_do_handshake(), SSL_read(), and SSL_write(). The function also handles various commands received from the client and frees all allocated memory and cleans up after the SSL connection is closed."
openssl-101f,O2,arm,__aeabi_idivmod,./data/decomp/openssl-101f_arm_gcc_O2_extraction/__aeabi_idivmod@00124584.c,"The function performs integer division and modulus operation for ARM processors. It takes two integer parameters and returns their quotient and remainder as a pair. It checks if the divisor is zero and returns if it is. Otherwise, it calls a helper function to perform the division. It also checks if the dividend is negative and sets the quotient accordingly. Finally, it calls another helper function."
openssl-101f,O2,arm,__libc_csu_init,./data/decomp/openssl-101f_arm_gcc_O2_extraction/__libc_csu_init@00124c94.c,"The function __libc_csu_init initializes the C runtime environment before the main function is called. It first initializes the static constructors by calling _init(). It calculates the number of function pointers that need to be called and calls each one with the four parameters passed to __libc_csu_init. The function takes four parameters, but they are not used in the function."
openssl-101f,O2,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101f_arm_gcc_O2_extraction/__sha256_block_data_order_from_thumb@00124cf0.c,"These functions all involve cryptographic operations, with several using the SHA-256 hashing algorithm. They take in various inputs, including arrays of integers and bytes, and perform a series of bitwise operations, additions, and rotations to generate a hash value. One function uses a key to encrypt or decrypt input data, while another updates values in an array based on arithmetic operations with another array. Overall, these functions are used for message authentication, digital signatures, and encryption/decryption purposes."
openssl-101f,O2,arm,__udivdi3,./data/decomp/openssl-101f_arm_gcc_O2_extraction/__udivdi3@00124998.c,"The function takes in four unsigned integers as parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_4` is zero, the function performs a division of `param_1` and `param_2` by `param_3`. If `param_4` is not zero, the function performs a division of `param_1` and `param_2` by `param_4`. In both cases, the function uses a series of bitwise operations, division, and multiplication to determine the quotient and remainder of the division. If `param_3` is less than `param_4`, the function sets the quotient to 0 and the remainder to `param_3`. Otherwise, the function initializes several variables and performs a loop to calculate the quotient and remainder of the division of `param_3` and `param_4`."
openssl-101f,O2,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101f_arm_gcc_O2_extraction/___armv7_tick_from_thumb@00124cd8.c,"The function is a timer interrupt handler for an ARMv7 processor. It reads the timer value from a coprocessor register and performs calculations on it using vector instructions. It updates a pointer to a memory location where timer-related data is stored. It checks if the interrupt was triggered while executing a Thumb instruction and performs additional calculations on the timer value if it was. If a certain feature is enabled, the function performs further calculations and halts the processor with a ""bad data"" error. If the feature is not enabled, the function updates memory locations with values and checks a certain pointer."
openssl-101f,O3,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_arm_gcc_O3_extraction/asn1_bio_callback_ctrl@001220f0.c,"The function takes three parameters: an integer param_1, an integer param_2, and a pointer to a function param_3. If the value stored in memory at the address (param_1 + 0x24) is not equal to NULL, it calls the BIO_callback_ctrl function with the parameters *(BIO **)(param_1 + 0x24), param_2, and param_3. If the value stored in memory at the address (param_1 + 0x24) is NULL, the function simply returns without doing anything."
openssl-101f,O3,arm,asn1_bio_ctrl,./data/decomp/openssl-101f_arm_gcc_O3_extraction/asn1_bio_ctrl@00122124.c,"The function `asn1_bio_ctrl` performs control operations on a BIO object (`param_1`) based on a control command (`param_2`) and a parameter (`param_3`). It also takes a pointer to an integer (`param_4`). 

If the `ptr` field of the BIO object is NULL, the function returns 0. 

If the control command is 0x97, the function sets the 10th and 11th elements of the `ptr` field to the first and second elements of `param_4`, respectively, and returns 1. 

If the control command is 0x99, the function sets the 15th element of the `ptr` field to the value of `param_4`, and returns 1. 

If the control command is 0x9a, the function sets the value of `param_4` to the 15th element of the `ptr`."
openssl-101f,O3,arm,asn1_bio_free,./data/decomp/openssl-101f_arm_gcc_O3_extraction/asn1_bio_free@001220fc.c,"The function takes an integer parameter `param_1` and retrieves a pointer from the memory location at `param_1 + 0x20`. If the pointer is not null, it checks if another pointer at an offset of 4 from the retrieved pointer is also not null. If it is not null, it frees the memory at that location using the `CRYPTO_free` function. It then frees the memory at the retrieved pointer location using the same function. Finally, it sets some memory locations to 0 and returns 1. If the retrieved pointer is null, it simply returns 0."
openssl-101f,O3,arm,asn1_bio_write,./data/decomp/openssl-101f_arm_gcc_O3_extraction/asn1_bio_write@001222c4.c,"The `asn1_bio_write` function takes in three parameters (`param_1`, `param_2`, and `param_3`) and returns a `bio_st` pointer. It checks if `param_2` is null and sets `pbVar4` to 1 if it is. If `pbVar4` is not null, it checks if `param_1` has a next bio and a pointer. If either of these is null, it returns `pbVar6`. The function then enters a loop that switches on the `method` field of `pbVar6`. If the `method` field is null, it calls a function stored in the `ptr` field of `pbVar6`, passing in `param_1`, `pbVar6->num_read`, `pbVar6->num_write`, and a value from the `ex_data` field of `pbVar6`. If the function returns 0, the function returns."
openssl-101f,O3,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BIO_asn1_get_suffix@00122540.c,"The function takes in a BIO object, a suffix pointer, and a suffix free pointer. It calls BIO_ctrl with parameters 0x98, 0, and a pointer to local_18. If the result is greater than 0, it sets the psuffix and psuffix_free pointers to local_18 and puStack_14, respectively. The function returns the result of the BIO_ctrl call."
openssl-101f,O3,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BIO_asn1_set_prefix@001224ec.c,The function sets the prefix for a BIO object using a given prefix pointer and control command. It also sets a prefix_free function if provided and returns the result of the control call.
openssl-101f,O3,arm,BN_GF2m_add,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_add@0011f668.c,"The function takes three BIGNUM pointers as input parameters: param_1, param_2, and param_3. It returns an integer value of 1 if the operation is successful, and 0 otherwise. The function first checks the sizes of the input BIGNUMs, and expands param_1 if it is smaller than the larger of the other two BIGNUMs. If the expansion fails, the function returns 0. The function then performs a bitwise XOR operation between the data arrays of param_2 and param_3, storing the result in the data array of param_1. If param_1 was expanded earlier, the function only performs the XOR operation up to the size of the smaller of the two input BIGNUMs. Finally, the function trims any leading zero words from the data array of param_1 and sets its top field to the new size."
openssl-101f,O3,arm,BN_GF2m_mod,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod@0011f940.c,"The function takes three parameters: two integers and a pointer to an integer array, and returns an integer. It first checks if the second integer parameter is zero, and if so, calls ERR_put_error and returns zero. It then determines the size of the integer array pointed to by the third parameter and stores it in a variable. If the size is less than or equal to zero, it sets a pointer to a local integer array. Otherwise, it iterates through the integer array and checks each 32-bit word for any set bits. If a set bit is found, the index of that bit is added to a local integer array. If this array contains more than 6 elements, the function calls ERR_put_error and returns zero. Otherwise, the function sets the last element of the array."
openssl-101f,O3,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_arr@0011f71c.c,"The function BN_GF2m_mod_arr takes two BIGNUMs (param_1 and param_2) and a uint (param_3) as input parameters. It performs a modular reduction operation where param_2 is reduced modulo param_3 and the result is stored in param_1. The function first checks if param_3 is equal to zero. If it is, it sets param_1 to zero and returns 1. Otherwise, it initializes some variables and checks if param_2 and param_1 are the same BIGNUM. If they are not, it expands param_1 if necessary and copies the contents of param_2 to param_1. The function then performs the modular reduction operation using a binary algorithm. It iterates over each word in param_2 (starting from the most significant word) and repeatedly subtracts a multiple of param_3 until the result is less than param_3. The remainder of this subtraction is then stored in the corresponding."
openssl-101f,O3,arm,BN_GF2m_mod_div,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_div@001201f0.c,"The function BN_GF2m_mod_div() performs modular division in binary fields (GF(2^m)). It takes three BIGNUMs, two integers, and a BN_CTX structure as input. The function first computes the inverse of param_4 modulo param_3 using BN_GF2m_mod_inv() and stores the result in a temporary BIGNUM. If this operation fails, the function returns 0. It then allocates memory for an array of integers and populates it with the indices of the non-zero bits in param_4. Finally, the function counts the number of non-zero bits in the array."
openssl-101f,O3,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_div_arr@0012031c.c,"The function takes four integers and a pointer to an integer array as parameters, as well as a BN_CTX pointer. It initializes a BN_CTX object and retrieves a BIGNUM object from it. The function then sets the value of the BIGNUM object to 0 and iterates through the integer array, setting the bit at the position specified by each integer using BN_set_bit(). It then performs a modular division of param_1 by param_2 modulo param_3 using BN_GF2m_mod_div() and the BIGNUM object."
openssl-101f,O3,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_mul@0011fc6c.c,"The function BN_GF2m_mod_mul performs modular multiplication on two BIGNUMs in the binary field GF(2^m). It first calculates the number of bits required to represent the result, allocates memory for an array of integers to store the indices of the non-zero bits in the modulus BIGNUM, populates this array using a bitwise AND operation with the modulus BIGNUM, calculates the number of leading zeroes in the array, and uses this to determine the number of words required to represent the array. If the number of words is greater than the allocated memory, an error is thrown. If not, the function BN_GF2m_mod_mul_arr is called to perform the actual multiplication using the array of indices and the two input BIGNUMs. Finally, the allocated memory is freed and the result of the multiplication is returned."
openssl-101f,O3,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_mul_arr@0011fb08.c,"The function BN_GF2m_mod_mul_arr() takes in five parameters: an integer, two integer arrays, an integer, and a BN_CTX structure. It returns an integer as the result of the computation. The function performs a multiplication of the two input arrays using bn_GF2m_mul_2x2() function and stores the result in a BIGNUM structure. It also performs a modulo operation on the BIGNUM structure using BN_GF2m_mod_arr() function. If the two input arrays are equal, it calls the BN_GF2m_mod_sqr_arr() function with the first two parameters and returns the result. If the two input arrays are not equal, the function allocates memory for a BIGNUM structure using the BN_CTX_get() function. It then sets the size of the BIGNUM structure based on the size of the input arrays and initializes its values to 0. Finally, the function checks if the modulo."
openssl-101f,O3,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_sqr@0011fd4c.c,"The function BN_GF2m_mod_sqr computes the square of a BIGNUM in a binary field GF(2^m) using polynomial basis representation. It allocates memory for a temporary array, converts the input BIGNUM into binary form, computes the number of leading zeros, and calls BN_GF2m_mod_sqr_arr to compute the square of the temporary array. The result is returned after freeing the temporary array. An error is generated if there are no non-zero bits."
openssl-101f,O3,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_sqrt@0012057c.c,"This function calculates the number of set bits in a parameter, allocates memory for an array of integers to store the positions of the set bits, and iterates through the words of the parameter to find the positions of the set bits and store them in the array. If the array is non-empty, it calls BN_GF2m_mod_exp_arr to compute the square root of another parameter modulo the first parameter. If the array is empty, it sets the result to 0 and returns 1."
openssl-101f,O3,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_GF2m_mod_sqr_arr@0011f9e4.c,"The function BN_GF2m_mod_sqr_arr() takes in four arguments: an integer, an integer array, another integer, and a BN_CTX structure pointer. It initializes a BIGNUM structure pointer a and checks if it is NULL. If it is, the function returns 0. Next, the function calculates the size of the array needed to store the result of the squaring operation. If the size of the array is greater than the current size of the BIGNUM structure pointed to by a, the function expands the BIGNUM structure using the bn_expand2() function. The function then performs the squaring operation on the input integer array using a precomputed table of squaring values. The result is stored in the BIGNUM structure pointed to by a. Finally, the function sets the top field of the BIGNUM structure to the correct value by checking the most significant word of the BIGNUM structure for non-zero values."
openssl-101f,O3,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101f_arm_gcc_O3_extraction/bn_GF2m_mul_2x2@00122700.c,"The function `bn_GF2m_mul_2x2` takes in five parameters, performs bitwise operations on the results of either `mul_1x1_neon` or `mul_1x1_ialu` depending on a certain bit in memory, and returns an `ulonglong` value. The function does not have any side effects. The parameters are all of type `undefined4` except for `param_1` which is of type `ulonglong`."
openssl-101f,O3,arm,BN_kronecker,./data/decomp/openssl-101f_arm_gcc_O3_extraction/BN_kronecker@0011ef30.c,"The BN_kronecker function computes the Kronecker symbol of two BIGNUMs, a and b, using the binary algorithm. The Kronecker symbol extends the Legendre symbol to all odd integers a and all odd integers b. The function first initializes two BIGNUM variables, a_00 and a_01, and then checks if a_01 is not null. If a_01 is null, the function returns an error code. Otherwise, it copies the values of a and b into a_00 and a_01, respectively. Next, the function checks if a_01 is zero. If it is, it calculates the Kronecker symbol using the value of a_00. If a_01 is not zero, the function checks if a_00 is negative or less than 1. If."
openssl-101f,O3,arm,by_dir_entry_free,./data/decomp/openssl-101f_arm_gcc_O3_extraction/by_dir_entry_free@000cf7d4.c,"The function ""by_dir_entry_free"" frees memory pointed to by a void pointer parameter, a stack pointer parameter, and the parameter itself using various functions. It also checks for NULL values before freeing memory."
openssl-101f,O3,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_arm_gcc_O3_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0011b23c.c,"The function takes in three parameters: a pointer to an ASN1_VALUE object (param_1), a pointer to a uchar object (param_2), and a long integer (param_3). The function then calls the ASN1_item_d2i function to decode the uchar data pointed to by param_2 into an ASN1_VALUE object pointed to by param_1. The third parameter, param_3, is the length of the uchar data. The ASN1_ITEM pointer passed to the ASN1_item_d2i function is PTR_GOST_CLIENT_KEY_EXCHANGE_PARAMS_it_0011b244, which is likely a pointer to an ASN1_ITEM structure defining the format of the GOST client key exchange parameters. Finally, the function returns without any explicit return value."
openssl-101f,O3,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_arm_gcc_O3_extraction/d2i_GOST_KEY_PARAMS@0011b1dc.c,"The ""d2i_GOST_KEY_PARAMS"" function converts DER-encoded data to an internal representation of GOST KEY PARAMETERS. It takes a pointer to an ASN1_VALUE, a pointer to a uchar array, and the length of the uchar array as arguments. The function uses the ""ASN1_item_d2i"" function with the ""PTR_GOST_KEY_PARAMS_it_0011b1e4"" argument to perform the conversion. The function returns nothing (void)."
openssl-101f,O3,arm,decode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O3_extraction/decode_gost_algor_params@00119d30.c,"The function decodes the algorithm parameters for a GOST key from an X509_ALGOR structure and assigns them to an EVP_PKEY structure. It extracts the algorithm parameters from the X509_ALGOR structure, converts the algorithm OID to a NID, and creates a new EC_KEY or DSA structure if the NID corresponds to a GOST key algorithm (0x32b or 0x32c). The key structure is then filled with the decoded algorithm parameters using either the fill_GOST2001_params or fill_GOST94_params functions. If there is an error during the decoding process, it calls the ERR_GOST_error function and returns a NULL pointer. Finally, it returns a pointer to the decoded algorithm parameters."
openssl-101f,O3,arm,DES_xcbc_encrypt,./data/decomp/openssl-101f_arm_gcc_O3_extraction/DES_xcbc_encrypt@0011e488.c,"The functions are both implementations of the DES algorithm with different modes of operation. The first function, `DES_xcbc_encrypt`, performs an XCBC encryption on the input buffer using the DES algorithm and stores the result in the output buffer. It takes in an input buffer `input`, an output buffer `output`, a length `length`, a DES key schedule `schedule`, an initialization vector `ivec`, and two constant DES cblocks `inw` and `outw`. The second function is an implementation of the Cipher Block Chaining (CBC) mode of the Data Encryption Standard (DES) algorithm. It takes an input plaintext, a key, an initialization vector (IV), and a length as arguments and returns the corresponding ciphertext. The function first sets up the DES key schedule using the provided key. It then processes the input plaintext in blocks of 8 bytes each, XORing each block with the previous block's ciphertext (or the IV for the first block), encrypting the result using DES, and outputting the resulting ciphertext. The function also updates the IV for the next block by XORing it with the previous block's ciphertext. If the input length is not a multiple of 8, the function pads the last block with zeros and processes it as usual. Finally, the function returns the updated IV for the next encryption operation."
openssl-101f,O3,arm,dgram_ctrl,./data/decomp/openssl-101f_arm_gcc_O3_extraction/dgram_ctrl@000a4f0c.c,"The two functions take in different parameters and perform different actions based on the values of those parameters. However, both functions use a switch statement to determine their actions and have a default case where they set a parameter to 0 and return if the input value is not one of the expected values. Additionally, the second function has a security feature that checks for stack buffer overflows."
openssl-101f,O3,arm,dlfcn_bind_func,./data/decomp/openssl-101f_arm_gcc_O3_extraction/dlfcn_bind_func@00121a68.c,"The function takes two integer parameters and checks if they are both non-zero. If they are, it initializes a void pointer variable. It then checks the number of elements in a stack pointed to by the first parameter and retrieves the last element if it exists. If the retrieved element is NULL, it calls ERR_put_error with an error code and additional information. If it is not NULL, the function calls the dlsym function with the retrieved element and the second parameter."
openssl-101f,O3,arm,dlfcn_bind_var,./data/decomp/openssl-101f_arm_gcc_O3_extraction/dlfcn_bind_var@00121b3c.c,"The function takes two integer parameters, param_1 and param_2. If both parameters are not equal to zero, the function attempts to retrieve a symbol from a shared library using dlsym(). If there are no shared libraries loaded, it adds an error message to the error stack using ERR_put_error(). If the symbol cannot be found, an error message is added to the error stack using ERR_put_error() and dlerror() is called to retrieve the error message from dlsym(). Finally, the function returns a pointer to the symbol if it was found, or NULL if there was an error. If either parameter is equal to zero, an error is returned."
openssl-101f,O3,arm,dlfcn_globallookup,./data/decomp/openssl-101f_arm_gcc_O3_extraction/dlfcn_globallookup@00121880.c,"This function uses the dlfcn library to dynamically load a shared object file and lookup a symbol within it. It takes four parameters, but only uses the first and third. It first calls dlopen with a null pointer as the filename and a flag indicating that the symbols should be made available for global symbol resolution. It then calls dlsym with the handle returned by dlopen and the first parameter passed to the function, which is the name of the symbol to look up. If dlsym successfully finds the symbol, it returns a pointer to the symbol's value. The function then calls dlclose to unload the shared object file and returns the value of the symbol. If either dlopen or dlsym fail, the function returns 0."
openssl-101f,O3,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_mont_field_encode@00120c80.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It returns an integer. The function first initializes a BN_MONT_CTX pointer, ""mont"", by dereferencing the value at the address (param_1 + 0xa0). If ""mont"" is not NULL, the function computes the Montgomery encoding of param_3 using the Montgomery reduction factor ""RR"" stored in ""mont"", and stores the result in param_2 using the BN_mod_mul_montgomery() function. If ""mont"" is NULL, the function generates an error message using the ERR_put_error() function and returns 0."
openssl-101f,O3,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_mont_field_sqr@00120c48.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It returns an integer. If the BN_MONT_CTX pointer stored at offset 0xa0 in the integer parameter is not null, the function calls the BN_mod_mul_montgomery function with the second and third parameters as inputs, and the BN_MONT_CTX pointer as the Montgomery context. The result of the multiplication is stored in the second parameter and returned. If the BN_MONT_CTX pointer is null, the function reports an error using the ERR_put_error function and returns 0."
openssl-101f,O3,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_mont_group_init@00120a24.c,"The function initializes a Montgomery group for ECC using `param_1`. It initializes a simple ECC group, sets two values to zero, and returns."
openssl-101f,O3,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@00122b5c.c,"The function takes in six parameters: an integer pointer, an integer, and four BIGNUM pointers. It returns a BIGNUM pointer. If the integer pointer's field is zero, it copies the second and third BIGNUM pointers into the fourth and fifth pointers, respectively. If the fifth pointer is not null, it also copies the sixth BIGNUM pointer into it. If any of these copy operations fails, the function returns null. Otherwise, it returns a pointer to the value 1. If the field in the integer pointer is not zero, the function creates a new BN_CTX object and assigns it to the sixth parameter. If this parameter is already non-null, it is used instead. The function then calls a function pointer stored in the integer pointer, passing in the second and fourth BIGNUM pointers, as well as the sixth parameter."
openssl-101f,O3,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_group_check_discriminant@00122c6c.c,"The function checks the validity of the discriminant for a given elliptic curve group by computing the discriminant using a formula and checking if the result is non-zero. It takes an integer array of elliptic curve parameters and a BN_CTX structure as input, and creates one if not provided. The function initializes BIGNUM variables using BN_CTX_get() and copies the elliptic curve coefficients into these variables. It then computes the discriminant using several OpenSSL functions."
openssl-101f,O3,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_group_clear_finish@00122914.c,"The function clears/free BIGNUM variables stored at offsets 0x48, 0x74, and 0x88 within a structure that is passed as an integer parameter, and returns without any value."
openssl-101f,O3,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_group_copy@001232e8.c,"The function ec_GFp_simple_group_copy takes two pointers to structures representing elliptic curve groups and returns a pointer to a BIGNUM structure. It copies the BIGNUM values from param_2 to param_1 for three different fields using the BN_copy function. If all three copies are successful, the function returns a pointer to a BIGNUM structure with value 1, otherwise it returns a null pointer."
openssl-101f,O3,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_group_get_degree@00122954.c,"The function takes an integer parameter and calls the OpenSSL function BN_num_bits() on a BIGNUM structure located at an offset of 0x48 bytes from the start of the group structure. The function then returns without doing anything with the result. The BIGNUM likely represents the order of the elliptic curve group and the BN_num_bits() function returns the number of bits in the BIGNUM, which is equivalent to the degree of the elliptic curve group."
openssl-101f,O3,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_group_set_curve@0012335c.c,"The `ec_GFp_simple_group_set_curve` function takes in five parameters: `param_1`, `param_2`, `param_3`, `param_4`, and `param_5`. The first parameter is a pointer to an array of integers containing various parameters related to the elliptic curve. The second parameter is a pointer to a `BIGNUM` representing the prime modulus of the field over which the elliptic curve is defined. The third parameter is a pointer to a `BIGNUM` representing the coefficient `a` of the elliptic curve equation `y^2 = x^3 + ax + b`. The fourth parameter is a pointer to a `BIGNUM` representing the coefficient `b` of the elliptic curve equation. The fifth parameter is a pointer to a `BN_CTX` structure used."
openssl-101f,O3,arm,ec_GFp_simple_invert,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_invert@00123a50.c,"The function checks if a point on an elliptic curve is at infinity or has a zero coordinate. If it does, it returns 1 indicating the inverse does not exist. Otherwise, it calculates the inverse of the point by subtracting the y-coordinate from the order of the curve and returns the result."
openssl-101f,O3,arm,EC_GFp_simple_method,./data/decomp/openssl-101f_arm_gcc_O3_extraction/EC_GFp_simple_method@00124068.c,"The function returns a pointer to an EC_METHOD object, which may be related to elliptic curve cryptography using a simple method for the GFp field. The warning message indicates potential incompatibility with the compiler's calling convention. The contents of the returned pointer, stored in ret_9588, are unclear without additional context."
openssl-101f,O3,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_point_copy@00123324.c,"The function takes two integer parameters and copies three BIGNUM structures from the second parameter to the first parameter at specified offsets. It returns a pointer to the first parameter if the copy is successful, or a null pointer if it fails."
openssl-101f,O3,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_point_finish@001228f4.c,The function frees memory allocated for three BIGNUMs used to represent a point on an elliptic curve by calling BN_free on each pointer. It takes the address of the structure containing the pointers as a parameter and does not return anything.
openssl-101f,O3,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_point_get_affine_coordinates@00122dd4.c,"The function takes an EC_POINT object and an EC_GROUP object defining the elliptic curve, along with two BIGNUM objects for storing the x and y coordinates and a BN_CTX object for temporary storage. It checks if the input point is at infinity, allocates memory for temporary BIGNUM objects, and computes the x-coordinate of the point in projective coordinates using the EC_METHOD function pointed to by the ""field"" member of the EC_GROUP object. If the function pointer is NULL, it assumes the x-coordinate is already in affine form and copies it directly to the output parameter."
openssl-101f,O3,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_arm_gcc_O3_extraction/ec_GFp_simple_point_set_affine_coordinates@0012347c.c,"The function takes in an EC_GROUP object, an EC_POINT object, two BIGNUM objects representing the affine coordinates of the point, and a BN_CTX object. If both BIGNUM objects are not null pointers, the function creates a BIGNUM object z with value 1 using BN_value_one(), and then sets the J-projective coordinates of the EC_POINT object using EC_POINT_set_Jprojective_coordinates_GFp() with the affine coordinates and z as inputs. The function returns the result of this operation. If either of the BIGNUM objects are null pointers, the function puts an error message using ERR_put_error() and returns 0."
openssl-101f,O3,arm,encode_gost_algor_params,./data/decomp/openssl-101f_arm_gcc_O3_extraction/encode_gost_algor_params@0011a494.c,"The function encodes the parameters of the GOST algorithm used by an EVP_PKEY object. It creates an empty ASN1_STRING object and a GOST_KEY_PARAMS object, checking if either of these objects cannot be created and returning an error if so. The function then checks the type of the input key, setting the curve name as the first parameter of the GOST_KEY_PARAMS object if it is an EC key, or setting the corresponding NID as the first parameter if it is a GOST R 34.10-2001 key. The second parameter of the GOST_KEY_PARAMS object is set to the OID of the GOST R 34.10-2001 algorithm, and the GOST_KEY_PARAMS object is encoded into the ASN1_STRING."
openssl-101f,O3,arm,get_gost_engine_param,./data/decomp/openssl-101f_arm_gcc_O3_extraction/get_gost_engine_param@0011c1d4.c,"The function takes an integer parameter and returns a character pointer. If the parameter is not equal to zero, it returns a null pointer. Otherwise, it checks if a global variable called ""gost_params"" is null. If it is null, it gets the value of an environment variable called ""CRYPT_PARAMS"" and assigns it to ""gost_params"" using a function called ""BUF_strdup"". Finally, it returns the value of ""gost_params""."
openssl-101f,O3,arm,gost2001_param_encode,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost2001_param_encode@0011a024.c,The function extracts an EC_KEY object from an EVP_PKEY object representing a public key algorithm. It then gets the associated EC_GROUP object and curve name and converts it to an ASN1_OBJECT object. The ASN1_OBJECT object is encoded into a binary format and stored in the memory location pointed to by the param_2 parameter. The function does not return anything.
openssl-101f,O3,arm,gost_cipher_cleanup,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost_cipher_cleanup@0011b394.c,"The function takes an integer parameter (param_1) and performs cleanup for a GOST cipher implementation. It calls the function gost_destroy to destroy the cipher context and free memory, sets a memory location to zero, and returns the value 1."
openssl-101f,O3,arm,gost_cipher_ctl,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost_cipher_ctl@0011b7dc.c,"The `gost_cipher_ctl` function takes four arguments: `param_1`, `param_2`, `param_3`, and `param_4`. 

If `param_2` is equal to 6, the function generates a random sequence of bytes using the `RAND_bytes` function and stores it in the memory pointed to by `param_4`. The number of bytes generated is determined by the integer value stored at the memory location `param_1 + 0x58`. If the `RAND_bytes` function returns a value greater than 0, the function returns 1. Otherwise, it calls the `ERR_GOST_error` function with error codes 0x6f and 0x7b, and returns -1.

If `param_2` is equal to 7, the function checks if `param_4` is not equal to null. If it is not null, the function stores the value 0x32a in the memory."
openssl-101f,O3,arm,gost_cipher_do_cnt,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost_cipher_do_cnt@0011b4ac.c,"The first function implements the GOST cipher algorithm in Counter (CTR) mode. It takes in a GOST context pointer, input buffer pointer, output buffer pointer, and an initialization vector (IV) or counter pointer. It checks if the IV/counter pointer is null and sets it to a default value if needed. Then, it processes the input buffer using the GOST block cipher algorithm in CTR mode, XORing the input block with the output of the algorithm using the current IV/counter value.

The second function takes in four parameters and checks if param_4 is less than or equal to 2. If so, it returns 0. If param_4 is greater than 2, it enters a loop and XORs two bytes from param_1 and param_3, storing the result in param_2. If the loop has not completed all iterations, it XORs two more bytes and stores the result. Finally, it sets a value in param_1 and returns 1."
openssl-101f,O3,arm,gost_cipher_init,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost_cipher_init@0011c020.c,"The `gost_cipher_init` function initializes the GOST encryption algorithm context with a pointer to the `EVP_CIPHER_CTX` structure, key length, and initialization vector. It checks if the `app_data` field of the `EVP_CIPHER_CTX` structure is NULL and gets the GOST engine parameter from the `get_gost_engine_param` function. If the parameter is not found, it uses the default parameter set `PTR_Gost28147_CryptoProParamSetA_00195aa0`. Otherwise, it looks up the parameter set based on the parameter name using the `OBJ_txt2nid` function. If the parameter name is not found, it returns 0. Finally, it initializes the `cipher_data` field of the `EVP_CIPHER_CTX` structure with the parameter."
openssl-101f,O3,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O3_extraction/GOST_CIPHER_PARAMS_new@0011b224.c,The function creates a new instance of GOST_CIPHER_PARAMS using ASN1_item_new() with PTR_GOST_CIPHER_PARAMS_it_0011b22c as its structure pointer. It has no arguments and returns void.
openssl-101f,O3,arm,gost_imit_final,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost_imit_final@0011be3c.c,"The function is the final step in the GOST R 34.13-2015 MAC algorithm. It retrieves the MAC algorithm implementation from the GOST context structure, checks for any remaining data in the input buffer, processes it by calling the gost_imit_update function, checks for padding needed to align input data to a multiple of 8 bytes, and performs key meshing on the input data if the key meshing flag is set in the GOST context structure. The function takes two parameters: param_1, which is a pointer to a GOST context structure, and param_2, which is a pointer to a buffer where the MAC value will be stored. If the MAC algorithm implementation is not found, an error is thrown and the function exits."
openssl-101f,O3,arm,gost_imit_init_cpa,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost_imit_init_cpa@0011b788.c,"The function `gost_imit_init_cpa` initializes variables in a data structure and calls another function with some arguments. It takes four parameters, but only uses the first one. The function returns 1 indicating success."
openssl-101f,O3,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_arm_gcc_O3_extraction/GOST_KEY_PARAMS_new@0011b1f4.c,"The function creates a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new function, with PTR_GOST_KEY_PARAMS_it_0011b1fc as an argument to specify the type. It does not return a value."
openssl-101f,O3,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_arm_gcc_O3_extraction/GOST_KEY_TRANSPORT_free@0011b170.c,The function frees the memory associated with an ASN1_VALUE pointer using ASN1_item_free and an ASN1_ITEM structure that corresponds to the GOST_KEY_TRANSPORT type. It then returns the freed memory.
openssl-101f,O3,arm,gost_param_free,./data/decomp/openssl-101f_arm_gcc_O3_extraction/gost_param_free@0011c17c.c,"The function checks if the global variable ""gost_params"" is not null and frees the memory allocated to it using the CRYPTO_free function, setting the variable to null. It essentially frees the memory allocated to the GOST parameters."
openssl-101f,O3,arm,hash_step,./data/decomp/openssl-101f_arm_gcc_O3_extraction/hash_step@0011c248.c,"The function takes in several parameters, including a key, plaintext, and an output buffer. It performs a series of operations, including XOR, memmove, and a call to the gost_enc_with_key function, to encrypt the plaintext using the key. Finally, it XORs the encrypted data with some additional data and stores the result in the output buffer. The specifics of the encryption algorithm are not clear from this code snippet, but it appears to involve bitwise operations and XOR operations between specific elements of the input parameters.

The function is performing a GOST encryption with a given key and input data. It first initializes some local variables and then calls the GOST encryption function with the key and input data. It then performs some bitwise operations on the output of the encryption function and stores the result in local variables. It then calls the encryption function again with the updated data and performs more bitwise operations on the output. Finally, it returns the encrypted data.

The function takes in three parameters: an integer, and two pointers to unsigned integers. It performs a series of bitwise operations and assignments using these parameters and local variables. If the bitwise OR of the two input pointers is not divisible by 4, the function performs a loop that XORs each byte of the second input parameter with the corresponding byte of the first input parameter and stores the result in a local variable. Otherwise, the function performs a series of XOR operations between specific elements of the two input parameters and stores the results in local variables. The function then calls another function called gost_enc_with_key() with several of these local variables and the first input parameter as arguments. The result of this function call is stored in another local variable. The function then performs a series of XOR and assignment operations between the local variables and the input parameters, storing the results in local variables. Finally, the function performs several bitwise shifts and stores the resulting values in other local variables."
openssl-101f,O3,arm,hwcrhk_init,./data/decomp/openssl-101f_arm_gcc_O3_extraction/hwcrhk_init@000f3898.c,"The `hwcrhk_init` function initializes the hardware crypto hook library by loading the library and binding its functions. It attempts to load the library using the filename ""nfhwcrhk"" or the value of the `HWCRHK_LIBNAME` variable. If the library cannot be loaded, an error is returned. If the library is loaded successfully, the function attempts to bind all the required functions using `DSO_bind_func`. If any of the functions cannot be bound, an error is returned. If all the required functions are successfully bound, the function sets global variables to the function pointers and initializes the RSA key handle index. If the RSA key handle index has already been initialized, the function returns without doing anything. If the library or any of the required functions cannot be loaded or bound, an error is returned. Finally, the function frees the library and sets all the function pointers to null."
openssl-101f,O3,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_arm_gcc_O3_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0011b1b8.c,"The function takes in two parameters: param_1, which is a pointer to an ASN1_VALUE structure, and param_2, which is a pointer to a pointer to an unsigned character (uchar). The function calls the ASN1_item_i2d function, passing in param_1, param_2, and a pointer to an ASN1_ITEM structure (PTR_GOST_KEY_AGREEMENT_INFO_it_0011b1c0). This function is responsible for converting the ASN1_VALUE structure into a DER-encoded byte string and storing it in the memory pointed to by param_2. Finally, the function returns without any value."
openssl-101f,O3,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_arm_gcc_O3_extraction/i2d_GOST_KEY_TRANSPORT@0011b158.c,"The function takes two parameters: param_1, which is a pointer to an ASN1_VALUE type, and param_2, which is a double pointer to an unsigned char array. It uses the ASN1_item_i2d function to convert the ASN1_VALUE type pointed to by param_1 into a binary format and store the result in the unsigned char array pointed to by param_2, using the ASN1_ITEM structure of type GOST_KEY_TRANSPORT_it. The function returns without any value."
openssl-101f,O3,arm,mul_1x1_ialu,./data/decomp/openssl-101f_arm_gcc_O3_extraction/mul_1x1_ialu@001225e0.c,"The function ""mul_1x1_ialu"" is empty and does not perform any operations."
openssl-101f,O3,arm,param_copy_gost94,./data/decomp/openssl-101f_arm_gcc_O3_extraction/param_copy_gost94@0011a1e4.c,"The function takes two EVP_PKEY pointers as input and checks if their base IDs are the same. If they are, it copies the parameters from the second pointer to the first. Specifically, it extracts the DSA key from the first pointer and the BIGNUM values from the second pointer. If the DSA key is not initialized, it creates a new one and assigns it to the first pointer. It then copies the BIGNUM values to the corresponding fields in the DSA key. Finally, if the key is not already initialized, it computes the public key using the GOST94 algorithm. If the second pointer is not initialized, an error is thrown. The function returns 1 if the parameter copy was successful, and 0 otherwise."
openssl-101f,O3,arm,param_print_gost01,./data/decomp/openssl-101f_arm_gcc_O3_extraction/param_print_gost01@0011ad54.c,"The function takes in a pointer to a BIO object, a pointer to an EVP_PKEY object, and an integer value. It retrieves the EC_KEY object from the EVP_PKEY object, retrieves the EC_GROUP object from the EC_KEY object, gets the curve name of the EC_GROUP object and stores it in the variable 'n'. The function then indents the output of the BIO object by the amount specified in the 'param_3' parameter and prints out the curve name of the EC_GROUP object using the BIO_printf function. Finally, the function returns 1 if the indentation was successful, and 0 otherwise."
openssl-101f,O3,arm,param_print_gost94,./data/decomp/openssl-101f_arm_gcc_O3_extraction/param_print_gost94@0011ace0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It iterates through a predefined array of integers and corresponding strings using a while loop. For each integer in the array, it converts the corresponding string to a BIGNUM and compares it with the BIGNUM value obtained earlier from the EVP_PKEY object. If the two BIGNUMs are equal, it returns the integer value from the array. If the loop completes without finding a matching BIGNUM, it frees the local BIGNUM object."
openssl-101f,O3,arm,pkey_ctrl_gost,./data/decomp/openssl-101f_arm_gcc_O3_extraction/pkey_ctrl_gost@0011a70c.c,"The function `pkey_ctrl_gost` takes in four parameters: `param_1` which is a pointer to an `EVP_PKEY` structure, `param_2` which is an integer, `param_3` which is a pointer to an `X509_ALGOR` structure, and `param_4` which is a pointer to a `PKCS7_SIGNER_INFO` structure. The function first sets the local variable `local_20` to the value of `param_3`. It then switches on the value of `param_2`. If `param_2` is 1 or 5, it checks if `param_3` is null, and if not, returns 1. It then sets `local_1c[0]` to the value of `param_3`. It then gets the base id of the `EVP_PKEY` structure pointed to by `param_1`. If `param_2` is..."
openssl-101f,O3,arm,priv_encode_gost,./data/decomp/openssl-101f_arm_gcc_O3_extraction/priv_encode_gost@0011a8d0.c,"The function encodes GOST algorithm parameters and sets them in a PKCS8_PRIV_KEY_INFO structure by taking in a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure as parameters. It gets the ID of the algorithm using EVP_PKEY_base_id(), gets the corresponding ASN1_OBJECT using OBJ_nid2obj(), encodes the GOST algorithm parameters using the encode_gost_algor_params() function and stores the result in pval. If the algorithm is GOST R 34.10-2001, it gets the private key from the EVP_PKEY structure using EC_KEY_get0_private_key() and sets it to bn. If the algorithm is GOST R 34.10-2012, it gets the second element of the BIGNUM array returned by EVP_PKEY_get0() and sets it to bn. It then converts the private key to an ASN1_INTEGER using BN_to."
openssl-101f,O3,arm,pub_encode_gost94,./data/decomp/openssl-101f_arm_gcc_O3_extraction/pub_encode_gost94@0011a7fc.c,"The function encodes a GOST 94 public key into an X509_PUBKEY structure. It takes two parameters, a pointer to the X509_PUBKEY structure and a pointer to the EVP_PKEY structure containing the GOST 94 public key. It gets the object identifier (OID) of the GOST 94 algorithm and the parameters of the public key from the EVP_PKEY structure. If the parameters are not present, it sets the parameter length to -1. Next, it calculates the number of bytes required to store the public key and allocates memory for it. It then converts the public key from a BIGNUM to a byte array and stores it in the allocated memory. It creates an ASN1_OCTET_STRING structure to hold the byte array and sets the data of the structure to the byte array. It then encodes the ASN1_OCTET_STRING structure into a byte array using the i2d_ASN1_OCT function."
openssl-101f,O3,arm,pub_print_gost94,./data/decomp/openssl-101f_arm_gcc_O3_extraction/pub_print_gost94@0011ad90.c,"The function `pub_print_gost94` extracts the public key from an `EVP_PKEY` object and prints it to a `BIO` object with an indent of `param_3` spaces. It then searches for the parameter set used for the key by iterating through a predefined list of parameter sets and comparing them to the one used for the key. Once a match is found, it prints the name of the parameter set to the `BIO` object with the same indent as before. The function returns 1 upon completion."
openssl-101f,O3,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O3_extraction/RSA_padding_add_PKCS1_PSS@001213b0.c,"The function RSA_padding_add_PKCS1_PSS adds padding to a message using the PKCS1 PSS scheme. It takes an RSA key, message hash, hash algorithm, and salt length as input. The function calculates the hash output size and RSA key size, and checks for valid input. If the salt length is greater than 0, it generates a random salt and initializes a hash function. The function then performs a mask generation function."
openssl-101f,O3,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_arm_gcc_O3_extraction/RSA_verify_PKCS1_PSS@00120d3c.c,"The function implements the RSA-PSS signature verification algorithm to authenticate a message signed with a private key using the corresponding public key. It takes the RSA public key, message hash, hash function, signature, and signature length as input. 

The function initializes an EVP message digest context with the specified hash function, computes the hash output size, and checks if it is valid. It also checks the signature length and computes the RSA modulus and key size. It adjusts the signature size if necessary and checks if the signature length plus hash length plus one is less than the RSA key size. 

If the signature is valid, the function computes the mask generation function (MGF1) using the specified hash function."
openssl-101f,O3,arm,sha_block_data_order,./data/decomp/openssl-101f_arm_gcc_O3_extraction/sha_block_data_order@0011d07c.c,"The functions all implement the SHA-1 hashing algorithm, which takes an input message and produces a fixed-length output hash. The algorithm operates on 512-bit blocks of the input message at a time, and the code is processing one such block. The code initializes several variables with constants and with parts of the input message. It then performs a series of bitwise operations and additions on these variables, using logical functions such as XOR, AND, and OR, as well as bit shifts and rotations. These operations are repeated several times, with the output of each iteration being used as input for the next. The final output hash is produced by concatenating the values of the variables at the end of the last iteration. The functions differ in their input parameters and output format, but all ultimately produce a SHA-1 hash value."
openssl-101f,O3,arm,SHA_Final,./data/decomp/openssl-101f_arm_gcc_O3_extraction/SHA_Final@0011e364.c,"The SHA_Final function is the final step in the SHA-1 hashing algorithm. It takes in a pointer to a message digest (md) and a pointer to a SHA_CTX structure (c) which contains the data to be hashed. The function first calculates the number of bytes in the data that have not been processed yet (stored in c->num) and adds a single bit (0x80) to the end of the data. If there is not enough space to add the bit and a 64-bit length value, the function pads the data with zeros and processes the block. Next, the function adds the length of the message in bits to the end of the data in big-endian format. It then processes the final block of data and stores the resulting hash values in the md buffer. Finally, the function clears the SHA_CTX structure and returns 1."
openssl-101f,O3,arm,start_hash,./data/decomp/openssl-101f_arm_gcc_O3_extraction/start_hash@0011cbf0.c,"The function initializes a hash table or other data structure by setting specific values to 0. It takes a pointer to an array of 4 undefined 4-byte values as its parameter, checks if the third element is not equal to 0, and if so, sets the fourth element and subsequent 32 bytes to 0, and sets the first, second, and fourth elements to 0. It returns 1."
openssl-101f,O3,arm,sv_body,./data/decomp/openssl-101f_arm_gcc_O3_extraction/sv_body@00026534.c,"The function `sv_body` is responsible for handling SSL/TLS handshake and communication between server and client. It allocates a buffer, creates a new SSL context, sets various options, and enters a loop to wait for data. It also handles debugging and message callbacks.

The function is a server-side implementation of SSL/TLS protocol using OpenSSL library. It listens for incoming connections on a socket, accepts them using SSL_accept(), and enters a loop to read and write data. It handles various commands received from the client, and if an error occurs, it sets the return value to a negative error code and returns. It also cleans up memory and resources used by OpenSSL library and the connection before exiting."
openssl-101f,O3,arm,__aeabi_idivmod,./data/decomp/openssl-101f_arm_gcc_O3_extraction/__aeabi_idivmod@00124584.c,"The function checks if the second parameter (param_2) is equal to zero. If it is not equal to zero, it calls another function ""_divsi3_skip_div0_test()"". If param_2 is equal to zero, it checks if param_1 is less than zero. If param_1 is greater than zero, it sets param_1 to the maximum positive integer value 0x7fffffff. If param_1 is less than zero, it sets param_1 to the minimum negative integer value -0x80000000. Finally, it calls another function ""__aeabi_idiv0(param_1)"" which performs integer division on param_1."
openssl-101f,O3,arm,__libc_csu_init,./data/decomp/openssl-101f_arm_gcc_O3_extraction/__libc_csu_init@00124c94.c,The function __libc_csu_init initializes the C runtime environment by calling the _init function and iterating over a list of function pointers to call initialization functions for various libraries used by the program. It then returns once all functions have been called.
openssl-101f,O3,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101f_arm_gcc_O3_extraction/__sha256_block_data_order_from_thumb@00124cf0.c,"The following functions implement the SHA-256 hash algorithm on a block of data. They use a series of bitwise operations, additions, and XORs to update the values in the input array. The input data is processed in 16-word blocks and updated based on each block. The functions use pre-defined arrays of constants to perform some of the calculations. The final hash value is a concatenation of the hash values generated for each block. The functions are divided into several rounds, each of which performs a specific set of operations on the input data. The final hash value is stored in specific variables."
openssl-101f,O3,arm,__udivdi3,./data/decomp/openssl-101f_arm_gcc_O3_extraction/__udivdi3@00124998.c,"The function takes in four parameters and performs arithmetic operations to calculate a 64-bit integer result. If param_3 is zero, it returns zero. Otherwise, it calculates the product of param_1 and param_2, and stores the result in a variable. It then calculates the quotient and remainder of the variable divided by param_3, and stores them in variables. If param_4 is not zero, it calculates the product of param_3 and param_4, and stores the result. It calculates the quotient of the previous quotient divided by param_4 and returns it. If param_4 is zero, it performs unsigned integer division of param_1:param_2 by param_3 using bitwise operations and function calls."
openssl-101f,O3,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101f_arm_gcc_O3_extraction/___armv7_tick_from_thumb@00124cd8.c,"The function called ___armv7_tick_from_thumb takes an undefined 4-byte value and an unsigned integer as arguments. It reads a value from a coprocessor register, performs vector operations, and updates a memory location pointer with the result. If the unsigned integer argument is less than 7, it checks if it's zero and jumps to a label if it is. Otherwise, it sets the memory location pointed to by the updated pointer to 0. If the unsigned integer argument is greater than or equal to 7, the function aligns the pointer to a 4-byte boundary (if it isn't already aligned) and sets the memory location to 0 in 4-byte chunks until the remaining size is less than 4 bytes. Finally, it sets the memory location to 0."
openssl-101f,O0,x86,aep_mod_exp.part.0,./data/decomp/openssl-101f_x86_gcc_O0_extraction/aep_mod_exp.part.0@0819e300.c,"The function `aep_mod_exp_part_0` takes five parameters: four pointers to `BIGNUM` structures and a pointer to a `BN_CTX` structure. It returns an integer value. 

The function first attempts to get a connection using the `aep_get_connection()` function. If successful, it calls the `p_AEP_ModExp` function with the provided parameters to perform modular exponentiation. If the modular exponentiation is successful, it updates the connection table and returns 1. If the modular exponentiation fails, it logs an error, closes the connection, updates the connection table, and returns 0.

If the connection attempt fails, it logs an error and returns 0. In this case, it performs modular exponentiation using the `BN_mod_exp` function with the provided parameters and returns the result."
openssl-101f,O0,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_x86_gcc_O0_extraction/asn1_bio_callback_ctrl@081e4db0.c,"The function takes in three parameters: param_1, param_2, and param_3. It first checks if the pointer stored in the memory location (param_1 + 0x24) is not NULL. If it is not NULL, it calls the BIO_callback_ctrl function with the parameters param_2 and param_3, and the pointer stored in (param_1 + 0x24). If the pointer stored in (param_1 + 0x24) is NULL, the function returns 0. The purpose of this function is to provide a callback function for a BIO object. The callback function is used to control the behavior of the BIO object."
openssl-101f,O0,x86,asn1_bio_ctrl,./data/decomp/openssl-101f_x86_gcc_O0_extraction/asn1_bio_ctrl@081e4e70.c,"This function handles control operations on a BIO object. It checks if the BIO object has been initialized and returns 0 if it has not. It then checks the value of the control operation code passed in as the second argument. If the code is 0x97 or 0x95, it sets certain values in the BIO object based on the values passed in through the fourth argument. If the code is 0x98 or 0x99, it retrieves certain values from the BIO object and stores them in the fourth argument. If the code is 0xb, it performs a write operation on the BIO object's next_bio using the data stored in the BIO object and returns the number of bytes written. If the code is not recognized, it returns 0. If the BIO object has a next_bio, the function recursively calls itself with the same arguments on the next_bio. If the next_bio does not have a method or a ctrl function, it sets an error and returns."
openssl-101f,O0,x86,asn1_bio_free,./data/decomp/openssl-101f_x86_gcc_O0_extraction/asn1_bio_free@081e4dd0.c,"The function takes an integer parameter (param_1) and frees the memory allocated to an ASN1_BIO structure pointed to by the pointer stored at offset 0x20 from the start of the structure. If the pointer is not null, the function first checks if the pointer stored at an offset of 4 bytes from the start of the structure is not null. If it is not null, the memory allocated to it is freed using CRYPTO_free() function. The memory allocated to the ASN1_BIO structure itself is then freed using CRYPTO_free() function. The function also sets the values stored at offsets 0xc, 0x14, and 0x20 to 0 before returning 1 to indicate success. If the pointer is null, the function returns 0 to indicate failure."
openssl-101f,O0,x86,asn1_bio_write,./data/decomp/openssl-101f_x86_gcc_O0_extraction/asn1_bio_write@081e5170.c,"The function takes in a BIO object, a pointer to data, and the length of the data. It checks if the input parameters are valid and then retrieves some variables from the BIO object's internal data structure. It then enters a loop based on the value of one of these variables. If the variable is less than 5, the function performs a switch statement based on the value of the variable. Depending on the case, the function may perform operations such as calculating the size of an ASN.1 object, writing data to the next BIO object in the chain, or calling a callback function. If the variable is greater than or equal to 5, the function clears some flags in the BIO object and returns 0. The function returns the number of bytes written to the BIO object."
openssl-101f,O0,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BIO_asn1_get_suffix@081e5580.c,"The function takes a BIO object, a pointer to a pointer to an undefined type (psuffix), and a pointer to a pointer to an undefined type (psuffix_free) as input parameters. It returns an integer value. The function first declares some local variables and initializes them. It then calls the BIO_ctrl() function with the control command 0x98 and sets the output parameter to the address of the local variable local_18. If the return value of BIO_ctrl() is greater than zero, it sets the values of psuffix and psuffix_free to the values of local_18 and local_14, respectively. Finally, the function checks if the value of local_10 is equal to the value of *(int *)(in_GS_OFFSET + 0x14), which is a stack canary. If they are equal, it returns the value of lVar1. Otherwise, it calls the __stack_chk_fail() function, which terminates the program due to a stack overflow or."
openssl-101f,O0,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BIO_asn1_set_prefix@081e5480.c,The function BIO_asn1_set_prefix sets the prefix for a BIO object using the control command 0x95 and a prefix string. It returns the result of the BIO_ctrl call and does not use the prefix_free parameter. It will not return if there is a stack check failure.
openssl-101f,O0,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_get0_nist_prime_224@081e55f0.c,"The function returns a pointer to a BIGNUM structure that contains the value of the NIST prime number for 224-bit elliptic curve cryptography. The value is stored in a static array named ""_bignum_nist_p_224"". The function does not take any parameters and does not modify any data."
openssl-101f,O0,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_get0_nist_prime_384@081e5610.c,"This function returns a pointer to a BIGNUM object representing a pre-defined prime number used in NIST P-384 elliptic curve cryptography. The prime number is stored in a static array named ""_bignum_nist_p_384"". The function does not take any arguments."
openssl-101f,O0,x86,BN_GF2m_add,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_add@081df9d0.c,"The function BN_GF2m_add takes in three parameters: a BIGNUM pointer and two integer pointers, and returns an integer value of 1 upon successful execution and 0 upon failure. It performs addition of two binary polynomials represented by the two integer pointers and stores the result in the BIGNUM pointer. The binary polynomials are represented as arrays of integers, with each integer being a word of 32 bits. The size of the binary polynomials is determined by the second element of the integer pointers. The function first checks if the size of the BIGNUM pointer is less than the size of the larger binary polynomial. If so, it expands the BIGNUM pointer to the size of the larger binary polynomial using the bn_expand2 function. If the expansion fails, the function returns 0. Next, the function XORs the two binary polynomials and stores the result in the BIGNUM pointer. If the size of the smaller binary polynomial is less than the size of the larger one, the missing bits are assumed to be zero."
openssl-101f,O0,x86,BN_GF2m_mod,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod@081dfb70.c,"The function BN_GF2m_mod takes in two BIGNUM pointers and an integer pointer, and returns an undefined value. It first checks if the second parameter has a non-zero value in its second field. If it is zero, an error message is printed and the function returns 0. The function then creates an array of integers called local_38, and populates it with the indexes of the non-zero bits in the second parameter. If there are more than 6 non-zero bits, an error message is printed and the function returns 0. If the first non-zero bit is at index 0, the function sets the first parameter to 0 and returns 1. Otherwise, if the first parameter is not equal to the second parameter, it expands the first parameter if necessary and copies the values of the second parameter into it. Then, it calls the function BN_GF2m_mod_arr_part_0() and returns its result."
openssl-101f,O0,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_arr@081dfad0.c,"The function BN_GF2m_mod_arr performs a modulo operation on binary polynomials represented as BIGNUMs. It takes three parameters: a BIGNUM pointer param_1, a BIGNUM pointer param_2, and an integer pointer param_3. If the integer pointed to by param_3 is zero, the function sets the value of param_1 to 0 and returns 1. If the integer pointed to by param_3 is not zero, the function checks if param_1 and param_2 are the same BIGNUM. If they are not, it expands the memory allocation of param_1 to match the size of param_2 and copies the values of param_2 into param_1. Finally, the function calls the function BN_GF2m_mod_arr_part_0 and returns its result."
openssl-101f,O0,x86,BN_GF2m_mod_div,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_div@081e1450.c,"The function BN_GF2m_mod_div() takes in five arguments - three undefined 4-byte variables, a pointer to a BIGNUM structure named param_4, and a pointer to a BN_CTX structure named param_5. The function starts a BN_CTX context using BN_CTX_start() and obtains a BIGNUM structure from the context using BN_CTX_get(). If the obtained BIGNUM structure is NULL or if the result of calling BN_GF2m_mod_inv() with param_3, param_4, and param_5 as arguments is 0, the function sets uVar7 to 0 and jumps to the end of the function. Otherwise, it proceeds with the computation. The function computes the number of bits in param_4 and allocates memory for a buffer of size (number of bits + 1) * 4 using CRYPTO_malloc(). If the allocation fails, the function sets uVar7 to 0 and jumps to the end of the."
openssl-101f,O0,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_div_arr@081e1600.c,"The function BN_GF2m_mod_div_arr() takes in four parameters: param_1, param_2, param_3, and param_4, and a BN_CTX structure pointer param_5. It initializes two BIGNUM structure pointers, a and pBVar3, and calculates the inverse mod param_3 using BN_GF2m_mod_inv(). It then populates an array with the indices of the set bits in a and checks if the array has any elements or if the number of set bits in a is zero. If either of these conditions is true, the function returns 0. Otherwise, it continues with the calculation."
openssl-101f,O0,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_mul@081e0b40.c,"The function BN_GF2m_mod_mul performs modular multiplication on two BIGNUMs in the binary field GF(2^m). It first allocates memory for an array of integers to store the indices of the non-zero bits in the first BIGNUM, populates this array with the indices of the non-zero bits in the BIGNUM, and then calls the BN_GF2m_mod_mul_arr function to perform the modular multiplication using the populated array and returns the result. If there is an error in the process, an error code is returned, and the allocated memory is freed."
openssl-101f,O0,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_mul_arr@081dff10.c,"The three functions perform mathematical operations on binary polynomials using BIGNUM and BN_CTX data types. 

The function BN_GF2m_mod_mul_arr multiplies two binary polynomials represented as arrays of uints and reduces the result modulo a third binary polynomial. It uses a schoolbook multiplication algorithm and bitwise XOR operation for reduction. 

The function performs modular squaring of a binary polynomial represented as a BIGNUM data type. It uses a precomputed reduction polynomial and a lookup table of square values for each byte. 

The function implements multiplication of two binary polynomials in GF(2^m) field using the Karatsuba algorithm. It recursively calls itself on smaller sub-polynomials until the base case of degree 1 is reached, at which point it performs a simple multiplication. It normalizes the output BIGNUM by removing any leading zero coefficients."
openssl-101f,O0,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_sqr@081e0c90.c,"This function computes the number of bits in the input BIGNUM and adds 1. It then allocates memory for an array of integers to store the positions of the set bits in the input BIGNUM. The function iterates over the words in the input BIGNUM and for each word, iterates over its bits to find the positions of the set bits. It stores the positions of the set bits in the allocated array. If the array is not empty, the function performs a modular squaring operation on the array using BN_GF2m_mod_sqr_arr. Finally, the function frees the allocated memory and returns the result of the modular squaring operation."
openssl-101f,O0,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_sqrt@081e1c00.c,"The function BN_GF2m_mod_sqrt computes the square root of a binary polynomial modulo a given binary polynomial. It takes four parameters: a BIGNUM pointer to store the result, an integer to specify the irreducible polynomial, a BIGNUM pointer to the modulus polynomial, and a BN_CTX pointer for temporary variables. The function first calculates the number of bits in the modulus polynomial and allocates memory for an array of integers to store the positions of the non-zero bits in the modulus polynomial. It then scans the modulus polynomial from the most significant bit to the least significant bit, and for each non-zero bit, it adds the position of the bit to the array. If the array is not empty, the function sets the most significant bit of a new BIGNUM variable and computes the modular square root of this variable using the array of non-zero bit positions as exponents. The result is stored in the first parameter passed to the function. If the array is empty or the computation fails, the function returns an error code."
openssl-101f,O0,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_GF2m_mod_sqr_arr@081dfcf0.c,"The function BN_GF2m_mod_sqr_arr() takes four parameters - a BIGNUM pointer, two integer pointers, and a BN_CTX pointer. It starts a BN_CTX context and gets a BIGNUM pointer from the context. If the pointer is NULL, the function returns false. If the size of the BIGNUM pointer is less than twice the value of the second integer pointer, the function expands the size of the BIGNUM pointer. If the expansion fails, the function returns false. If the size of the BIGNUM pointer is large enough, the function computes the square of the binary polynomial represented by the integer array pointed to by the second integer pointer and stores the result in the BIGNUM pointer using a precomputed table of values."
openssl-101f,O0,x86,BN_kronecker,./data/decomp/openssl-101f_x86_gcc_O0_extraction/BN_kronecker@081dec60.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs a and b. It initializes two BIGNUM variables a_00 and a_01 using the BN_CTX_get function and copies the value of a into a_00 and b into a_01 using the BN_copy function. If either a_01 or a_00 is NULL or the BN_copy function fails, the function returns -2. It checks if either a_00 or a_01 is odd and shifts a_01 to the right until it becomes even. It also calculates a value local_24 based on the parity of a_00 and a_01. If a_01 is negative, it negates the value of local_24. It then loops through the bits of a_00, and for each bit, it shifts a_00 to the right until it becomes odd and calculates a new value for local_24."
openssl-101f,O0,x86,by_dir_entry_free,./data/decomp/openssl-101f_x86_gcc_O0_extraction/by_dir_entry_free@08168760.c,"The function takes a double pointer to a parameter (param_1). If the value of the pointer pointed to by param_1 is not equal to NULL, it frees the memory pointed to by the pointer using CRYPTO_free() function. If the value of the third element of the array pointed to by param_1 (param_1[2]) is not equal to NULL, it pops all elements from the stack pointed to by param_1[2] and frees the memory associated with each element using the by_dir_hash_free() function. Finally, it frees the memory pointed to by param_1 using CRYPTO_free() function."
openssl-101f,O0,x86,cswift_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O0_extraction/cswift_rand_bytes@081a0320.c,"The `cswift_rand_bytes` function generates random bytes using the CryptoSwift hardware accelerator. It acquires an access context using the `CSwift_AcquireAccContext` function, generates random bytes in chunks of 1024 bytes or less using the `CSwift_SimpleRequest` function, and copies the generated bytes to a buffer. If the number of bytes to generate is not a multiple of 4, the remaining bytes are copied using byte-wise copying. The access context is released using the `CSwift_ReleaseAccContext` function. If any error occurs, an error message is added to the output."
openssl-101f,O0,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_x86_gcc_O0_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9cf0.c,"The function takes in three parameters: a pointer to an ASN1_VALUE pointer, a pointer to a uchar pointer, and a long integer. It calls the ASN1_item_d2i function with these parameters and a pointer to an ASN1_ITEM object of type GOST_CLIENT_KEY_EXCHANGE_PARAMS_it to decode an ASN.1 encoded structure into a C structure. The function returns without any explicit value."
openssl-101f,O0,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_x86_gcc_O0_extraction/d2i_GOST_KEY_PARAMS@081d9bf0.c,"The function decodes a uchar array into an ASN1 structure of type GOST_KEY_PARAMS using the ASN1_item_d2i function and stores it in the memory location pointed to by the first parameter. It takes in three parameters - a pointer to an ASN1_VALUE structure, a pointer to a uchar array, and a long integer - and returns without any value."
openssl-101f,O0,x86,decode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O0_extraction/decode_gost_algor_params@081d78c0.c,"The function takes in an EVP_PKEY object and an X509_ALGOR object as parameters. It extracts the algorithm parameters from the X509_ALGOR object, which should contain a GOST algorithm identifier and associated parameters. It then decodes the parameters and sets them in the EVP_PKEY object. First, it extracts the algorithm identifier and parameters from the X509_ALGOR object using the X509_ALGOR_get0 function. If the algorithm identifier is not a GOST identifier, it returns an error. If the algorithm identifier is a GOST identifier, it uses the d2i_GOST_KEY_PARAMS function to decode the parameters. This function returns a pointer to an ASN1_OBJECT structure that contains the decoded parameters. It then extracts the specific GOST algorithm being used from this structure using the OBJ_obj2nid function. Depending on the specific GOST algorithm being used, it then sets the appropriate parameters in the EVP_PKEY object. For the GOST R 34.10-200."
openssl-101f,O0,x86,DES_xcbc_encrypt,./data/decomp/openssl-101f_x86_gcc_O0_extraction/DES_xcbc_encrypt@081ddf90.c,"The functions take in input byte arrays, output byte arrays, length values, DES key schedules, initialization vectors (IVs), and flags indicating whether to encrypt or decrypt. 

If the flag is set to encrypt, the functions perform CBC or XCBC encryption on the input byte array using the DES algorithm and key schedule. They process the input in 8-byte blocks, XORing the current block with the previous output block and the IV, encrypting the result using DES, and outputting the encrypted block. The IV is updated to the last encrypted block. If the input length is not a multiple of 8, the functions pad the last block with zeros and encrypt it using the same process. 

If the flag is set to decrypt, the functions perform CBC or XCBC decryption on the input byte array using the DES algorithm and key schedule. They process the input in 8-byte blocks, decrypting the block using DES. The CBC function initializes some variables, including the previous output block (which is the IV for the first block), and loops through the input buffer in blocks of 8 bytes. The XCBC function uses two constant DES blocks (inw and outw). 

Finally, the functions update the IV to be the last encrypted block and return the output buffer."
openssl-101f,O0,x86,dgram_ctrl,./data/decomp/openssl-101f_x86_gcc_O0_extraction/dgram_ctrl@08120f10.c,"The function `dgram_ctrl` takes four arguments: `param_1`, `param_2`, `param_3`, and `param_4`. It initializes local variables and performs different operations based on the value of `param_2`, such as setting and getting socket options using `setsockopt` and `getsockopt`, setting and getting the size of a datagram, and copying data between memory locations. It returns a `size_t` value depending on the operation performed.

The function takes four parameters: a pointer to a buffer (__src), a size_t value (param_3), a pointer to an integer (param_4), and an integer value (param_1). It declares a local variable and uses a switch statement to determine what action to take based on the value of `param_1`. If `param_1` is 0x67, it checks if the first two bytes of the buffer are equal to 10 and if the third and fourth bytes are equal to 0. If these conditions are met and the fifth byte is equal to -0x10000, then `param_3` is set to 0x224. If `param_1` is 0x68, it checks if the value at the memory address `param_1+0x10` is not equal to 0."
openssl-101f,O0,x86,dlfcn_bind_func,./data/decomp/openssl-101f_x86_gcc_O0_extraction/dlfcn_bind_func@081e4350.c,"The function dlfcn_bind_func takes two integer parameters and checks if either parameter is equal to 0. If so, it sets variables to specific values. If not, it gets the number of items in a stack and stores it in a variable. If the stack is empty, it sets variables to specific values. Otherwise, it gets the last item in the stack and calls dlsym with that item and the second parameter. If dlsym returns 0, an error is logged and 0 is returned. Otherwise, the value returned by dlsym is returned."
openssl-101f,O0,x86,dlfcn_bind_var,./data/decomp/openssl-101f_x86_gcc_O0_extraction/dlfcn_bind_var@081e4450.c,"The function dlfcn_bind_var takes two integer parameters, param_1 and param_2. It checks if either of the parameters is 0 and returns an error code if so. It retrieves the number of elements in a stack pointed to by param_1+4, and if the number is less than 1, it returns another error code. Otherwise, it retrieves the last element of the stack and uses it as a handle to search for a symbol named param_2 using the dlsym function. If the symbol is found, it returns its address, otherwise it returns an error code. If the last element of the stack is null, it returns yet another error code. Finally, if any error occurs, it logs an error message and returns 0."
openssl-101f,O0,x86,dlfcn_globallookup,./data/decomp/openssl-101f_x86_gcc_O0_extraction/dlfcn_globallookup@081e4070.c,"The function takes in an undefined 4-byte parameter and returns an undefined 4-byte value. It uses the dlfcn library to dynamically load a shared object file at runtime using the dlopen() function. It sets the mode parameter to 1, which means that the symbols defined in the shared object will be made available for symbol resolution of subsequently loaded libraries. If the dlopen() call fails, the function returns 0. Otherwise, it uses the dlsym() function to look up the symbol named by the parameter passed in. The function then closes the shared object handle using the dlclose() function. The function returns the address of the symbol, or 0 if the dlopen() call failed or the symbol could not be found."
openssl-101f,O0,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_mont_field_encode@081e2870.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. If the BN_MONT_CTX pointer is not null, the function computes the Montgomery encoding of the second BIGNUM parameter using the Montgomery reduction factor stored in the BN_MONT_CTX structure and stores the result in the first BIGNUM parameter. It then returns the result of the computation. If the BN_MONT_CTX pointer is null, the function generates an error and returns 0."
openssl-101f,O0,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_mont_field_sqr@081e2810.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It first checks if the value at offset 0xa0 in the integer parameter (which is assumed to be a pointer to a BN_MONT_CTX struct) is not equal to NULL. If it is not NULL, the function calls BN_mod_mul_montgomery() with the second and third BIGNUM pointers as parameters, along with the BN_MONT_CTX pointer and the BN_CTX pointer. The result of this multiplication is stored in the second BIGNUM pointer. If the value at offset 0xa0 is NULL, the function calls ERR_put_error() to log an error and returns 0."
openssl-101f,O0,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_mont_group_init@081e2420.c,"The function initializes a Montgomery group structure for an elliptic curve over a finite field. It calls the ec_GFp_simple_group_init function to initialize basic parameters and sets two additional parameters to zero, which will be set later in the initialization process. The function then returns."
openssl-101f,O0,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_nist_field_mul@081e2ba0.c,"The function ec_GFp_nist_field_mul performs multiplication for elliptic curves over prime fields. It takes four parameters: an integer, two BIGNUMs, and a BN_CTX. It checks if any parameters are NULL and logs an error if so. If the BN_CTX parameter is NULL, it creates a new one and performs the multiplication using BN_mul. It then calls a modular reduction function pointer stored in the integer parameter + 0xa8 and returns the result. If the BN_CTX parameter is not NULL, it performs the multiplication using BN_mul and then calls the same modular reduction function pointer. The function returns a boolean indicating success."
openssl-101f,O0,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_nist_group_copy@081e29a0.c,"The ec_GFp_nist_group_copy function takes two parameters, param_1 and param_2, and copies the group parameters from param_2 to param_1. It does this by assigning the value of the 4-byte memory address located at offset 0xa8 in param_2 to the same offset in param_1. It then calls the ec_GFp_simple_group_copy function, which is not shown in the code snippet. Finally, the function returns."
openssl-101f,O0,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_nist_group_set_curve@081e29c0.c,"The function `ec_GFp_nist_group_set_curve` takes in five parameters: `param_1`, `param_2`, `param_3`, `param_4`, and `param_5`. `param_1` is an integer representing a pointer to an elliptic curve group structure. `param_2` is a pointer to a BIGNUM structure representing the prime modulus of the elliptic curve. `param_3` and `param_4` are integers representing the coefficients `a` and `b` of the elliptic curve equation `y^2 = x^3 + ax + b`. `param_5` is a pointer to a BN_CTX structure used for temporary BIGNUM variables. The function first checks if `param_5` is null. If it is null, it creates a new BN_CTX structure and starts it. If it is not null, the function continues with the given `param_5`."
openssl-101f,O0,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e74d0.c,"The function takes in pointers to integers and BIGNUM structures. If the integer value is zero, it copies the BIGNUM structures to the corresponding parameters. Otherwise, it creates a BN_CTX structure and calculates the Jprojective coordinates of the input parameters using a function pointer. The resulting values are then copied to the corresponding output parameters. The function returns a boolean indicating success or failure."
openssl-101f,O0,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_group_check_discriminant@081e76a0.c,"The function `ec_GFp_simple_group_check_discriminant` checks the discriminant of an elliptic curve group defined by the parameters in `param_1`. It first creates a new BN_CTX object if one is not provided. It then retrieves necessary parameters from the BN_CTX object, including `a`, `a_00`, `r`, `r_00`, and `pBVar1`. If `pBVar1` is not null, it checks if the curve is defined by a simple equation or a custom equation. If it is a simple equation, it copies the values of `param_1 + 0x1d` and `param_1 + 0x22` into `a` and `a_00`, respectively. If it is a custom equation, it uses a callback function to get the values of `a` and `a_00`. It then checks if `a` and `a_00` are non-zero."
openssl-101f,O0,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_group_clear_finish@081e7130.c,"The function takes an integer parameter representing an elliptic curve group and clears and frees three BIGNUM variables within the data structure, likely serving as a cleanup function when the group is no longer needed."
openssl-101f,O0,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_group_copy@081e8280.c,"The ec_GFp_simple_group_copy function copies the values of three BIGNUM structures and an undefined 4-byte value from the second parameter to the first parameter. It takes in two integer parameters and returns 1 if all the copies are successful, otherwise it returns 0. The offsets for the copies are 0x48, 0x74, 0x88, and 0x9c."
openssl-101f,O0,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_group_get_degree@081e71a0.c,"The function calculates the degree of an elliptic curve group by calling BN_num_bits on a BIGNUM field at an offset of 0x48 from the start of the structure. The result is not returned, and the function exits."
openssl-101f,O0,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_group_set_curve@081e8370.c,"The function `ec_GFp_simple_group_set_curve` sets the parameters of an elliptic curve group in a simple way over a prime field. The input parameters are `param_1`, `param_2`, `param_3`, `param_4`, and `param_5`. `param_1` is a pointer to an array containing various parameters of the elliptic curve group, such as the curve coefficients and the generator point. `param_2` is a pointer to a `BIGNUM` representing the prime field modulus. `param_3` and `param_4` are pointers to `BIGNUM`s representing the curve coefficients. `param_5` is a pointer to a `BN_CTX` context object. The function first checks if the modulus `param_2` is valid by checking its bit length and whether it is odd. If it is not valid, an error is returned. If `param_5` is `NULL`, a..."
openssl-101f,O0,x86,ec_GFp_simple_invert,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_invert@081e90a0.c,"The function takes an EC_GROUP and an EC_POINT as input and returns an integer value. It checks if the input point is at infinity or not using EC_POINT_is_at_infinity. If the point is at infinity, the function returns 1. If the point is not at infinity, it subtracts the x-coordinate of the point from the order of the elliptic curve group using BN_usub and stores the result in the x-coordinate of the point. Finally, it returns the result of the subtraction operation."
openssl-101f,O0,x86,EC_GFp_simple_method,./data/decomp/openssl-101f_x86_gcc_O0_extraction/EC_GFp_simple_method@081e9c60.c,"The function returns a pointer to an EC_METHOD structure related to elliptic curve cryptography using a prime order finite field. However, the decompiler cannot determine the calling convention used for the function's parameters, resulting in a warning."
openssl-101f,O0,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_point_copy@081e8300.c,"This function takes two integer parameters and copies values from three BIGNUM structures in the second parameter to corresponding offsets in the first parameter. It also copies a value from offset 64. If any BN_copy() call fails, the function returns 0, otherwise it returns 1 for success."
openssl-101f,O0,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_point_finish@081e7100.c,"The function takes an integer parameter `param_1`, likely a pointer to a structure representing an elliptic curve point in GF(p) field. It frees three BIGNUM objects stored in the structure at offsets +4, +0x18, and +0x2c using the BN_free() function, representing the x-coordinate, y-coordinate, and z-coordinate of the point in the projective coordinate system. The function returns without any value."
openssl-101f,O0,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7910.c,"The function retrieves the affine coordinates of an EC_POINT structure using an EC_GROUP structure. If successful, it stores the x-coordinate and y-coordinate in provided parameters. It checks if the point is at infinity, creates a new BN_CTX context if necessary, and uses the EC_GROUP's point conversion function to retrieve the coordinates. If no conversion function exists, it retrieves the coordinates using the point's projective coordinates."
openssl-101f,O0,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O0_extraction/ec_GFp_simple_point_set_affine_coordinates@081e85e0.c,"The function takes an EC_GROUP object, an EC_POINT object, two BIGNUM objects representing the affine coordinates of the point, and a BN_CTX object for temporary storage. If the affine coordinates are provided, it sets the J-projective coordinates of the point using EC_POINT_set_Jprojective_coordinates_GFp and returns the result. Otherwise, it puts an error message in the error queue using ERR_put_error and returns 0."
openssl-101f,O0,x86,encode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O0_extraction/encode_gost_algor_params@081d8ab0.c,"The `encode_gost_algor_params` function takes an `EVP_PKEY` pointer and returns an `ASN1_STRING` pointer. It creates a new `ASN1_STRING` object and a new `GOST_KEY_PARAMS` object, setting error codes and returning NULL if either object cannot be created. The function determines the type of key being used and creates an `ASN1_OBJECT` for it. Lastly, it assigns the `ASN1_OBJECT` pointers to the `GOST_KEY_PARAMS`."
openssl-101f,O0,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_x86_gcc_O0_extraction/general_allocate_boolean.constprop.5@081896c0.c,"The function ""general_allocate_boolean_constprop_5"" checks if two character pointers (param_1 and param_2) and an integer (param_3) are not null. If param_1 is not null and param_2 is not null, the function iterates through the characters in param_1 and checks if each character is in param_2. If a character in param_1 is not in param_2, the function returns -1. If all characters in param_1 are in param_2, the function checks if param_5 is not zero. If param_5 is zero, the function returns -1. If param_5 is not zero, the function dynamically allocates memory for a boolean array and returns a pointer to this array."
openssl-101f,O0,x86,get_gost_engine_param,./data/decomp/openssl-101f_x86_gcc_O0_extraction/get_gost_engine_param@081db3b0.c,"The function takes an integer argument called ""param_1"". If the value of param_1 is not equal to 0, it returns a null pointer. Otherwise, it checks if a global variable called ""gost_params"" is null. If it is null, the function tries to get an environment variable called ""CRYPT_PARAMS"". If this variable is not set, the function returns a null pointer. Otherwise, it copies the value of the environment variable into the ""gost_params"" global variable using the BUF_strdup function. Finally, the function returns the value of the ""gost_params"" global variable."
openssl-101f,O0,x86,gost2001_param_encode,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost2001_param_encode@081d7de0.c,"The function encodes elliptic curve parameters from an EVP_PKEY structure into a binary format. It extracts the EC_KEY structure from the EVP_PKEY, retrieves the EC_GROUP structure from the EC_KEY, gets the curve name from the EC_GROUP, converts it to an ASN1_OBJECT structure using the OBJ_nid2obj() function, encodes the ASN1_OBJECT into a binary format using the i2d_ASN1_OBJECT() function, and stores the result in the param_2 pointer."
openssl-101f,O0,x86,gost_cipher_cleanup,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost_cipher_cleanup@081d9f50.c,The function cleans up resources used by the GOST cipher algorithm by destroying the GOST cipher context and setting a value to an offset before returning 1.
openssl-101f,O0,x86,gost_cipher_ctl,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost_cipher_ctl@081da4a0.c,"The function takes four parameters: two integers, an undefined value, and a pointer to an undefined value. If the second parameter is 6, it generates random bytes and stores them in the memory pointed to by the fourth parameter. If successful, it returns 1; otherwise, it calls the ERR_GOST_error function and returns -1. If the second parameter is 7, it checks if the fourth parameter is not NULL. If it is not, the function sets the value at the memory location pointed to by the fourth parameter to 810 (0x32a in hexadecimal) and returns 1. If the second parameter is any other value, it calls the ERR_GOST_error function and returns -1."
openssl-101f,O0,x86,gost_cipher_do_cnt,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost_cipher_do_cnt@081da0c0.c,"The `gost_cipher_do_cnt` function is part of the GOST block cipher algorithm implementation. It takes four parameters - a pointer to the cipher context, input and output byte arrays, and the length of the input data. The function checks the counter value in the cipher context and sets local variables accordingly. It XORs the counter value with the first byte of the input data and stores the result in the output data, repeating for up to 8 bytes or until the counter value reaches 8."
openssl-101f,O0,x86,gost_cipher_init,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost_cipher_init@081db0d0.c,"This function initializes the GOST cipher in the OpenSSL library. It takes in an EVP_CIPHER_CTX structure, key length, and an initialization vector (IV) as parameters. The function checks if the app_data field of the EVP_CIPHER_CTX structure is null and retrieves the GOST engine parameter from the OpenSSL configuration file. If the parameter is not found, it uses default GOST cipher parameters from the gost_cipher_list structure. Otherwise, it uses the parameters corresponding to the specified OID. The function initializes the cipher data field of the EVP_CIPHER_CTX structure with the GOST cipher parameters and calls the gost_init function to initialize the GOST cipher context. If a key length is provided, the function calls the gost_key function to set the key for the GOST cipher context. If an IV is provided, the function copies it to the oiv field of the EVP_CIPHER."
openssl-101f,O0,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O0_extraction/GOST_CIPHER_PARAMS_new@081d9cb0.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using the GOST_CIPHER_PARAMS_it parameter with the ASN1_item_new function and then returns.
openssl-101f,O0,x86,gost_imit_final,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost_imit_final@081dad70.c,"The function `gost_imit_final` takes two parameters - an integer `param_1` and an undefined 4-byte value `param_2`. It retrieves the value of an integer `iVar1` from the address `param_1 + 0xc`, and then retrieves the value of another integer `iVar2` from the address `iVar1 + 0x103c`. If `iVar2` is equal to 0, an error is thrown and the function returns. If `iVar2` is not equal to 0, the function checks if the value of an integer at the address `iVar1 + 0x1030` is equal to 0. If it is, the function checks if the value of an integer at the address `iVar1 + 0x1038` is not equal to 0. If it is not equal to 0, the function sets the values of two undefined 4-byte variables `local`."
openssl-101f,O0,x86,gost_imit_init_cpa,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost_imit_init_cpa@081da430.c,The function initializes the GOST imitation cipher with CryptoPro parameter set A using an integer parameter. It sets some variables to 0 and one variable to 1 before calling gost_init. The function returns 1 when done.
openssl-101f,O0,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O0_extraction/GOST_KEY_PARAMS_new@081d9c30.c,The function creates a new instance of the GOST_KEY_PARAMS data structure using the ASN1_item_new function and immediately returns without any further processing.
openssl-101f,O0,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_x86_gcc_O0_extraction/GOST_KEY_TRANSPORT_free@081d9ad0.c,"The function takes an ASN1_VALUE pointer named ""param_1"" as input and frees the memory allocated to the object using the GOST_KEY_TRANSPORT_it ASN1_ITEM structure with the ASN1_item_free() function. It does not return any value."
openssl-101f,O0,x86,gost_param_free,./data/decomp/openssl-101f_x86_gcc_O0_extraction/gost_param_free@081db310.c,"The ""gost_param_free"" function frees the memory allocated for the ""gost_params"" variable. If ""gost_params"" is not a null pointer, the function calls ""CRYPTO_free"" to free the memory and sets ""gost_params"" to null. The function then returns."
openssl-101f,O0,x86,hash_step,./data/decomp/openssl-101f_x86_gcc_O0_extraction/hash_step@081db480.c,"The first function takes in three parameters, performs XOR and encryption operations using a GOST encryption function, and returns output through the second input pointer. Its purpose is unclear without more context.

The second function initializes local variables, performs bitwise operations and memmoves, calls the gost_enc_with_key function, and performs more bitwise operations and memmoves. It returns without explicit output, and its purpose is unclear without more context.

The third function takes in two parameters and returns an integer value. It initializes local variables and performs bitwise operations on the first 8 bytes of the first parameter. It then checks if a value is equal to the 10th element of the second parameter and stores values in the 5th, 6th, and 7th elements of the second parameter. If not equal, it calls __stack_chk_fail(). 

Note: The summaries could be further improved by providing more context and clarifying certain details."
openssl-101f,O0,x86,hwcrhk_init,./data/decomp/openssl-101f_x86_gcc_O0_extraction/hwcrhk_init@081a2c00.c,"The function initializes the hardware cryptography library by loading the library and binding its functions for RSA and modular exponentiation operations. It checks if the library has already been loaded and if not, loads it using the default library name or a user-specified name. If the library does not load or the required functions cannot be found, it sets an error code and returns 0. If the library and functions are successfully loaded, it sets up mutex callbacks and returns 1. Finally, it frees the library and resets the function pointers."
openssl-101f,O0,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_x86_gcc_O0_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9b90.c,"The function takes two parameters, a pointer to an ASN1_VALUE and a pointer to a pointer to a uchar. It calls the ASN1_item_i2d function with the parameters passed in, along with an ASN1_ITEM pointer to the GOST_KEY_AGREEMENT_INFO_it item. This function is used to encode the ASN1_VALUE into the uchar buffer pointed to by param_2. Finally, the function returns without a value."
openssl-101f,O0,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_x86_gcc_O0_extraction/i2d_GOST_KEY_TRANSPORT@081d9a90.c,"The function takes two parameters: param_1, which is a pointer to an ASN1_VALUE structure, and param_2, which is a pointer to a pointer to a uchar (unsigned char) array. The function calls the ASN1_item_i2d() function, passing in param_1, param_2, and a pointer to an ASN1_ITEM structure for the GOST_KEY_TRANSPORT type. This function converts the ASN1_VALUE structure to a binary format and stores it in the uchar array pointed to by param_2. Finally, the function returns."
openssl-101f,O0,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101f_x86_gcc_O0_extraction/load_pkcs12.constprop.4@08079a50.c,"The function loads a PKCS12 file and verifies its MAC using PKCS12_verify_mac(). If the verification fails, it tries to retrieve the password using a callback function and tries again. If the verification still fails, it returns 0. If the MAC verification succeeds, the function parses the PKCS12 file using PKCS12_parse() and stores the retrieved EVP_PKEY and X509 objects in the provided pointers. It frees the PKCS12 object and returns 1 if successful."
openssl-101f,O0,x86,padlock_init,./data/decomp/openssl-101f_x86_gcc_O0_extraction/padlock_init@081a9ad0.c,"The ""padlock_init"" function returns a boolean value based on whether ""padlock_use_rng"" or ""padlock_use_ace"" is not equal to zero. It is used to check if the padlock hardware has been properly initialized and configured for cryptographic operations."
openssl-101f,O0,x86,padlock_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O0_extraction/padlock_rand_bytes@081a8be0.c,"The function `padlock_rand_bytes` generates random bytes and stores them in a buffer. If the length is less than 8, it generates random bytes one at a time until the desired length is reached. If the length is greater than or equal to 8, it generates random bytes in blocks of 8 and stores them in the buffer if there is enough space. The function returns 1 if successful and 0 otherwise."
openssl-101f,O0,x86,param_copy_gost94,./data/decomp/openssl-101f_x86_gcc_O0_extraction/param_copy_gost94@081d8120.c,"This function takes two EVP_PKEY pointers representing GOST 94 parameters as input and returns a void pointer. It retrieves the DSA structure and GOST 94 parameters from the input parameters using EVP_PKEY_get0() function. It checks if the base IDs of both parameters are the same using EVP_PKEY_base_id() function and raises an error if they are not the same using ERR_GOST_error() function. If the base IDs are the same, it checks if the GOST 94 parameters pointer is NULL and raises an error using ERR_GOST_error() function and returns NULL if it is. If the GOST 94 parameters pointer is not NULL, the function creates a new DSA structure using DSA_new() function and assigns it to the first parameter using EVP_PKEY_assign() function."
openssl-101f,O0,x86,param_print_gost01,./data/decomp/openssl-101f_x86_gcc_O0_extraction/param_print_gost01@081d8540.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer value. It retrieves the EC_KEY and EC_GROUP objects from the EVP_PKEY object, gets the curve name of the EC_GROUP object, indents the output by the integer value using the BIO_indent() function, and prints the long name of the curve to the BIO object using the BIO_printf() function. The function returns 1 if the indentation and printing were successful and 0 if the indentation failed."
openssl-101f,O0,x86,param_print_gost94,./data/decomp/openssl-101f_x86_gcc_O0_extraction/param_print_gost94@081d85b0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It retrieves the public key from the EVP_PKEY object and creates a new BIGNUM object. It compares the BIGNUM object with the values in the R3410_paramset array to determine the parameter set used for the key. If a matching parameter set is found, the function retrieves the corresponding NID and prints it to the BIO object. If no match is found, it prints a message indicating that the parameter set could not be determined. The function returns 1 upon successful completion."
openssl-101f,O0,x86,pkey_ctrl_gost,./data/decomp/openssl-101f_x86_gcc_O0_extraction/pkey_ctrl_gost@081d8ea0.c,"The function is a control function for handling GOST keys in OpenSSL. It takes in four parameters: a pointer to an EVP_PKEY object, an integer parameter, an integer flag, and a pointer to a PKCS7_SIGNER_INFO object. The function initializes a local variable and then switches on the second parameter. If the parameter is not recognized, the function returns an error code. If the parameter is 1, the function retrieves the signer algorithms from the PKCS7_SIGNER_INFO object and sets the local variables local_28 and local_24 to their respective values. It then proceeds to the next case. If the parameter is 2, the function encodes the GOST algorithm parameters and retrieves the recipient algorithm from the PKCS7_RECIP_INFO object. It then sets the algorithm parameters for the recipient algorithm. If the parameter is 3, the function sets the version of the signer info to 0x329."
openssl-101f,O0,x86,pkey_free_gost94,./data/decomp/openssl-101f_x86_gcc_O0_extraction/pkey_free_gost94@081d8520.c,"The function takes an integer parameter ""param_1"" and checks if the value stored at the memory location ""param_1+0x14"" is not equal to NULL. If it is not NULL, it calls the DSA_free() function to free the memory allocated for the DSA structure. If it is NULL, the function simply returns without doing anything."
openssl-101f,O0,x86,priv_encode_gost,./data/decomp/openssl-101f_x86_gcc_O0_extraction/priv_encode_gost@081d91d0.c,"The function takes in a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure as parameters. It first gets the algorithm identifier for the EVP_PKEY and encodes it using the encode_gost_algor_params() function. It then checks the type of the EVP_PKEY and extracts the private key from it. If the EVP_PKEY is an EC key, it gets the private key using EC_KEY_get0_private_key() function, otherwise, if it is a BIGNUM key, it gets the private key from the EVP_PKEY structure directly. The function then converts the private key to an ASN1_INTEGER structure using the BN_to_ASN1_INTEGER() function and encodes it using the i2d_ASN1_INTEGER() function. Finally, it sets the algorithm identifier, parameters, and private key in the PKCS8_PRIV_KEY_INFO structure using the PKCS8_pkey_set0() function and returns the result."
openssl-101f,O0,x86,pub_encode_gost94,./data/decomp/openssl-101f_x86_gcc_O0_extraction/pub_encode_gost94@081d9080.c,"The function takes in a pointer to an X509_PUBKEY structure and an EVP_PKEY structure and returns an integer value indicating the success or failure of the operation. It retrieves the public key from the EVP_PKEY structure, creates an ASN1_OBJECT structure from the base ID of the key, and encodes GOST algorithm parameters if the save_parameters flag is set. It then calculates the number of bytes needed to store the public key, allocates memory for a buffer of that size, and converts the public key from a BIGNUM structure to a byte array. It creates an ASN1_OCTET_STRING structure from the byte array, sets its value to the byte array in reverse order, and frees the memory allocated for the buffer."
openssl-101f,O0,x86,pub_print_gost94,./data/decomp/openssl-101f_x86_gcc_O0_extraction/pub_print_gost94@081d86a0.c,"The function takes a BIO object, EVP_PKEY object, and integer as parameters, extracts the public key from the EVP_PKEY object, prints it to the BIO object, checks the parameter set used for the key, prints it to the BIO object, and returns 1 upon completion."
openssl-101f,O0,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O0_extraction/RSA_padding_add_PKCS1_PSS@081e36a0.c,"The first function, RSA_padding_add_PKCS1_PSS, adds padding to a message using the PKCS1 PSS scheme. It takes an RSA key, a message hash, a hash function, and a salt length as input. If the salt length is -1, it calculates the salt length based on the RSA key and hash function. If the salt length is -2, it generates a random salt of the appropriate length. Otherwise, it uses the salt length as-is. It then calculates the size of the output buffer based on the RSA key, message hash, and salt length. If the buffer size is too small, it returns an error. It initializes an EVP_MD_CTX structure and updates it with the hash function and message hash. If a random salt is generated, it also generates a mask using the PKCS1 MGF1 function. The function then XORs the mask with the message.

The second function, someFunction, takes a single parameter named ""someParam"" and removes all spaces from the input string. It creates a variable named ""result"" and initializes it to an empty string. It iterates over each character in the ""someParam"" parameter and checks if it is a space character. If it is not a space character, it appends the character to the ""result"" variable. Once all characters have been processed, it returns the ""result"" variable."
openssl-101f,O0,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O0_extraction/RSA_verify_PKCS1_PSS@081e2d80.c,"The function RSA_verify_PKCS1_PSS verifies a message digest signature using the RSA algorithm and PKCS#1 PSS padding scheme. It takes an RSA key, message digest, hash function, signature, and signature length as input. The function initializes a hash function context, computes the hash function output size, and verifies the signature format. It then extracts the masked message and mask using PKCS#1 MGF1 function, XORs the mask with the masked message to obtain the original message digest, and checks the padding. The function initializes the hash function context and updates it if the padding is correct."
openssl-101f,O0,x86,sha_block_data_order,./data/decomp/openssl-101f_x86_gcc_O0_extraction/sha_block_data_order@081dcb10.c,These are summaries of different functions and cannot be consolidated.
openssl-101f,O0,x86,SHA_Final,./data/decomp/openssl-101f_x86_gcc_O0_extraction/SHA_Final@081ddde0.c,"The SHA_Final function is the final step in the SHA-1 hashing process. It takes the last block of input data, pads it with zeros, and computes the hash value. The function requires two arguments: a pointer to the output buffer where the hash value will be stored, and a pointer to the SHA_CTX structure that contains the intermediate hash state.

The function sets a flag variable bVar4 to 0 and retrieves the number of bytes in the input data from the num field of the SHA_CTX structure. It then sets the first byte after the input data to 0x80 to mark the end of the input data. If the number of bytes in the input data is less than 56 (i.e., if there is enough room in the final block for padding and the 64-bit length field), the function pads the block with zeros and calls the sha_block_data_order function to compute the hash value. If the number of bytes in the input data is 56 or more, the function will handle the padding and length field separately."
openssl-101f,O0,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_x86_gcc_O0_extraction/SSL_SESSION_free.part.2@080c59a0.c,"This function frees all memory associated with an SSL session. It first frees any extended data associated with the session using CRYPTO_free_ex_data and securely erases the memory associated with various fields of the session structure using OPENSSL_cleanse. It then frees any certificates and stacks associated with the session, as well as any memory associated with session keys and IDs. Finally, it securely erases the entire session structure using OPENSSL_cleanse and frees the memory using CRYPTO_free."
openssl-101f,O0,x86,start_hash,./data/decomp/openssl-101f_x86_gcc_O0_extraction/start_hash@081dc420.c,"The function takes a pointer to an array of 32-bit integers as its parameter. If the third element of the array is not equal to zero, the function initializes the array by setting specific elements to zero and returns 1. If the third element of the array is equal to zero, the function returns 0."
openssl-101f,O0,x86,surewarehk_finish,./data/decomp/openssl-101f_x86_gcc_O0_extraction/surewarehk_finish@081a4ef0.c,"The function surewarehk_finish() cleans up and frees resources used by the SureWare cryptographic library. It checks if the library has been loaded, calls the p_surewarehk_Finish function pointer for cleanup, frees the DSO object and checks for errors, frees any logstream object, and resets all function pointers to null. It returns 1 if successful and 0 if there was an error."
openssl-101f,O0,x86,sv_body,./data/decomp/openssl-101f_x86_gcc_O0_extraction/sv_body@08067fe0.c,"The function `sv_body` handles the SSL/TLS connection between the server and client. It allocates memory for a buffer, sets options for the SSL object, creates a new `BIO` object, and sets the SSL object to accept mode. It also reads input from the client using `SSL_read` and processes it accordingly, checking for empty input, renegotiating the SSL connection or printing statistics. If the input is not empty, it checks if the SSL connection is waiting for input and calls `SSL_read` to read input from the client. If the SSL connection encounters an error, the function ends."
openssl-101f,O0,x86,__libc_csu_init,./data/decomp/openssl-101f_x86_gcc_O0_extraction/__libc_csu_init@081e9f00.c,"The __libc_csu_init function initializes the C runtime environment by calling _init() to initialize libraries and data structures. It then iterates through the __frame_dummy_init_array_entry array to call initialization functions for global variables and static objects with parameters param_1, param_2, and param_3. The function ultimately returns."
openssl-101f,O0,x86,__udivdi3,./data/decomp/openssl-101f_x86_gcc_O0_extraction/__udivdi3@081e9c70.c,"The function takes four unsigned integer parameters: param_1, param_2, param_3, and param_4. It returns an unsigned 64-bit integer (ulonglong). 

The function performs a division operation between two unsigned integers, param_1:param_2, and param_3:param_4. If param_4 is zero, it performs a regular division operation using the ""/"" operator. Otherwise, it performs a division operation using bit manipulation and multiplication.

If param_4 is zero, the function first checks if param_2 is less than param_3. If it is, it returns the result of the regular division operation. If not, it sets param_3 to the maximum value of an unsigned integer if it is zero, then performs the division operation using the ""/"" operator, and returns the result.

If param_4 is not zero, the function first checks if param_2 is less than param_4. If it is, it returns zero. Otherwise,"
openssl-101f,O1,x86,aep_mod_exp.part.0,./data/decomp/openssl-101f_x86_gcc_O1_extraction/aep_mod_exp.part.0@0819e300.c,"The function `aep_mod_exp_part_0` is a wrapper for a hardware-accelerated modular exponentiation function `p_AEP_ModExp`. It takes in five parameters: `param_1_00`, `param_2_00`, `param_3`, `param_1`, and `param_2`. The first two parameters (`param_1_00` and `param_2_00`) are BIGNUMs representing the base and exponent respectively. `param_3` is another BIGNUM representing the modulus. `param_1` is an output BIGNUM that will contain the result of the modular exponentiation. `param_2` is a BN_CTX structure used for temporary storage during the computation. The function first calls `aep_get_connection` to obtain a connection to the hardware accelerator. If successful, it calls `p_AEP_ModExp` with the input parameters to perform the modular exponentiation. If the call succeeds, it updates the output BIGNUM `param_1` with the result."
openssl-101f,O1,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_x86_gcc_O1_extraction/asn1_bio_callback_ctrl@081e4db0.c,"The C function ""asn1_bio_callback_ctrl"" takes three parameters: an integer ""param_1"", an integer ""param_2"", and a pointer to a function ""param_3"". It checks if the value at memory location ""param_1 + 0x24"" (which is a pointer to a BIO structure) is not equal to NULL. If it is not NULL, then the function calls the ""BIO_callback_ctrl"" function with the parameters ""*(BIO **)(param_1 + 0x24)"" (which is the value of the pointer to the BIO structure), ""param_2"", and ""param_3"". The result of this function call is then returned by the ""asn1_bio_callback_ctrl"" function. If the value at memory location ""param_1 + 0x24"" is NULL, then the function returns 0."
openssl-101f,O1,x86,asn1_bio_ctrl,./data/decomp/openssl-101f_x86_gcc_O1_extraction/asn1_bio_ctrl@081e4e70.c,"The `asn1_bio_ctrl` function takes in a `bio_st` structure pointer, an integer `param_2`, a long integer `param_3`, and an integer pointer `param_4` as input parameters. If the `ptr` field of the `bio_st` structure is NULL, the function returns 0. If `param_2` is 0x97, the function sets the values of two integers in the `piVar2` array (which is a pointer to the `ptr` field of the `bio_st` structure) to the values pointed to by `param_4` and `param_4[1]`, respectively, and returns 1. If `param_2` is 0x95, the function sets the values of two integers in the `piVar2` array to the values pointed to by `param_4` and `param_4[1]`."
openssl-101f,O1,x86,asn1_bio_free,./data/decomp/openssl-101f_x86_gcc_O1_extraction/asn1_bio_free@081e4dd0.c,"The function `asn1_bio_free` takes an integer parameter `param_1` as input. It frees the memory pointed to by the first pointer using the `CRYPTO_free` function. If the second pointer is not null, it frees the memory pointed to by this second pointer using the `CRYPTO_free` function. Finally, it sets the values at offsets of 0xc, 0x20, and 0x14 from the address pointed to by `param_1` to 0 and returns 1 to indicate success. If the first pointer was null, it returns 0 to indicate failure."
openssl-101f,O1,x86,asn1_bio_write,./data/decomp/openssl-101f_x86_gcc_O1_extraction/asn1_bio_write@081e5170.c,"The function `asn1_bio_write` takes in a `BIO` object, a pointer to a buffer (`param_2`), and the length of the buffer (`param_3`). It checks if the input parameters are valid, and if not, returns 0. Next, it checks the state of the `BIO` object and performs different actions based on its current state. 

If the `BIO` object is in state 0, it calculates the size of the ASN.1 object and writes it to the buffer. Then, it sets the state to 3 and proceeds to the next case. If the `BIO` object is in state 1, it writes the buffer to the next `BIO` object in the chain and updates the state accordingly. If the write operation fails, it clears the flags of the `BIO` object and retries. If the `BIO` object is in state 2, it..."
openssl-101f,O1,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BIO_asn1_get_suffix@081e5580.c,"The function takes a BIO object, a suffix pointer, and a suffix_free pointer. It uses BIO_ctrl to retrieve the suffix from the BIO object and stores it in local variables. If the suffix length is greater than 0, it sets pointers to the local variables and returns the suffix length. If there is a stack check failure, it does not return."
openssl-101f,O1,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BIO_asn1_set_prefix@081e5480.c,"The function sets the prefix for a BIO object using a given prefix pointer and a control command. It returns the result of this operation and does not use the prefix_free function. If there is a stack check failure, the function does not return."
openssl-101f,O1,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_get0_nist_prime_224@081e55f0.c,"The function returns a pointer to a BIGNUM structure containing the NIST prime number for the curve P-224, which is stored in a static array called _bignum_nist_p_224. It does not take any parameters or modify any data."
openssl-101f,O1,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_get0_nist_prime_384@081e5610.c,The function returns a pointer to a BIGNUM structure that contains the value of a pre-defined prime number used in NIST P-384 elliptic curve cryptography. The value is stored in a static array called _bignum_nist_p_384. The function does not take any parameters and the calling convention is unknown.
openssl-101f,O1,x86,BN_GF2m_add,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_add@081df9d0.c,"The function BN_GF2m_add takes a BIGNUM struct pointer, and two integer pointers as parameters, and returns an integer value. It checks the sizes of the two integer arrays, swaps them if necessary, and expands the BIGNUM if needed. The function performs the addition of the two integer arrays, treating them as binary polynomials over GF(2^m), and stores the result in the d array of the BIGNUM struct. It trims any leading zero elements from the d array and updates the top field."
openssl-101f,O1,x86,BN_GF2m_mod,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod@081dfb70.c,"The function takes in two BIGNUM pointers and an int array pointer as parameters. It checks if the second element of the int array is zero, and if so, it sets an error and returns 0. It loops through the int array and finds the indices where the bits are set to 1, storing up to 6 of these indices in a local array. If there are more than 6 indices, it sets an error and returns 0. If there are no indices, it sets the first BIGNUM to 0 and returns 1. If there are indices, it expands the first BIGNUM if necessary and copies the data from the second BIGNUM if the first BIGNUM pointer is not equal to the second. It then calls another function, BN_GF2m_mod_arr_part_0(), passing in the first BIGNUM as a parameter, and returns the result of the function call."
openssl-101f,O1,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_arr@081dfad0.c,"The function takes in three parameters: two BIGNUM pointers (param_1 and param_2) and an integer pointer (param_3). It returns an undefined value (represented as ""undefined4"" in the code). The function first checks if the value pointed to by param_3 is 0. If it is, it sets param_1 to 0 using the BN_set_word function and returns 1. If the value pointed to by param_3 is not 0, the function checks if param_1 and param_2 are the same pointer. If they are not the same, the function checks if the number of words in param_2 is greater than the maximum number of words that can be stored in param_1. If it is, it expands the memory allocation for param_1 using the bn_expand2 function. If the memory allocation fails, the function returns 0. If the memory allocation succeeds or if param_1 and param_2 are the same, the function performs additional operations that are not described in this summary."
openssl-101f,O1,x86,BN_GF2m_mod_div,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_div@081e1450.c,The function BN_GF2m_mod_div performs division of two BIGNUMs modulo a third BIGNUM in GF(2^m) field. It first computes the inverse of the divisor using BN_GF2m_mod_inv function. It then computes the bit representation of the dividend and stores it in an array. It then calls the BN_GF2m_mod_mul_arr function to compute the product of the dividend and the inverse of the divisor modulo the third BIGNUM. The function returns 0 if successful and 1 otherwise.
openssl-101f,O1,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_div_arr@081e1600.c,"The function BN_GF2m_mod_div_arr performs a division operation in a finite field. It takes in five parameters: param_1, param_2, param_3, param_4, and a BN_CTX object, param_5. The function initializes a BIGNUM object, a, to zero and sets certain bits of a based on the values in param_4. It then computes the inverse of a modulo param_3 using BN_GF2m_mod_inv and allocates memory for an array of integers, ptr, populated with the indices of the set bits in a. Finally, the function calls BN_GF2m_mod_mul_arr with param_1, param_2, pBVar3, and ptr as parameters and returns a uint value indicating success or failure."
openssl-101f,O1,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_mul@081e0b40.c,"The function BN_GF2m_mod_mul() performs modular multiplication in the GF(2^m) and takes in a BIGNUM pointer and four other parameters. It calculates the number of bits in the BIGNUM and allocates memory for a temporary buffer to store the indices of the non-zero bits in the BIGNUM. It then iterates through each word in the BIGNUM and checks if the word has any non-zero bits. If a non-zero bit is found, the index of that bit is added to the temporary buffer. The function checks if the temporary buffer is smaller than the allocated memory or not and pads it with 0xffffffff if necessary. Finally, the function calls the BN_GF2m_mod_mul_arr() function with the temporary buffer and other parameters, and returns the result of that function."
openssl-101f,O1,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_mul_arr@081dff10.c,"The following functions perform modular multiplication of two BIGNUMs in different ways:

1. Function BN_GF2m_mod_mul_arr takes two binary polynomials represented as arrays of integers in GF(2^m) field and a modulus polynomial as input parameters. It uses the schoolbook multiplication method to perform the multiplication and reduces the result modulo the modulus polynomial.

2. Function BN_mod_mul_montgomery takes two BIGNUMs, an integer, and a BN_CTX as input parameters. It performs a modular multiplication using a precomputed table and stores the result in the first BIGNUM.

3. Function BN_mod_mul takes two BIGNUMs, an integer, and a BN_CTX as input parameters. It performs a modular multiplication using a different algorithm than BN_mod_mul_montgomery and stores the result in the first BIGNUM."
openssl-101f,O1,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_sqr@081e0c90.c,"The function BN_GF2m_mod_sqr() computes the square of a binary polynomial in GF(2^m) and returns the result. It first computes the number of bits in the input polynomial and allocates memory to store an array of indices of the non-zero bits. It then populates this array with the indices of the non-zero bits in the input polynomial. Next, it checks if the input polynomial is zero and sets a flag accordingly. If the input polynomial is non-zero, it calls the function BN_GF2m_mod_sqr_arr() to compute the square of the polynomial using the array of non-zero bit indices. If the input polynomial is zero, it returns 0. Finally, it frees the memory allocated for the array of non-zero bit indices and returns the result of the computation."
openssl-101f,O1,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_sqrt@081e1c00.c,"The function BN_GF2m_mod_sqrt computes the square root of a binary polynomial in GF(2^m) using the Rabin-Miller algorithm. It takes as input a BIGNUM param_1 to store the result, an unsigned integer param_2 indicating the degree of the polynomial, a BIGNUM param_3 representing the polynomial, and a BN_CTX param_4 for temporary variables. The function first allocates an array of integers ptr to store the indices of the non-zero bits in the polynomial. It then loops through the bits of the polynomial and adds their indices to ptr. If ptr is smaller than the degree of the polynomial, it adds an extra element to ptr with the value 0xffffffff. Next, the function checks if the first bit of the polynomial is set. If it is, it computes the square root using the Rabin-Miller algorithm by setting a BIGNUM a to the highest non-zero bit of the polynomial and calling BN_GF2m_mod."
openssl-101f,O1,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_GF2m_mod_sqr_arr@081dfcf0.c,"The function takes four parameters: a BIGNUM pointer, two integer pointers, and a BN_CTX pointer. It returns a boolean value. The function starts the BN_CTX and gets a new BIGNUM pointer from it. If it fails to get a new BIGNUM pointer, it returns false. It checks if the size of the new BIGNUM pointer is less than twice the size of the second integer parameter. If it is, it expands the new BIGNUM pointer to twice the size of the second integer parameter. It performs a squaring operation on the second integer parameter and stores the result in the new BIGNUM pointer. It then sets the top value of the new BIGNUM pointer to twice the size of the second integer parameter and removes any leading zeros. If the third integer parameter is zero, it sets the first parameter to zero and returns true. If the new BIGNUM pointer is not equal to the first parameter, it checks if the size."
openssl-101f,O1,x86,BN_kronecker,./data/decomp/openssl-101f_x86_gcc_O1_extraction/BN_kronecker@081dec60.c,"The BN_kronecker function calculates the Kronecker symbol of two BIGNUMs a and b using the binary method. It initializes two BIGNUM variables a_00 and a_01 using the BN_CTX_get function and copies the value of a to a_00 and b to a_01 using the BN_copy function. If either a_01 or a_00 is null or the BN_copy function fails, the function returns -2. Otherwise, it checks if either a_00 or a_01 is odd. If either is odd, it sets the Kronecker symbol to 0 or 1 depending on the values of a_00 and a_01. If both a_00 and a_01 are even, it divides a_01 by 2 until it becomes odd. It then sets the Kronecker symbol to 1 or -1 depending on the value of a_00 and a_01. It then divides a."
openssl-101f,O1,x86,by_dir_entry_free,./data/decomp/openssl-101f_x86_gcc_O1_extraction/by_dir_entry_free@08168760.c,"The function ""by_dir_entry_free"" frees memory pointed to by a void pointer and an array's third element if they are not NULL, using ""CRYPTO_free"" and ""sk_pop_free"" with ""by_dir_hash_free"" as its parameter. It then frees the memory pointed to by the parameter and returns."
openssl-101f,O1,x86,cswift_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O1_extraction/cswift_rand_bytes@081a0320.c,"The function `cswift_rand_bytes` uses CryptoSwift hardware accelerator to generate random bytes. It takes a buffer pointer and the number of bytes to generate as parameters. It acquires a context for the CryptoSwift accelerator using `CSwift_AcquireAccContext` and generates random bytes in blocks of 1024 bytes or less using `CSwift_SimpleRequest`. If there is an error, it sets an error code and returns 0. Otherwise, it returns 1 and releases the context using `CSwift_ReleaseAccContext`."
openssl-101f,O1,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_x86_gcc_O1_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9cf0.c,"The function d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS decodes data using the ASN1_item_d2i function and a specified ASN1_ITEM structure (GOST_CLIENT_KEY_EXCHANGE_PARAMS_it) to describe the data format. It takes a pointer to an ASN1_VALUE (which will be populated with the decoded data), a double pointer to a uchar (which contains the encoded data), and a long integer (which specifies the length of the encoded data) as arguments. The function returns the decoded data."
openssl-101f,O1,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_x86_gcc_O1_extraction/d2i_GOST_KEY_PARAMS@081d9bf0.c,"defines a function named ""d2i_GOST_KEY_PARAMS"" that deserializes an ASN.1-encoded data structure into a C data structure. The function takes three arguments: a pointer to a pointer to an ASN1_VALUE, a pointer to a pointer to a uchar, and a long integer. The function returns nothing. The ""ASN1_item_d2i"" function is called within the function with arguments ""param_1"", ""param_2"", ""param_3"", and ""GOST_KEY_PARAMS_it"". ""ASN1_item_d2i"" is a utility function provided by the OpenSSL library."
openssl-101f,O1,x86,decode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O1_extraction/decode_gost_algor_params@081d78c0.c,"The function decodes the algorithm parameters for a GOST key and sets them in an EVP_PKEY structure. It extracts the algorithm parameters from the X509_ALGOR structure and determines the type of GOST key (GOST2001 or GOST94) based on the OID of the parameters. It then creates either an EC_KEY or DSA structure and fills it with the appropriate parameters using fill_GOST2001_params() or fill_GOST94_params(). If any errors occur, the function returns false, otherwise it returns true."
openssl-101f,O1,x86,DES_xcbc_encrypt,./data/decomp/openssl-101f_x86_gcc_O1_extraction/DES_xcbc_encrypt@081ddf90.c,"The function `DES_xcbc_encrypt` and the function that takes in a plaintext message and encrypts it using the Data Encryption Standard (DES) algorithm are similar in that they both use the DES algorithm to encrypt data in blocks of 8 bytes at a time. They both also take in an initialization vector (IV) and handle padding for messages that are not a multiple of 8 bytes long. However, `DES_xcbc_encrypt` additionally takes in an input buffer `input` of length `length` and encrypts it using the provided key schedule `schedule`. It also derives two intermediate values `inw` and `outw` from the IV and processes the input buffer in blocks of 8 bytes by XORing the block with the intermediate values and encrypting the result using the key schedule. The resulting ciphertext is then XORed with the intermediate value `outw` to produce the output block. If the input length is not a multiple of 8, the function processes the last block separately."
openssl-101f,O1,x86,dgram_ctrl,./data/decomp/openssl-101f_x86_gcc_O1_extraction/dgram_ctrl@08120f10.c,"Two functions are described:

1. `dgram_ctrl` takes in four parameters: an integer `param_1`, an undefined 4-byte value `param_2`, a size_t value `param_3`, and a pointer to an undefined 4-byte value `param_4`. The function initializes some local variables, including a pointer `__src` to a location in memory specified by the value at offset `0x20` from `param_1`. The function then enters a switch statement based on the value of `param_2`. Depending on the case, the function performs various operations, including setting or getting socket options using `setsockopt` or `getsockopt`, setting or getting values stored in `__src`, and copying data from `__src` to `param_4`. If `param_2` does not match any of the cases, the function sets `param_3` to 0 and exits. Finally, the function returns the value of `param_3`.

2. The second function takes four parameters: a pointer to a structure, a size_t value, a pointer to an array of undefined 4-byte values, and a size_t value. It returns a size_t value. The function first declares a local variable and initializes it to the value of the fourth parameter. Next, it enters a switch statement based on the value of the first parameter in the structure. There are several cases in the switch statement, each with different behavior. In the first case, the function checks if the value of the second parameter is greater than or equal to 3. If it is, the function sets the value of the fourth parameter to 0x224. If it is not, the function checks several conditions involving the values in the array pointed to by the third parameter. If these conditions are met, the function sets the value of the fourth parameter to 0x224. In the second case, the function checks if two values in the structure are not equal to 0."
openssl-101f,O1,x86,dlfcn_bind_func,./data/decomp/openssl-101f_x86_gcc_O1_extraction/dlfcn_bind_func@081e4350.c,"The function dlfcn_bind_func takes in two integer parameters, param_1 and param_2. It first checks if either parameter is equal to zero and if so, sets the variable line to 0x110 and the variable iVar1 to 0x43. If both parameters are not equal to zero, it retrieves the number of elements in the stack pointed to by the value at the memory location (param_1 + 4) and stores it in the variable iVar1. If iVar1 is less than 1, it sets the variable line to 0x115 and the variable iVar1 to 0x69. If iVar1 is greater than or equal to 1, it retrieves the value at the top of the stack and stores it in the variable pvVar2. If pvVar2 is not equal to NULL, it calls the dlsym function with the parameters pvVar2 and param_2. If the return value of dlsym is zero, it."
openssl-101f,O1,x86,dlfcn_bind_var,./data/decomp/openssl-101f_x86_gcc_O1_extraction/dlfcn_bind_var@081e4450.c,"The ""dlfcn_bind_var"" function takes two integer parameters. If either parameter is equal to zero, it sets an error code and returns 0. It retrieves the number of items in a stack pointed to by the first parameter and, if the number is less than 1, sets an error code and returns 0. If the stack has at least one item, it retrieves the last item from the stack and calls dlsym with that item and the second parameter. If dlsym returns 0, it sets an error code and returns 0. Otherwise, it returns the result of dlsym. If the last item in the stack is null, it sets an error code and returns 0."
openssl-101f,O1,x86,dlfcn_globallookup,./data/decomp/openssl-101f_x86_gcc_O1_extraction/dlfcn_globallookup@081e4070.c,"This function uses the dlfcn library to dynamically load a shared object file and look up a symbol within it. It takes a single argument, which is the name of the symbol to be looked up. The function first calls dlopen with a null pointer and the flag 1 (RTLD_LAZY) to open the current executable file and return a handle to the dynamic linker object. If the call to dlopen fails, it returns 0 and the function returns 0 as well. Next, it calls dlsym with the handle returned by dlopen and the symbol name passed as an argument to the function. This function returns a pointer to the symbol if it is found, or a null pointer if it is not. Finally, the function calls dlclose to close the dynamic linker handle returned by dlopen, freeing the resources used by the dynamically loaded shared object file. The function returns the pointer to the symbol if it was found, or a null pointer if it was not."
openssl-101f,O1,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_mont_field_encode@081e2870.c,"The function takes in four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The integer parameter is used to access a BN_MONT_CTX pointer stored in a struct. If the BN_MONT_CTX pointer is not null, the function uses the BN_mod_mul_montgomery function to multiply the second and third parameters using the Montgomery reduction algorithm and store the result in the first parameter. The BN_mod_mul_montgomery function takes in the second and third parameters as inputs, along with the BN_MONT_CTX pointer and the BN_CTX pointer. If the BN_MONT_CTX pointer is null, the function uses the ERR_put_error function to report an error with the error code 0x10 and the reason ""ecp_mont.c"" at line 0x124. The function then returns 0."
openssl-101f,O1,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_mont_field_sqr@081e2810.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The integer parameter is used to access a BN_MONT_CTX pointer stored in memory. If the BN_MONT_CTX pointer is not null, the function computes the square of the second BIGNUM parameter using Montgomery multiplication with the third BIGNUM parameter and the BN_MONT_CTX pointer. The result is stored in the first BIGNUM parameter, and the function returns 1. If the BN_MONT_CTX pointer is null, the function reports an error using the ERR_put_error function and returns 0."
openssl-101f,O1,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_mont_group_init@081e2420.c,The `ec_GFp_mont_group_init` function initializes a Montgomery elliptic curve group in OpenSSL by calling `ec_GFp_simple_group_init` to initialize the simple elliptic curve group. It sets two variables to zero for storing Montgomery-specific parameters and returns.
openssl-101f,O1,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_nist_field_mul@081e2ba0.c,"The function performs a multiplication operation for elliptic curve cryptography over a finite field of prime order. It takes four parameters: an integer value, two BIGNUM pointers, and a BN_CTX pointer. The function checks for parameter validity and creates a new BN_CTX pointer if one is not provided. It then multiplies the two BIGNUM values, stores the result in the first BIGNUM, reduces the result modulo the prime order of the elliptic curve using a function pointer, and returns a boolean value indicating the success or failure of the operation."
openssl-101f,O1,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_nist_group_copy@081e29a0.c,The function `ec_GFp_nist_group_copy` copies one elliptic curve group to another by first copying a 4-byte integer at offset 0xa8 from `param_2` to the same offset in `param_1`. It then calls `ec_GFp_simple_group_copy` to copy the remaining fields of the elliptic curve group structure from `param_2` to `param_1`. The function then returns.
openssl-101f,O1,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_nist_group_set_curve@081e29c0.c,"The function takes in an integer, a BIGNUM pointer, and three undefined 4-byte values, and returns an undefined 4-byte value. It checks if the fifth parameter (a BN_CTX pointer) is null and creates a new BN_CTX object if it is. It then compares the second parameter (a BIGNUM pointer) to various NIST primes using BN_ucmp. If the BIGNUM matches one of the primes, the function sets a function pointer in the integer parameter based on the matching prime and calls ec_GFp_simple_group_set_curve with the remaining parameters. If there is no match, the function returns 0 and puts an error message in the error queue using ERR_put_error. Finally, the function ends the BN_CTX object and frees it if it was created within the function."
openssl-101f,O1,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e74d0.c,"The function is a C implementation of getting J-projective coordinates of a point on an elliptic curve over a prime field (GFp). It takes in six parameters: an integer pointer (param_1), an integer (param_2), and four BIGNUM pointers (param_3, param_4, param_5, and param_6). The function first checks if a certain field in the param_1 struct is equal to zero. If it is, it checks if the param_3, param_4, and param_5 BIGNUM pointers are null or not, and if they are not null, it copies the corresponding values from the param_2 integer into the respective BIGNUM pointers. If the param_5 BIGNUM pointer is null, it returns true. If the field in the param_1 struct is not equal to zero, the function creates a BN_CTX object if the param_6 BIGNUM pointer is not null or if a."
openssl-101f,O1,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_group_check_discriminant@081e76a0.c,"The function `ec_GFp_simple_group_check_discriminant` checks the discriminant of an elliptic curve over a finite field. It takes two arguments - an integer pointer `param_1` and a `BN_CTX` pointer `param_2`. The function initializes a `BN_CTX` object if it is not provided as an argument and allocates memory for five `BIGNUM` objects using the `BN_CTX_get` function. If the elliptic curve parameters do not have a custom `field_type` method, the function copies the values of `param_1 + 0x1d` and `param_1 + 0x22` (which represent the `a` and `a_0` coefficients of the curve) to the `BIGNUM` objects `a` and `a_00`, respectively. Otherwise, it calls the custom `field_type` method to obtain these values."
openssl-101f,O1,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_group_clear_finish@081e7130.c,"The function takes an integer parameter (param_1) which is likely a pointer to a structure containing some data related to an elliptic curve group. The function then clears and frees three BIGNUM variables that are stored at specific offsets from the beginning of the structure. These BIGNUM variables likely contain sensitive data related to the group, such as the group order, curve parameters, or generator point coordinates. By clearing and freeing these variables, the function ensures that any sensitive data is securely erased from memory to prevent it from being accessed by unauthorized parties. Finally, the function returns without any further action."
openssl-101f,O1,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_group_copy@081e8280.c,"The function ec_GFp_simple_group_copy takes two parameters, param_1 and param_2, and returns an integer value of 0 or 1. It performs four copy operations: three BIGNUM values at offsets 0x48, 0x74, and 0x88, and an undefined 4-byte value at offset 0x9c. BN_copy is used to perform the copy operation. If all the copy operations are successful, the function returns 1. Otherwise, it returns 0."
openssl-101f,O1,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_group_get_degree@081e71a0.c,The function takes an integer parameter representing an elliptic curve group and retrieves the group's order from a structure. It calculates the bit length of the order using the BN_num_bits() function and returns the degree of the elliptic curve group without modifying any data.
openssl-101f,O1,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_group_set_curve@081e8370.c,"The function `ec_GFp_simple_group_set_curve` sets the parameters of an elliptic curve group over a finite field of prime order. The input parameters are the prime order `param_2`, the coefficients `param_3` and `param_4` of the elliptic curve, and a `BN_CTX` object `param_5` used for temporary storage. The function first checks if the prime order is valid (at least 3 bits, top bit set to 1, and odd). If the `BN_CTX` object is not provided, it creates a new one and allocates memory for two `BIGNUM` objects `r` and `param_1+0x12`. If memory allocation fails, the function returns 0. The function then sets the sign of `param_1+0x12` to positive and computes `r` as the modulus of `param_3` with `param_2`. If `r` is zero or..."
openssl-101f,O1,x86,ec_GFp_simple_invert,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_invert@081e90a0.c,"The function checks if an EC_POINT object is at infinity or if its y-coordinate is zero. If neither condition is met, it calculates the inverse of the point using a BN_usub function call. The function returns the result of the inverse calculation or 1 if it fails."
openssl-101f,O1,x86,EC_GFp_simple_method,./data/decomp/openssl-101f_x86_gcc_O1_extraction/EC_GFp_simple_method@081e9c60.c,"The function returns a pointer to an EC_METHOD structure, but it is unclear what specific implementation it uses. It may be a method for elliptic curve operations over a finite field, but more context is needed. The warning message indicates that the function may use an unfamiliar calling convention, which could cause problems if called from other code."
openssl-101f,O1,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_point_copy@081e8300.c,"The ""ec_GFp_simple_point_copy"" function takes two integer parameters and returns an integer value of either 0 or 1. It copies three BIGNUM values from the second parameter to the first parameter using BN_copy() function. The function returns 1 if all three BN_copy() functions return a non-null value and sets the fourth parameter of the first parameter to the fourth parameter of the second parameter. Otherwise, it returns 0."
openssl-101f,O1,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_point_finish@081e7100.c,"The function takes an integer parameter (presumably a pointer to a structure representing a point in an elliptic curve group), frees the memory allocated for three BIGNUM objects stored within the structure (representing the x-coordinate, y-coordinate, and z-coordinate of the point), and returns."
openssl-101f,O1,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7910.c,"The function obtains the affine coordinates of a given EC_POINT on an elliptic curve using the curve parameters, the point to be converted, and a BN_CTX object for temporary storage. It checks if the point is at infinity and returns an error if it is. It creates a new BN_CTX object if one is not provided and initializes some local BIGNUM variables. If the curve's field inversion function is defined, it uses it. If not, it checks if the x-coordinate of the point is equal to 1. If it is not, it calculates the inverse of the x-coordinate modulo the curve's order and uses it to calculate the y-coordinate using the curve's equation. If the y-coordinate is successfully calculated, it is returned as the affine y-coordinate of the point. If a non-null parameter is provided for the affine x-coordinate, it is also calculated and returned."
openssl-101f,O1,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O1_extraction/ec_GFp_simple_point_set_affine_coordinates@081e85e0.c,"The function takes in an EC_GROUP object, an EC_POINT object, two BIGNUM objects (param_3 and param_4) representing the x and y affine coordinates of the point, and a BN_CTX object. If both param_3 and param_4 are not null pointers, the function creates a new BIGNUM object z with value 1 and calls EC_POINT_set_Jprojective_coordinates_GFp with the given parameters to set the point's coordinates in Jacobian projective form. If either param_3 or param_4 is a null pointer, the function reports an error using ERR_put_error and returns 0. The function returns an integer value indicating success (1) or failure (0)."
openssl-101f,O1,x86,encode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O1_extraction/encode_gost_algor_params@081d8ab0.c,"The function takes an EVP_PKEY pointer as input and returns an ASN1_STRING pointer as output. It encodes the parameters of a GOST algorithm, which can be either a GOST R 34.10-2001 elliptic curve key or a GOST R 34.10-2012 elliptic curve key. First, it creates a new ASN1_STRING object and a new GOST_KEY_PARAMS object. If either of these objects cannot be created, the function returns an error. Next, it determines the type of GOST algorithm being used by checking the EVP_PKEY's base ID. If it is a GOST R 34.10-2001 key, it extracts the elliptic curve group and gets its curve name. If it is a GOST R 34.10-2012 key, it extracts the parameters and compares them to the predefined parameter sets. If a match is found, it gets the parameter set's name. It then creates ASN1."
openssl-101f,O1,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_x86_gcc_O1_extraction/general_allocate_boolean.constprop.5@081896c0.c,"The function takes in parameters including two strings, an integer, and several other integers. It first checks if the first string is null, and if so, returns an error code. If not null, it checks if the second string is also not null. If the second string is null, the function returns an error code. If both strings are not null, the function iterates through each character in the first string and checks if it is present in the second string. If a character in the first string is not present in the second string, the function returns an error code. If all characters in the first string are present in the second string, the function checks if a specific integer parameter is nonzero. If the integer parameter is zero, the function returns an error code. If the integer parameter is nonzero, the function continues."
openssl-101f,O1,x86,get_gost_engine_param,./data/decomp/openssl-101f_x86_gcc_O1_extraction/get_gost_engine_param@081db3b0.c,"The function takes an integer parameter called param_1 and returns a pointer to a character string. If the value of param_1 is not equal to zero, the function returns a null pointer. If the global variable gost_params is null, the function tries to get the value of the environment variable CRYPT_PARAMS using the getenv function. If the value of CRYPT_PARAMS is null, the function returns a null pointer. Otherwise, the function allocates memory for gost_params using the BUF_strdup function and returns its value. If the value of gost_params is not null, the function simply returns its value. Overall, the function is used to retrieve the value of the CRYPT_PARAMS environment variable and store it in a global variable for later use."
openssl-101f,O1,x86,gost2001_param_encode,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost2001_param_encode@081d7de0.c,"The function extracts the curve name of an EC_GROUP object from an EVP_PKEY input, assumed to contain an EC_KEY object. It converts the curve name into an ASN1_OBJECT object and encodes it into a byte array using i2d_ASN1_OBJECT function, returning the encoded byte array."
openssl-101f,O1,x86,gost_cipher_cleanup,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost_cipher_cleanup@081d9f50.c,"The function takes an integer parameter `param_1`, calls the `gost_destroy` function with an argument that is the result of adding the value at memory location `param_1 + 0x60` with 12, sets the value at memory location `param_1 + 0x54` to zero, and returns the value 1. The `gost_destroy` function likely deallocates memory or resources associated with the GOST cipher algorithm."
openssl-101f,O1,x86,gost_cipher_ctl,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost_cipher_ctl@081da4a0.c,"The function `gost_cipher_ctl` takes in four parameters (`param_1`, `param_2`, `param_3`, and `param_4`). 

If `param_2` is equal to 6, the function generates random bytes using the `RAND_bytes` function and stores them in the memory location pointed to by `param_4`. If successful, it returns 1. Otherwise, it calls the `ERR_GOST_error` function with error codes and returns -1.

If `param_2` is equal to 7, the function checks if `param_4` is not equal to NULL. If it is not NULL, the function stores the value 0x32a in the memory location pointed to by `param_4` and returns 1. Otherwise, it returns 0.

If `param_2` is not equal to 6 or 7, the function calls the `ERR` function."
openssl-101f,O1,x86,gost_cipher_do_cnt,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost_cipher_do_cnt@081da0c0.c,"The function `gost_cipher_do_cnt` takes four parameters: an integer `param_1`, a pointer `param_2`, a pointer `param_3`, and an integer `param_4`. It checks if the cipher state has been initialized and sets a local variable `local_20` to 8 if not. If the cipher state has already been initialized, it sets `uVar4` to 0."
openssl-101f,O1,x86,gost_cipher_init,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost_cipher_init@081db0d0.c,"The `gost_cipher_init` function initializes the GOST cipher context `param_1` with cipher data, key, and initialization vector (IV) provided as input parameters `param_2` and `param_3`. It first checks if the context has already been initialized by checking if the `app_data` field is `NULL`. If it is `NULL`, the function retrieves the GOST engine parameter and uses it to find the corresponding cipher data from the `gost_cipher_list`. If the engine parameter is not set, the function uses the default cipher data from the `gost_cipher_list`. The function then initializes the cipher data in the context by setting the `cipher_data` field to the cipher data from the `gost_cipher_list`, setting the key size to `param_2`, and..."
openssl-101f,O1,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O1_extraction/GOST_CIPHER_PARAMS_new@081d9cb0.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function. It uses the GOST_CIPHER_PARAMS_it pointer to define the structure and does not take any input parameters or return anything.
openssl-101f,O1,x86,gost_imit_final,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost_imit_final@081dad70.c,"1. Retrieve the value of a variable from a specified memory address.
2. Check if another variable is equal to zero. If it is, call an error function and exit the function. If the second variable is not equal to zero, perform a series of operations including updating the message authentication code (MAC) and key meshing.
3. Generate a MAC and return it as output. If an error occurred earlier, return a value indicating failure."
openssl-101f,O1,x86,gost_imit_init_cpa,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost_imit_init_cpa@081da430.c,"The function `gost_imit_init_cpa` initializes the GOST 28147-89 cipher for use in the CPA mode. It retrieves an integer value from a memory location, sets various memory locations to zero, sets one memory location to 1, and then calls `gost_init` with the appropriate arguments. The function returns upon completion."
openssl-101f,O1,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O1_extraction/GOST_KEY_PARAMS_new@081d9c30.c,The function creates a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new() function and does not return any value.
openssl-101f,O1,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_x86_gcc_O1_extraction/GOST_KEY_TRANSPORT_free@081d9ad0.c,The function frees the memory of a GOST_KEY_TRANSPORT object passed as a parameter using the ASN1_item_free function and returns without any value.
openssl-101f,O1,x86,gost_param_free,./data/decomp/openssl-101f_x86_gcc_O1_extraction/gost_param_free@081db310.c,"The ""gost_param_free"" function frees memory allocated to the ""gost_params"" variable by checking if it is not equal to NULL, using the ""CRYPTO_free"" function, setting ""gost_params"" to NULL, and returning without any value."
openssl-101f,O1,x86,hash_step,./data/decomp/openssl-101f_x86_gcc_O1_extraction/hash_step@081db480.c,"The first function takes in three parameters, performs some bitwise operations on the values pointed to by the two pointers, calls another function called ""gost_enc_with_key"" with the integer parameter and some of the local variables as arguments, performs a series of bitwise operations and assignments on the remaining local variables, and updates some of the values pointed to by the second pointer with the results of these operations. Its overall purpose is unclear without more context.

The second function initializes some local variables, performs some bitwise operations on the local variables, calls the ""gost_enc_with_key"" function to encrypt some data using a key, performs some more bitwise operations on the encrypted data and the input parameters, and returns the encrypted data as output. Its overall purpose appears to be performing some kind of encryption or hashing operation on the input data using a key.

The third function takes two parameters, initializes some local variables, enters a loop that iterates over a range of values, performs some arithmetic operations on the current iteration value and stores the results in local variables, checks if the value of a variable called local_20 is equal to a variable called iVar10, and stores the values of the local variables in the param_2 array and returns 1 if they are equal, otherwise it calls __stack_chk_fail() and terminates. 

Overall, the functions perform different operations and have different purposes, so they cannot be consolidated."
openssl-101f,O1,x86,hwcrhk_init,./data/decomp/openssl-101f_x86_gcc_O1_extraction/hwcrhk_init@081a2c00.c,"The function declares variables and function pointers, checks if a library is null and loads it if necessary, sets global function pointers, sets mutex operation function pointers if not disabled, sets RSA key handle index if not already set, handles errors in loading the library and binding functions, and frees the library and resets function pointers before returning 0."
openssl-101f,O1,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_x86_gcc_O1_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9b90.c,"The function takes a pointer to an ASN1_VALUE structure and a double pointer to a uchar variable. It calls the ASN1_item_i2d function with the parameters param_1, param_2, and GOST_KEY_AGREEMENT_INFO_it. This function converts the ASN1_VALUE structure to a DER-encoded uchar string and stores it in the uchar variable pointed to by param_2. The function returns without any value."
openssl-101f,O1,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_x86_gcc_O1_extraction/i2d_GOST_KEY_TRANSPORT@081d9a90.c,"The function takes in two parameters: param_1, a pointer to an ASN1_VALUE structure, and param_2, a pointer to a pointer to an unsigned character (uchar). It encodes the ASN1_VALUE structure into a byte stream using the ASN1_item_i2d function and stores it in the memory pointed to by param_2. The function returns without any value."
openssl-101f,O1,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101f_x86_gcc_O1_extraction/load_pkcs12.constprop.4@08079a50.c,"The function `load_pkcs12_constprop_4` takes in several parameters including two `BIO` pointers, a string, a function pointer, and two double pointers to `EVP_PKEY` and `X509` structs. It reads in a PKCS12 file using the `d2i_PKCS12_bio` function and checks if the file was successfully loaded. If not, it prints an error message and returns 0. Next, it verifies the MAC of the PKCS12 file using `PKCS12_verify_mac` function. If the verification fails, it checks if a password callback function was provided. If not, it sets the password callback function to `password_callback`. It then prompts the user for a password using the password callback function and verifies the MAC again using the password provided. If the verification fails again, it prints an error message and returns 0. If the MAC verification is successful, the function parses the PKCS12 file using."
openssl-101f,O1,x86,padlock_init,./data/decomp/openssl-101f_x86_gcc_O1_extraction/padlock_init@081a9ad0.c,"The ""padlock_init"" function checks if ""padlock_use_rng"" and ""padlock_use_ace"" are not equal to zero. If either of them is not zero, the function returns true (1), indicating successful initialization, otherwise, it returns false (0), indicating initialization failure."
openssl-101f,O1,x86,padlock_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O1_extraction/padlock_rand_bytes@081a8be0.c,"The function padlock_rand_bytes takes two parameters: a pointer to a buffer and an integer value representing the number of bytes to generate. If the integer value is less than 8, the function generates random bytes one at a time using the xstore_available function and stores them in the buffer. If the integer value is greater than or equal to 8, the function attempts to generate the bytes in larger chunks of 8 bytes at a time using the xstore_available function. If successful, the function returns 1, otherwise it returns 0 to indicate failure. The function also checks for stack smashing by comparing a local variable to the value stored in the gs register offset by 0x14."
openssl-101f,O1,x86,param_copy_gost94,./data/decomp/openssl-101f_x86_gcc_O1_extraction/param_copy_gost94@081d8120.c,"The function takes two EVP_PKEY pointers as input, param_1 and param_2. It extracts the DSA key from param_1 and the contents of param_2 using EVP_PKEY_get0(). It checks if the base identifiers of param_1 and param_2 match. If they do, it checks if the contents of param_2 are not NULL. If they are NULL, it calls ERR_GOST_error() to report an error. If they are not NULL, it assigns a new DSA key to param_1 if it is currently NULL. It then copies the three BIGNUMs from param_2 to the corresponding fields of the DSA key in param_1 using BN_dup(). If the private key component of the DSA key is not zero, it computes the public key using gost94_compute_public(). Finally, it returns 1 if the operation was successful, or NULL if there was an error."
openssl-101f,O1,x86,param_print_gost01,./data/decomp/openssl-101f_x86_gcc_O1_extraction/param_print_gost01@081d8540.c,"The function takes a BIO object, EVP_PKEY object, and integer value as parameters. It extracts an EC_KEY object from the EVP_PKEY object, gets the associated EC_GROUP object, and prints the parameter set to the BIO object with an indentation level specified by the integer parameter. The function returns 1 if the printing is successful, and 0 otherwise."
openssl-101f,O1,x86,param_print_gost94,./data/decomp/openssl-101f_x86_gcc_O1_extraction/param_print_gost94@081d85b0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer parameter. It extracts the public key from the EVP_PKEY object and creates a new BIGNUM object called local_24. It then checks if the R3410_paramset._12_4_ is not null. If it is not null, it loops through the R3410_paramset array and compares the BIGNUM object local_24 with each element of the array. If it finds a match, it sets the integer variable iVar2 to the corresponding value in the array and frees the local_24 object. If it does not find a match, it sets iVar2 to 0 and frees the local_24 object. The function then indents the BIO object by the integer parameter and prints the parameter set name corresponding to the integer value of iVar2 using OBJ_nid2ln(). Finally, it checks if the stack has been corrupted before returning 1."
openssl-101f,O1,x86,pkey_ctrl_gost,./data/decomp/openssl-101f_x86_gcc_O1_extraction/pkey_ctrl_gost@081d8ea0.c,"The function `pkey_ctrl_gost` takes in four parameters: `param_1` (an EVP_PKEY pointer), `param_2` (an integer), `param_3` (an integer), and `param_4` (a PKCS7_SIGNER_INFO pointer). The function initializes a local variable `local_20` to the value stored in the `GS_OFFSET + 0x14` memory location. Depending on the value of `param_2`, the function takes different actions. If `param_2` is not one of the predefined cases (1, 2, 3, 5, or 7), the function sets `uVar2` to `0xfffffffe` and jumps to `LAB_081d8ee8`. If `param_2` is 1 and `param_3` is 0, the function sets `uVar2` to 1 and initializes two."
openssl-101f,O1,x86,pkey_free_gost94,./data/decomp/openssl-101f_x86_gcc_O1_extraction/pkey_free_gost94@081d8520.c,"The function pkey_free_gost94 takes an integer parameter and checks if the value stored at an offset of 0x14 from this parameter is not equal to 0. If it is not equal to 0, the function calls the DSA_free function to free the memory allocated to the DSA structure. If it is equal to 0, the function simply returns without doing anything. This function is likely a part of a larger program that deals with public key cryptography."
openssl-101f,O1,x86,priv_encode_gost,./data/decomp/openssl-101f_x86_gcc_O1_extraction/priv_encode_gost@081d91d0.c,"The function encodes private key information in an EVP_PKEY structure using the GOST algorithm and sets the encoded information in a PKCS8_PRIV_KEY_INFO structure. It first gets the OID of the GOST algorithm and encodes the algorithm parameters using the encode_gost_algor_params() function. It then checks the type of the private key and gets the private key value using either EC_KEY_get0_private_key() or from the EVP_PKEY structure. Finally, it converts the private key value to an ASN1_INTEGER using BN_to_ASN1_INTEGER()."
openssl-101f,O1,x86,pub_encode_gost94,./data/decomp/openssl-101f_x86_gcc_O1_extraction/pub_encode_gost94@081d9080.c,"The function encodes a GOST 94 public key into an X509_PUBKEY structure by retrieving the key and its identifier, encoding them into an ASN.1 octet string, and setting them into the X509_PUBKEY structure. It returns 0 if successful or an error code otherwise."
openssl-101f,O1,x86,pub_print_gost94,./data/decomp/openssl-101f_x86_gcc_O1_extraction/pub_print_gost94@081d86a0.c,"This function retrieves the public key from the EVP_PKEY parameter and stores it in a BIGNUM variable called 'a', then prints the public key using the BN_print() function. It also retrieves the parameter set from the EVP_PKEY parameter and compares it with the predefined R3410 parameter set, printing the parameter set using the OBJ_nid2ln() function. The function returns 1 if successful."
openssl-101f,O1,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O1_extraction/RSA_padding_add_PKCS1_PSS@081e36a0.c,"One function, RSA_padding_add_PKCS1_PSS, adds padding to a message using the PKCS#1 PSS algorithm for RSA encryption. It takes a RSA key, a message hash, a hash function, and a salt length as input. The function checks if the hash size is valid and if the salt length is either -1, -2, or greater than 0. If the salt length is -2, the function calculates the maximum salt length based on the RSA key size and the hash size. If the salt length is invalid, an error is returned. The function allocates memory for a buffer to hold the salt and generates random bytes to fill the buffer. Then, the function initializes an EVP_MD_CTX structure with the hash function and updates it with the message hash and a string of zeroes. If the salt length is 0, the function finalizes the hash and uses the result as the salt. If the salt length is greater.

The other function, add_numbers, takes two parameters, ""a"" and ""b"". Within the function, it creates a variable ""result"" that is the sum of ""a"" and ""b"". It then returns the value of ""result""."
openssl-101f,O1,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O1_extraction/RSA_verify_PKCS1_PSS@081e2d80.c,"The function RSA_verify_PKCS1_PSS verifies a signature using the RSA-PSS algorithm. It takes in the RSA key, message hash, hash function used, encoded message, and length of encoded message. It initializes an EVP_MD_CTX structure, checks for valid encoded message length, calculates RSA key size, and removes incorrect padding. It generates a mask using PKCS1_MGF1 and XORs it with the encoded message. It checks for correct padding and returns an error if incorrect. If padding is correct, it computes hash of message and compares it to hash in encoded message."
openssl-101f,O1,x86,sha_block_data_order,./data/decomp/openssl-101f_x86_gcc_O1_extraction/sha_block_data_order@081dcb10.c,"The functions all implement the SHA-1 hashing algorithm to produce a fixed-size 160-bit hash value as output. They initialize variables with constant values, process the input data in 512-bit (64-byte) chunks, and perform a series of bitwise operations on the variables using the input words and various constants. They involve rotating the variables, performing logical AND, OR, and XOR operations, and adding constants. The final values of the variables are concatenated to form the hash value. One of the functions also checks if a pointer to a struct object is not null and if the value of a specific member variable in that struct object is not equal to 0 before continuing with its execution."
openssl-101f,O1,x86,SHA_Final,./data/decomp/openssl-101f_x86_gcc_O1_extraction/SHA_Final@081ddde0.c,"The function takes in a message digest buffer and a SHA context structure as input. It appends a single bit to the message block and pads the block with zeros until it is 64 bytes long. It then processes the message block using the sha_block_data_order() function. Next, it sets the first two words of the padded block to the high and low order bits of the total number of bits in the message. It processes the final message block using sha_block_data_order() again. It resets the SHA context structure and copies the five 32-bit hash values from the context structure into the message digest buffer. Finally, it returns a value of 1 to indicate success."
openssl-101f,O1,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_x86_gcc_O1_extraction/SSL_SESSION_free.part.2@080c59a0.c,This function frees memory allocated for an SSL session. It cleanses specific memory locations and memory allocated for certificates and stacks. It also frees additional memory and the entire memory block.
openssl-101f,O1,x86,start_hash,./data/decomp/openssl-101f_x86_gcc_O1_extraction/start_hash@081dc420.c,"The function takes a pointer to an array of 16 bytes as input. If the third element of the array is not equal to zero, the function initializes various elements of the array to zero. Specifically, it sets the fourth and eleventh elements of the array to zero, and initializes a block of memory starting at the fifth element of the array and extending to the end of the array to zero. It also sets the twelfth and nineteenth elements of the array to zero, and initializes a block of memory starting at the thirteenth element of the array and extending to the end of the array to zero. Finally, it sets the first, second, and fourth elements of the array to zero and returns 1. If the third element of the array is zero, the function returns 0."
openssl-101f,O1,x86,surewarehk_finish,./data/decomp/openssl-101f_x86_gcc_O1_extraction/surewarehk_finish@081a4ef0.c,"The function checks if the surewarehk_dso variable is null. If it is null, it sets the SUREWARE_lib_error_code to the next error code in the library and returns an error. If it is not null, it calls the p_surewarehk_Finish function, frees the surewarehk_dso variable, and sets the SUREWARE_lib_error_code to the next error code in the library. If the DSO_free function call fails, it sets the SUREWARE_lib_error_code to the next error code in the library and returns an error. Finally, it frees the logstream variable and sets all the function pointers to null. The function returns either 0 or 1 depending on whether the function executed successfully or not."
openssl-101f,O1,x86,sv_body,./data/decomp/openssl-101f_x86_gcc_O1_extraction/sv_body@08067fe0.c,"The function `sv_body` is part of a TLS server implementation and handles the SSL connection with the client. It first allocates a buffer of size 0x4000 using `CRYPTO_malloc`. It then checks if non-blocking I/O is enabled and sets a timeout value of 1 second using `BIO_socket_ioctl` if it is. It creates a new SSL object using the global `ctx` variable and sets various options and callbacks depending on the values of global variables such as `s_tlsextdebug` and `s_msg`. If a session ID context is provided, it sets it using `SSL_set_session_id_context`. It then sets up the SSL I/O using `BIO_new_socket` or `BIO_new_dgram` depending on the SSL version being used. If `s_nbio_test` is set, it wraps the I/O with a non-blocking I/O test BIO using `BIO_f_nbio_test`. 

The function `sv_body` is the main function that handles the SSL connection with the client. It first initializes the SSL connection using `init_ssl_connection` function. It then enters a loop where it waits for input from the client using `SSL_read` function and sends output to the client using `SSL_write` function. The loop continues until the client closes the connection or an error occurs. Within the loop, the function checks for specific commands sent by the client, such as ""QUIT"", ""RENEG"", ""PRINT"", and ""STATS"", and performs the corresponding actions. For example, if the client sends ""QUIT"", the function closes the connection and exits the loop. The function also handles any errors that occur during the SSL connection, such as when SSL_write returns a blocking error, by retrying the write operation until it succeeds. Finally, the function cleans up the SSL connection and memory allocations before exiting."
openssl-101f,O1,x86,__libc_csu_init,./data/decomp/openssl-101f_x86_gcc_O1_extraction/__libc_csu_init@081e9f00.c,"The function initializes the C runtime environment by calling the _init() function for necessary initialization of the C runtime library. It then iterates through an array of function pointers to static constructors for global objects, calling each with specified parameters to initialize global objects before program execution. Finally, the function returns after all constructors have been called."
openssl-101f,O1,x86,__udivdi3,./data/decomp/openssl-101f_x86_gcc_O1_extraction/__udivdi3@081e9c70.c,"The function takes in four unsigned integers as parameters: param_1, param_2, param_3, and param_4. It returns an unsigned 64-bit integer. If param_4 is equal to 0, the function checks if param_2 is less than param_3. If it is, it returns the result of param_1 concatenated with param_2 divided by param_3. If param_3 is equal to 0, it sets param_3 to the maximum value of an unsigned integer. It then calculates the quotient and remainder of param_2 concatenated with param_1 divided by param_3 and returns the quotient. If param_4 is not equal to 0, the function checks if param_2 is less than param_4. If it is, it returns 0. It then calculates the number of bits needed to represent param_4 and stores it in uVar6. If uVar6 is not equal to 0, it..."
openssl-101f,O2,x86,aep_mod_exp.part.0,./data/decomp/openssl-101f_x86_gcc_O2_extraction/aep_mod_exp.part.0@0819e300.c,"The `aep_mod_exp_part_0` function uses the AEP library for modular exponentiation. It takes in five parameters and calls `aep_get_connection` to connect to the AEP device. If the connection is successful, it calls `p_AEP_ModExp` with the given parameters. If the function returns 0, it sets a flag in `aep_app_conn_table`. If it returns a non-zero value, it closes the connection and sets an error."
openssl-101f,O2,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_x86_gcc_O2_extraction/asn1_bio_callback_ctrl@081e4db0.c,"The function takes three parameters: param_1, param_2, and param_3. If the value stored at the memory address pointed to by (param_1 + 0x24) is not equal to NULL, it calls the BIO_callback_ctrl function with the parameters param_2 and param_3, passing the value stored at the memory address pointed to by (param_1 + 0x24) as the first argument. The return value of BIO_callback_ctrl is then returned by the function. If the value stored at the memory address pointed to by (param_1 + 0x24) is equal to NULL, the function returns 0."
openssl-101f,O2,x86,asn1_bio_ctrl,./data/decomp/openssl-101f_x86_gcc_O2_extraction/asn1_bio_ctrl@081e4e70.c,"The `asn1_bio_ctrl` function takes in a `bio_st` structure pointer, an integer, a long integer, and an integer pointer, and returns a long integer. It checks if the `ptr` field of the `bio_st` structure is `NULL`. If it is, the function returns 0. If `param_2` is equal to 0x97, the function sets the `10` and `0xb` fields of the `piVar2` integer array to the values pointed to by `param_4` and `param_4[1]`, respectively, and returns 1. If `param_2` is less than 0x98, the function checks if `param_2` is equal to 0x95. If it is, the function sets..."
openssl-101f,O2,x86,asn1_bio_free,./data/decomp/openssl-101f_x86_gcc_O2_extraction/asn1_bio_free@081e4dd0.c,"The function takes an integer parameter (param_1) and frees the memory allocated to it. It first retrieves a pointer from the offset 0x20 of the parameter and checks if it is not null. If it is not null, it checks if the pointer at an offset of 4 from the retrieved pointer is not null. If it is not null, it frees the memory allocated to it using the CRYPTO_free function. It then frees the memory pointed to by the retrieved pointer using the same function. Finally, it sets the values at offsets 0xc, 0x20, and 0x14 of the parameter to zero and returns 1 to indicate success. If the retrieved pointer is null, it returns 0 to indicate failure."
openssl-101f,O2,x86,asn1_bio_write,./data/decomp/openssl-101f_x86_gcc_O2_extraction/asn1_bio_write@081e5170.c,"The function asn1_bio_write() takes in a BIO object, a pointer to data, and the length of the data. It checks if the data and length are valid, and if the next_bio field of the BIO object is not null. If any of these conditions are not met, the function returns 0. The function then proceeds to check the state of the BIO object by looking at the value of a uint variable pointed to by the ptr field of the BIO object. Depending on the value of this variable, the function performs different actions. If the variable is less than 5, the function enters a loop that switches on the value of the variable. Depending on the case, the function may perform actions such as calculating the size of an ASN.1 object, writing data to the next_bio object, or calling a callback function. If the variable is greater than or equal to 5, the function clears the flags of the BIO object and returns 0."
openssl-101f,O2,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BIO_asn1_get_suffix@081e5580.c,"The function `BIO_asn1_get_suffix` retrieves the suffix of an ASN.1 object from a `BIO` object. It takes three arguments: a `BIO` pointer `b`, a double pointer `psuffix`, and another double pointer `psuffix_free`. The function declares local variables `lVar1`, `local_18`, `local_14`, and `local_10`. `lVar1` stores the result of a call to `BIO_ctrl`, `local_18` and `local_14` are pointers to undefined values, and `local_10` stores the value of the stack pointer at the beginning of the function. The function then calls `BIO_ctrl` with three arguments: the `BIO` object `b`, the constant `0x98`, and the value `0`."
openssl-101f,O2,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BIO_asn1_set_prefix@081e5480.c,"The function sets the prefix string for a BIO object using the BIO_ctrl function with command code 0x95 and returns the result. It takes in a BIO object, a prefix string, and a prefix_free string as arguments. If there is a stack check failure, it does not return."
openssl-101f,O2,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_get0_nist_prime_224@081e55f0.c,"The function returns a pointer to a BIGNUM structure containing a NIST prime number with 224 bits. The prime number's value is stored in a static array named ""_bignum_nist_p_224"". The function does not have any parameters and its calling convention is unknown."
openssl-101f,O2,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_get0_nist_prime_384@081e5610.c,"The function returns a pointer to a BIGNUM structure containing a 384-bit NIST prime number, stored in a static array named ""_bignum_nist_p_384"". It has no parameters and its calling convention is unknown. The warning message indicates that the function's parameter storage is locked, preventing the compiler from modifying parameter passing."
openssl-101f,O2,x86,BN_GF2m_add,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_add@081df9d0.c,"The function takes in three arguments: a BIGNUM pointer and two integer pointers, and returns an integer value. It checks the size of the two integer arrays pointed to by the second and third arguments, and stores the larger size in the variable iVar2. If the size of param_3 is larger than param_2, it swaps the pointers param_2 and param_3. Next, the function checks if the size of the BIGNUM object pointed to by param_1 is less than iVar2. If it is, the function expands the BIGNUM object using the bn_expand2() function. The function then performs a bitwise XOR operation between the integers pointed to by param_2 and param_3, and stores the result in the BIGNUM object pointed to by param_1. This is done using a loop that iterates over the integers in the two arrays until the end of the smaller array is reached. If the size of the array pointed to is smaller than iVar2, the function pads it with zeroes."
openssl-101f,O2,x86,BN_GF2m_mod,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod@081dfb70.c,"The function BN_GF2m_mod takes in two BIGNUM pointers and an integer pointer and returns an undefined 4-byte value. It first checks if the second parameter has a non-zero value in its second element. If it does not, an error is thrown and the function returns 0. Next, the function creates an array of integers to store the indices of the non-zero bits in param_2. If there are more than 6 non-zero bits, an error is thrown and the function returns 0. If there are 6 or fewer non-zero bits, the function proceeds to compute the result of the GF2m modular reduction operation using the BN_GF2m_mod_arr_part_0 function. If param_1 and param_2 are not the same BIGNUM, param_2 is copied into param_1 before the operation."
openssl-101f,O2,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_arr@081dfad0.c,"The function takes in three parameters: two BIGNUM pointers and an integer pointer. If the integer pointed to by the third parameter is zero, it sets the first BIGNUM pointer to zero and returns 1. If the third parameter is not zero, the function checks if the first BIGNUM pointer is equal to the second BIGNUM pointer. If they are not equal, it expands the first BIGNUM pointer to be the same size as the second BIGNUM pointer and copies the values of the second BIGNUM pointer into the first BIGNUM pointer. Finally, the function calls another function BN_GF2m_mod_arr_part_0() and returns the result."
openssl-101f,O2,x86,BN_GF2m_mod_div,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_div@081e1450.c,"The function BN_GF2m_mod_div in the OpenSSL library performs division in a binary field. It takes three BIGNUMs as input: the divisor, the dividend, and a temporary BIGNUM allocated from a BN_CTX object. It also takes a BN_CTX object for temporary storage. The function first computes the modular inverse of the divisor using BN_GF2m_mod_inv and stores it in the temporary BIGNUM. If the inverse cannot be computed, the function returns 0. Next, the function computes the number of bits in the dividend and allocates a buffer to store the indices of the non-zero bits. It then iterates over the limbs of the dividend, scanning each limb for non-zero bits and storing their indices in the buffer. If the buffer size is greater than the number of bits in the dividend, the function returns 0."
openssl-101f,O2,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_div_arr@081e1600.c,The function BN_GF2m_mod_div_arr in OpenSSL's cryptographic library takes three BIGNUM integers and an array of integers as input. It initializes a new BIGNUM integer and sets specified bits to 1. It computes the inverse modulo of one of the BIGNUM integers and allocates an array to store bit indices. It iterates over the bits and stores the indices in the array. The function then calls another function.
openssl-101f,O2,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_mul@081e0b40.c,The function BN_GF2m_mod_mul performs a multiplication operation on two BIGNUM values in GF(2^m) finite field. It calculates the number of bits in the first BIGNUM value and allocates memory to store the result. Non-zero bits are extracted from the first BIGNUM value and stored in the allocated memory. The BN_GF2m_mod_mul_arr function is called to perform the multiplication operation using the stored positions of non-zero bits. The allocated memory is then freed and the result of the multiplication operation is returned. The function generates and returns an error message if any errors occur during execution.
openssl-101f,O2,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_mul_arr@081dff10.c,"These functions all involve mathematical operations on large integers using a BN_CTX context structure. 

The first function, BN_GF2m_mod_mul_arr, multiplies two arrays of integers in GF(2^m) and reduces the result modulo a polynomial. It takes five parameters and returns a boolean value. The function first checks if the two input arrays are equal, and if not, allocates memory for a BIGNUM object. It then initializes the BIGNUM object and loops through each element of the second input array to perform bitwise operations and XOR the result.

The second function takes in five parameters and returns a boolean value indicating success or failure. It computes the square of a polynomial modulo using precomputed values in a lookup table. The function first checks if the modulus is zero, and if not, loops through each element in the polynomial array to perform a squaring operation. The result is stored in a temporary BIGNUM variable and reduced modulo the modulus using the BN_GF2m_mod_arr_part_0 function. If the reduction is successful, the result is copied to the output BIGNUM variable.

The third function takes in several parameters including two BIGNUMs (large integers), an integer, and a BN_CTX. It returns a boolean value indicating success or failure. The function first initializes some variables and checks if the input parameters are valid. It then performs a loop to calculate the square of the first BIGNUM parameter using a precomputed table of values. The result is stored in a temporary BIGNUM variable. Next, the function calculates the product of the two input BIGNUMs using a modular reduction algorithm. If the result is zero, the function sets the output BIGNUM to zero and returns true. Otherwise, if the temporary BIGNUM is not equal to the second input BIGNUM, the function expands the output BIGNUM and copies the values over. The function then returns true. If the expansion fails, it returns false."
openssl-101f,O2,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_sqr@081e0c90.c,"The function BN_GF2m_mod_sqr computes the square of a BIGNUM in the finite field GF(2^m), where m is a positive integer. It allocates memory for an array of integers to store the positions of the non-zero bits in the BIGNUM. It then iterates through the words of the BIGNUM to find the positions of the non-zero bits, and passes this array of integers to the function BN_GF2m_mod_sqr_arr to compute the square of the BIGNUM in GF(2^m) using a polynomial basis representation. The result is returned as an integer, and the memory allocated for the array of integers is freed. If there are no non-zero bits in the BIGNUM, an error is generated."
openssl-101f,O2,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_sqrt@081e1c00.c,"The function BN_GF2m_mod_sqrt calculates the square root of a binary polynomial in GF(2^m) using the Berlekamp algorithm. The input is a BIGNUM representation of the binary polynomial, param_3, and the output is the square root, param_1. The function returns 1 if the square root exists, and 0 otherwise. The function first calculates the number of bits in the input binary polynomial and allocates memory for an array of integers to store the positions of the non-zero bits in the polynomial. It then loops through the bits of the polynomial and stores the positions of the non-zero bits in the array. If the array is not empty, the function sets a bit in a BIGNUM variable, a, corresponding to the highest position of a non-zero bit in the polynomial. It then calculates the square root using the BN_GF2m_mod_exp_arr function, which performs modular exponentiation in GF(2^m) using an array of."
openssl-101f,O2,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_GF2m_mod_sqr_arr@081dfcf0.c,"BN_GF2m_mod_sqr_arr is a function in OpenSSL's BIGNUM library that computes the square of a binary polynomial represented as an array of uint32_t integers. It takes four arguments: a pointer to a BIGNUM structure that will hold the result, an array of uint32_t integers representing the input polynomial, a pointer to an integer that specifies the degree of the input polynomial, and a pointer to a BN_CTX structure that is used for temporary storage. The function first allocates a new BIGNUM structure using the BN_CTX_get function. If the allocation fails, the function returns false. The function then checks if the allocated BIGNUM structure has enough space to hold the result, and expands it if necessary using the bn_expand2 function. Next, the function computes the square of the input polynomial using a lookup table called SQR_tb. The result is stored in the allocated BIGNUM structure. The function then trims any leading zero."
openssl-101f,O2,x86,BN_kronecker,./data/decomp/openssl-101f_x86_gcc_O2_extraction/BN_kronecker@081dec60.c,"The function takes two BIGNUM pointers a and b, and a BN_CTX pointer ctx as input. It returns the Kronecker symbol of a and b, which is a generalization of the Legendre symbol to all odd integers. The function first allocates two BIGNUM variables a_00 and a_01 using BN_CTX_get() function. It then copies the value of a into a_00 and b into a_01 using BN_copy() function. If the function fails to allocate or copy, it returns -2. Next, the function checks if either a_00 or a_01 is zero or odd. If so, it calculates the Kronecker symbol using a simple formula and returns the result. If neither a_00 nor a_01 is zero or odd, it performs the Kronecker algorithm. The algorithm first normalizes a_01 by shifting it to the right until the least significant bit is 1. It then calculates the Kronecker symbol."
openssl-101f,O2,x86,by_dir_entry_free,./data/decomp/openssl-101f_x86_gcc_O2_extraction/by_dir_entry_free@08168760.c,"The function takes in a pointer to a pointer (void **param_1) as its argument. It first checks if the value pointed to by param_1 is not NULL. If it is not NULL, it frees the memory pointed to by param_1 using the CRYPTO_free function. Next, it checks if the third element of the array pointed to by param_1 (param_1[2]) is not NULL. If it is not NULL, it frees the memory pointed to by param_1[2] using the sk_pop_free function, which is a function to free a stack structure. Finally, it frees the memory pointed to by param_1 using the CRYPTO_free function and returns from the function. Overall, the function is responsible for freeing memory allocated to a directory entry structure and its associated hash table."
openssl-101f,O2,x86,cswift_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O2_extraction/cswift_rand_bytes@081a0320.c,"The function ""cswift_rand_bytes"" generates a random byte sequence of length ""param_2"" and stores it in the memory location pointed to by ""param_1"". It acquires an access context using the CSwift library and generates random bytes in chunks of 1024 bytes until the remaining number of bytes to be generated is less than or equal to 1024. Finally, it generates the remaining bytes and stores them in the memory location pointed to by ""param_1"". If any error occurs during the generation of random bytes or while acquiring the access context, an error message is added to the error queue using the ERR_put_error function. The function returns 1 if the random bytes were generated successfully and 0 otherwise."
openssl-101f,O2,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_x86_gcc_O2_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9cf0.c,"The function takes three parameters: a pointer to an ASN1_VALUE, a pointer to an unsigned character (uchar), and a long integer. It calls the ASN1_item_d2i function, passing in the three parameters as well as a pointer to an ASN1_ITEM structure representing the GOST_CLIENT_KEY_EXCHANGE_PARAMS data type. The purpose of this function is to decode (deserialize) a GOST_CLIENT_KEY_EXCHANGE_PARAMS structure from the provided uchar buffer and store the resulting data in the ASN1_VALUE pointed to by param_1. The function returns without any explicit return value."
openssl-101f,O2,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_x86_gcc_O2_extraction/d2i_GOST_KEY_PARAMS@081d9bf0.c,"The function converts ASN1 encoded GOST key parameters to their internal representation using the ASN1_item_d2i() function. It takes three arguments: a pointer to an ASN1_VALUE, a pointer to a uchar, and a long. The function stores the internal representation in the memory pointed to by the first argument and returns without any value. The ASN1_ITEM argument specifies the type of the ASN1 object being decoded (in this case, GOST_KEY_PARAMS_it)."
openssl-101f,O2,x86,decode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O2_extraction/decode_gost_algor_params@081d78c0.c,"The function takes an EVP_PKEY object and a X509_ALGOR object as parameters, and returns a boolean value indicating the success of the decoding of the GOST algorithm parameters. It first extracts the algorithm parameters using X509_ALGOR_get0 and determines the type of GOST algorithm using OBJ_obj2nid. If the algorithm is ECDSA, it creates a new EC_KEY object and fills it with the appropriate parameters using fill_GOST2001_params. If the algorithm is DSA, it creates a new DSA object and fills it with the appropriate parameters using fill_GOST94_params. If the decoding is successful, the function returns true. Otherwise, it returns false and sets an error message using ERR_GOST_error."
openssl-101f,O2,x86,DES_xcbc_encrypt,./data/decomp/openssl-101f_x86_gcc_O2_extraction/DES_xcbc_encrypt@081ddf90.c,"The functions `DES_xcbc_encrypt` and `CBC_mode_DES_encrypt` both encrypt byte arrays using DES. `DES_xcbc_encrypt` takes in an input byte array, an output byte array, a length parameter, a DES key schedule, an initialization vector (`ivec`), and two constant DES blocks (`inw` and `outw`). It also takes in a flag `enc` indicating whether to encrypt or decrypt the input. If `enc` is non-zero, the function performs XCBC encryption on the input byte array using the given key schedule, initialization vector, and constant blocks. If `enc` is zero, the function performs XCBC decryption on the input byte array using the same parameters as for encryption. 

`CBC_mode_DES_encrypt` takes in a plaintext message, a key, an initialization vector (IV), and the length of the message as inputs. It then divides the message into blocks of 8 bytes and encrypts each block using DES algorithm with the given key and IV. For each block, the function XORs the plaintext with the previous ciphertext (or IV for the first block), encrypts the result using DES algorithm with the given key, and outputs the resulting ciphertext. It also updates the IV to be the ciphertext of the current block for use in the next block. If the length of the message is not a multiple of 8 bytes, the function pads the message with zeros to make it a multiple of 8 bytes before encryption. The function also performs some error checking and stack protection before returning the ciphertext."
openssl-101f,O2,x86,dgram_ctrl,./data/decomp/openssl-101f_x86_gcc_O2_extraction/dgram_ctrl@08120f10.c,The functions `dgram_ctrl` and `switchD_08120f42_case` both take four parameters and begin by initializing local variables. `dgram_ctrl` switches on the value of its second parameter and sets `param_3` based on the case. `switchD_08120f42_case` enters a switch statement based on its second parameter and sets `param_3` based on the case.
openssl-101f,O2,x86,dlfcn_bind_func,./data/decomp/openssl-101f_x86_gcc_O2_extraction/dlfcn_bind_func@081e4350.c,"The ""dlfcn_bind_func"" function takes two integer parameters and returns an integer value. If either parameter is zero, it sets ""line"" to 0x110 and ""iVar1"" to 0x43. If both parameters are non-zero, it gets the number of items in a stack pointed to by the first parameter plus 4. If the number of items is less than 1, it sets ""line"" to 0x115 and ""iVar1"" to 0x69. If the number of items in the stack is greater than or equal to 1 and the value of the last item in the stack is not null, it calls the dlsym function with the last item in the stack and the second parameter as arguments. If dlsym returns 0, the function..."
openssl-101f,O2,x86,dlfcn_bind_var,./data/decomp/openssl-101f_x86_gcc_O2_extraction/dlfcn_bind_var@081e4450.c,"The function takes two parameters: param_1 and param_2. If either parameter is equal to 0, the function sets the variable ""line"" to 0xee and returns the integer value 0x43. If both parameters are not equal to 0, the function gets the number of items in a stack pointed to by the value at the memory location param_1 + 4. If the number of items is less than 1, the function sets the variable ""line"" to 0xf3 and returns the integer value 0x69. If the number of items in the stack is greater than or equal to 1, the function gets the value at the top of the stack (which is at index iVar1 - 1, where iVar1 is the number of items in the stack). If the value is not equal to 0, the function calls the dlsym function with the value and param_2 as arguments. If the dlsym function returns a non-zero value, the function sets the variable ""line"" to 0xf6 and returns the integer value 0x6f. If the dlsym function returns 0, the function sets the variable ""line"" to 0xf7 and returns the integer value 0x7b."
openssl-101f,O2,x86,dlfcn_globallookup,./data/decomp/openssl-101f_x86_gcc_O2_extraction/dlfcn_globallookup@081e4070.c,"This function takes in an argument of type `undefined4` and returns a value of type `undefined4`. It uses the `dlopen` function to load the dynamic linker library and returns a handle to it. It then uses the `dlsym` function to search for the symbol specified by the argument `param_1` in the loaded library. If the symbol is found, it returns a pointer to the symbol. Finally, it uses the `dlclose` function to close the handle to the dynamic linker library. If the `dlopen` function fails to load the library, it returns 0."
openssl-101f,O2,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_mont_field_encode@081e2870.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It retrieves a BN_MONT_CTX pointer from the integer parameter. If it is not NULL, it uses BN_mod_mul_montgomery() function to calculate the modular multiplication of the second and third parameters using the Montgomery reduction algorithm with the Montgomery context. The result is stored in the first parameter. If the BN_MONT_CTX pointer is NULL, it generates an error using the ERR_put_error() function and returns 0."
openssl-101f,O2,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_mont_field_sqr@081e2810.c,"The function takes four arguments: an integer, a pointer to a BIGNUM structure, another pointer to a BIGNUM structure, and a pointer to a BN_CTX structure. 

The function checks if the BN_MONT_CTX pointer stored at offset 0xa0 of the integer argument is not NULL. If it is not NULL, it calls the BN_mod_mul_montgomery function to compute the square of the second BIGNUM argument using the Montgomery multiplication algorithm with the Montgomery context pointed to by the BN_MONT_CTX pointer stored in the integer argument. The result is stored in the first BIGNUM argument.

If the BN_MONT_CTX pointer is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101f,O2,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_mont_group_init@081e2420.c,"The function `ec_GFp_mont_group_init` initializes a group for elliptic curve cryptography using Montgomery multiplication. It first calls the function `ec_GFp_simple_group_init` to initialize the group using simple (non-Montgomery) multiplication. Then, it sets two variables to zero: `*(undefined4 *)(param_1 + 0xa0)` and `*(undefined4 *)(param_1 + 0xa4)`. These variables are likely used in the Montgomery multiplication algorithm. Finally, the function returns."
openssl-101f,O2,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_nist_field_mul@081e2ba0.c,"The function is a multiplication operation for elliptic curve cryptography on a prime field. It takes four parameters: an integer parameter (param_1), and three BIGNUM parameters (param_2, param_3, and param_4). It also takes a BN_CTX parameter (param_5) which is optional and can be null. The function first checks if any of the input parameters are null. If so, it puts an error message into the error queue using the ERR_put_error function. If the BN_CTX parameter is null, the function creates a new BN_CTX using the BN_CTX_new function. It then performs the multiplication operation using the BN_mul function, passing in the three BIGNUM parameters and the newly created BN_CTX. If the multiplication is successful, it performs a modular reduction operation using a function pointer obtained from the param_1 integer parameter. It then frees the BN_CTX and returns a boolean value indicating whether the operation was successful. If the BN_CTX parameter is not null, the function uses it instead of creating a new one."
openssl-101f,O2,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_nist_group_copy@081e29a0.c,"The function `ec_GFp_nist_group_copy` copies the value of the `order` field from the second elliptic curve group to the first group and calls `ec_GFp_simple_group_copy()` to copy the remaining fields of the second group to the first group. The implementation of `ec_GFp_simple_group_copy()` is not shown in the code snippet, so it is unclear what it does. The function returns without any output or further processing."
openssl-101f,O2,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_nist_group_set_curve@081e29c0.c,"The function ec_GFp_nist_group_set_curve takes in five parameters: an integer, a BIGNUM pointer, and three undefined 4-byte values, as well as a BN_CTX pointer. It checks if the BN_CTX pointer is null and creates a new one if necessary. It then gets a BIGNUM pointer from the BN_CTX and sets it to pBVar1. If pBVar1 is null, the function returns 0. If the BN_CTX pointer is not null, it starts the BN_CTX and gets a BIGNUM pointer from it. If the BIGNUM pointer is null, the function returns 0. The function then compares the second parameter passed into the function to the NIST prime for 192, 224, 256, 384, and 521 bits and sets a function pointer to the corresponding N if there is a match."
openssl-101f,O2,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e74d0.c,"The function takes an integer pointer, an integer, and three BIGNUM pointers (with an optional BN_CTX pointer). It returns a boolean value. If the integer value pointed to by the integer pointer is zero, the function checks if the BIGNUM pointers are not null and copies their values to the corresponding input parameters before returning true. If the third BIGNUM pointer is null, it still returns true. If the integer value is not zero, the function creates a BN_CTX object (if necessary) and calls a function pointer with the input parameters and BN_CTX object. It returns true if the function pointer returns a non-zero value for both the second and third input parameters."
openssl-101f,O2,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_group_check_discriminant@081e76a0.c,"The function `ec_GFp_simple_group_check_discriminant` checks the validity of an elliptic curve group's discriminant. It takes two parameters: an integer pointer `param_1` that contains information about the elliptic curve group, and a `BN_CTX` pointer `param_2` that is used for temporary storage during the computation. The function first checks if `param_2` is null, and if so, creates a new `BN_CTX` object. It then uses the `BN_CTX_start` function to initialize the temporary storage, and retrieves several `BIGNUM` objects from the context using the `BN_CTX_get` function. If the `BN_CTX_get` function returns a non-null value for the `pBVar1` object, the function checks if the elliptic curve group has a custom implementation for computing the coefficients `a` and `a_00`. If not, it simply copies the values from the `param_1` array."
openssl-101f,O2,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_group_clear_finish@081e7130.c,"The function takes an integer parameter `param_1` which is assumed to be a pointer to a structure representing an elliptic curve group. The function then clears and frees the memory allocated to three BIGNUMs within the structure located at offsets `0x48`, `0x74`, and `0x88` from the beginning of the structure. The function does not return anything."
openssl-101f,O2,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_group_copy@081e8280.c,"This function takes two integer parameters that represent pointers to structures of a simple elliptic curve group. It copies the values of the three BIGNUM fields of the second structure into the corresponding fields of the first structure using the BN_copy function. If all three copies are successful, the function sets the fourth field of the first structure to the value of the fourth field of the second structure and returns 1 to indicate success. If any of the copies fail, the function returns 0 to indicate failure."
openssl-101f,O2,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_group_get_degree@081e71a0.c,"The function takes an integer parameter `param_1`, likely a pointer to an `EC_GROUP` structure in OpenSSL library. It retrieves the order of the elliptic curve group associated with the `EC_GROUP` structure, calculates the number of bits required to represent the order using `BN_num_bits` function, and returns the result. The number of bits required to represent the order is also known as the degree of the elliptic curve group. However, the function does not return the degree explicitly, but it is assumed that the caller will use the returned value accordingly."
openssl-101f,O2,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_group_set_curve@081e8370.c,"The function takes in four BIGNUM parameters and a BN_CTX parameter. It checks if the number of bits in the second parameter is less than 3, if the top of the second parameter is less than 1, or if the least significant bit of the second parameter is not set. If any of these conditions are true, an error is generated and the function returns 0. If the BN_CTX parameter is null, a new BN_CTX is created and initialized. If it is not null, the function starts a new BN_CTX within the existing context. The function then sets the sign of the third parameter to positive and takes its modulus with respect to the second parameter. If the modulus operation fails, the function returns 0. If the function pointer at the address stored in the first parameter is null, the fourth parameter is copied to the memory location starting at the first parameter plus 0x1d. If the function pointer is not null, the function at that address is called."
openssl-101f,O2,x86,ec_GFp_simple_invert,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_invert@081e90a0.c,"The function takes an EC_GROUP and an EC_POINT as input. It checks if the point is at infinity or not using EC_POINT_is_at_infinity. If the point is not at infinity and its y-coordinate is not equal to zero, it calculates the inverse of the point's x-coordinate using BN_usub. If the point is at infinity or its y-coordinate is zero, the function returns 1. The function returns the result of the computation or 1."
openssl-101f,O2,x86,EC_GFp_simple_method,./data/decomp/openssl-101f_x86_gcc_O2_extraction/EC_GFp_simple_method@081e9c60.c,"The function returns a pointer to an EC_METHOD structure for elliptic curve cryptography over a prime field. It does not have any parameters and its calling convention is unclear. The function's parameter storage is locked, which may be a warning to other developers."
openssl-101f,O2,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_point_copy@081e8300.c,"The function takes two integer parameters representing points on an elliptic curve in GF(p) field. It copies the x-coordinate, y-coordinate, and z-coordinate values of the second point to the first point, as well as the point type. It uses the BN_copy function from OpenSSL's BIGNUM library. If the copying operation is successful, the function returns 1, otherwise it returns 0."
openssl-101f,O2,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_point_finish@081e7100.c,"The function ec_GFp_simple_point_finish() frees memory allocated for three BIGNUM variables storing x, y, and z coordinates of an elliptic curve point, given the memory address of the point. It does not perform any other action and returns."
openssl-101f,O2,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7910.c,"The function takes an EC_GROUP object, an EC_POINT object, and four BIGNUM objects as input, and returns a boolean indicating success. It checks if the EC_POINT is at infinity and throws an error if it is. It creates a BN_CTX object and allocates four BIGNUM objects if none are provided. If the EC_POINT has a precomputed table, it uses it to compute the affine coordinates. Otherwise, it computes the inverse of the x-coordinate modulo the group order and uses it to compute the y-coordinate using the group's equation. If input BIGNUM objects for the x and y coordinates are not null, it stores the computed values in them. Finally, it cleans up the BN."
openssl-101f,O2,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O2_extraction/ec_GFp_simple_point_set_affine_coordinates@081e85e0.c,"The function takes an EC_GROUP object, an EC_POINT object, two BIGNUM objects, and a BN_CTX object as input. If both BIGNUM objects are non-null, the function sets the point's coordinates using EC_POINT_set_Jprojective_coordinates_GFp. Otherwise, an error is generated using ERR_put_error. The function returns an integer value indicating success or failure."
openssl-101f,O2,x86,encode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O2_extraction/encode_gost_algor_params@081d8ab0.c,"The function encodes GOST algorithm parameters as an ASN1_STRING using an EVP_PKEY parameter. It creates a new ASN1_STRING object and a GOST_KEY_PARAMS object, checking for errors. It determines the base ID of the EVP_PKEY parameter and retrieves the EC group curve name or key parameters. If a match is found with the known parameter sets, it retrieves the corresponding NID. The function sets the first element of the GOST_KEY_PARAMS object to the NID of the curve or parameter set and the second element to the NID of the hash function. Finally, the GOST_KEY_PARAMS object is encoded into the ASN1_STRING object."
openssl-101f,O2,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_x86_gcc_O2_extraction/general_allocate_boolean.constprop.5@081896c0.c,"The function takes in two strings and several integers as parameters. It checks if the first string is null and returns an error code if it is. It then checks if the second string is not null and iterates through each character in the first string to check if it is present in the second string. If there are no matching characters and the second string is not null, it allocates memory and creates a new stack object, sets values in the allocated memory block, and pushes it onto the stack. Finally, it returns an error code if a certain parameter is not zero, otherwise it returns the result of the stack push operation."
openssl-101f,O2,x86,get_gost_engine_param,./data/decomp/openssl-101f_x86_gcc_O2_extraction/get_gost_engine_param@081db3b0.c,"The ""get_gost_engine_param"" function takes an integer parameter ""param_1"". If ""param_1"" is not equal to zero, the function returns a null pointer. If ""gost_params"" is null, the function tries to get the value of the environment variable ""CRYPT_PARAMS"" using getenv(). If the value of ""CRYPT_PARAMS"" is null, the function returns a null pointer. If ""CRYPT_PARAMS"" has a value, the function allocates memory using BUF_strdup() and assigns the value of ""CRYPT_PARAMS"" to ""gost_params"". Finally, the function returns the value of ""gost_params""."
openssl-101f,O2,x86,gost2001_param_encode,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost2001_param_encode@081d7de0.c,"The function encodes the parameters of the GOST R 34.10-2001 elliptic curve cryptography algorithm using an EVP_PKEY object as input. It extracts the EC_KEY object from the EVP_PKEY object and gets the EC_GROUP object from the EC_KEY object. It gets the curve name of the EC_GROUP object using the EC_GROUP_get_curve_name() function and converts the curve name integer to an ASN1_OBJECT using the OBJ_nid2obj() function. Finally, it encodes the ASN1_OBJECT into a binary format using the i2d_ASN1_OBJECT() function and stores the result in the uchar pointer passed in as a parameter. The encoded parameters can be used to generate a public/private key pair for the GOST R 34.10-2001 algorithm."
openssl-101f,O2,x86,gost_cipher_cleanup,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost_cipher_cleanup@081d9f50.c,"The function takes an integer parameter `param_1`. It then calls the `gost_destroy()` function on a value obtained by adding 12 to the integer value stored at the memory location pointed to by the expression `*(int *)(param_1 + 0x60)`. This is likely some kind of pointer arithmetic to access a specific memory location. After that, the function sets the integer value stored at the memory location pointed to by the expression `*(undefined4 *)(param_1 + 0x54)` to 0. Finally, the function returns 1. It is not clear what this function is used for or how it fits into a larger program without more context."
openssl-101f,O2,x86,gost_cipher_ctl,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost_cipher_ctl@081da4a0.c,"The function gost_cipher_ctl takes four parameters: two integers, an undefined 4-byte value, and a pointer to an undefined 4-byte value. If the second parameter is equal to 6, the function calls the RAND_bytes function to generate random bytes and stores them in the memory pointed to by the fourth parameter. If the RAND_bytes function returns a non-negative value, the function returns 1. Otherwise, it calls the ERR_GOST_error function to report an error and returns -1. If the second parameter is equal to 7 and the fourth parameter is not null, the function stores the value 0x32a in the memory pointed to by the fourth parameter and returns 1. Otherwise, it returns 0. If the second parameter is neither 6 nor 7, the function calls the ERR_GOST_error function to report an error and returns -1."
openssl-101f,O2,x86,gost_cipher_do_cnt,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost_cipher_do_cnt@081da0c0.c,"The `gost_cipher_do_cnt` function performs encryption or decryption using the GOST block cipher in counter (CTR) mode. It takes four parameters: an integer, a pointer to a byte array, another pointer to a byte array, and an unsigned integer. 

The function generates a new counter value if the value of a variable stored at offset 0x50 in the integer parameter is zero. It sets the local variable `local_20` to 8 and `uVar4` to 0. If the counter value is not zero, the function performs an XOR operation between the counter value and the input data and stores the result in the output buffer if the counter value is less than 8 and the input data size is greater than zero. This process is repeated until the operation is complete."
openssl-101f,O2,x86,gost_cipher_init,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost_cipher_init@081db0d0.c,"The function initializes the GOST cipher context with specified parameters. It checks if the context's app_data is null, retrieves the GOST engine parameter, and sets the cipher data accordingly. If a specific cipher is specified, it checks if it is valid and sets the cipher data accordingly. If a key is specified, it calls the gost_key function to set the key. If an initialization vector (IV) is specified, it copies it to the context's original IV (oiv) and sets the IV to the oiv. The function returns 1 to indicate success."
openssl-101f,O2,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O2_extraction/GOST_CIPHER_PARAMS_new@081d9cb0.c,"The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function, which allocates memory and initializes the structure. It then returns without any further action."
openssl-101f,O2,x86,gost_imit_final,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost_imit_final@081dad70.c,"The function `gost_imit_final` takes two parameters: `param_1` and `param_2`. It retrieves `iVar1` from `param_1 + 0xc` and `iVar2` from `iVar1 + 0x103c`. If `iVar2` is zero, an error is generated. Otherwise, it checks if the value stored at `iVar1 + 0x1030` is zero and if the value stored at `iVar1 + 0x1038` is non-zero. If so, it creates two local variables `local_28` and `local_24`, sets their values to zero, and calls the function `gost_imit_update` with `param_1`, `local_28`, `local_24`, and `param_2`."
openssl-101f,O2,x86,gost_imit_init_cpa,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost_imit_init_cpa@081da430.c,"The function initializes the GOST imitation cipher with CryptoProParamSetA parameters by accessing a memory location using an integer parameter. It sets specific variables to zero and one, calls the gost_init function with the memory location and the Gost28147_CryptoProParamSetA parameter, and returns 1 to indicate success."
openssl-101f,O2,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O2_extraction/GOST_KEY_PARAMS_new@081d9c30.c,"The ""GOST_KEY_PARAMS_new"" function creates a new instance of the ""GOST_KEY_PARAMS"" data structure using the ""ASN1_item_new"" function with the ""GOST_KEY_PARAMS_it"" parameter. The function does not return any value."
openssl-101f,O2,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_x86_gcc_O2_extraction/GOST_KEY_TRANSPORT_free@081d9ad0.c,The function frees memory allocated to a GOST_KEY_TRANSPORT object using the ASN1_item_free function and takes an ASN1_VALUE pointer as input. It returns without any value and is likely used when the object is no longer needed.
openssl-101f,O2,x86,gost_param_free,./data/decomp/openssl-101f_x86_gcc_O2_extraction/gost_param_free@081db310.c,"The function ""gost_param_free"" frees the memory allocated to ""gost_params"". It checks if ""gost_params"" is not null, and if it is not null, it frees the memory using ""CRYPTO_free"" function and sets ""gost_params"" to null."
openssl-101f,O2,x86,hash_step,./data/decomp/openssl-101f_x86_gcc_O2_extraction/hash_step@081db480.c,"There are four function summaries:

Function 1:
- Takes in three parameters: a 32-bit integer, and two pointers to 32-bit integers.
- Performs some bitwise operations on the two integers pointed to by the pointers, storing the results in local variables.
- If the pointers are not aligned to 4-byte boundaries, manually copies the data byte-by-byte.
- Calls another function called `gost_enc_with_key` with the 32-bit integer parameter and the local variables as arguments.
- The result of this function call is stored in another local variable.
- Performs some more bitwise operations on the local variables and stores the results in the 32-bit integers pointed to by the pointers.
- Updates some other local variables with the results of these operations.
- Overall, it seems that this function is performing some kind of hashing or encryption operation on the two input integers, using the 32-bit integer parameter as a key. However, without more context it is difficult to say for sure.

Function 2:
- Initializes some local variables and copies some data from the input parameters.
- Calls a function called ""gost_enc_with_key"" with the input key and some data from the input parameters.
- Performs some bitwise operations and XORs on the local variables.
- Calls ""gost_enc_with_key"" again with the input key and some more data from the input parameters.
- Performs more bitwise operations and XORs on the local variables.
- Returns the final values of the local variables.

Function 3:
- Takes in two parameters, an integer array and its size.
- Initializes some local variables and performs some arithmetic operations on them.
- Checks if the size of the array is greater than or equal to 8. If not, it returns 0.
- Assigns the values of the local variables to specific indices of the array parameter.
- Checks if the value of a local variable is equal to a specific index of the array parameter.
- If not, it calls the __stack_chk_fail function and does not return.
- Finally, it returns 1 if the function executes successfully.

Function 4:
- Initializes some local variables and copies some data from the input parameters to these variables.
- Performs some bitwise operations on these variables.
- Calls a function called ""gost_enc_with_key"" with some of these variables as input parameters.
- Performs some more bitwise operations on the variables.
- XORs some data from the input parameters with the variables.
- Performs some"
openssl-101f,O2,x86,hwcrhk_init,./data/decomp/openssl-101f_x86_gcc_O2_extraction/hwcrhk_init@081a2c00.c,"The function hwcrhk_init initializes the nFast HWCryptoHook library, sets up mutex callbacks, and creates an RSA key handle. It returns 1 if successful and 0 if it fails, along with an error code. Additionally, it frees the library and resets all function pointers."
openssl-101f,O2,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_x86_gcc_O2_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9b90.c,The function encodes an ASN.1 structure (GOST_KEY_AGREEMENT_INFO) using a pointer to an ASN1_VALUE structure and a double pointer to an unsigned char value. It uses the ASN1_item_i2d() function to convert the ASN1_VALUE structure into binary format and store it in the uchar pointer. The second parameter is a double pointer because the function needs to modify the pointer to the uchar value to point to the beginning of the encoded data. The function returns once the encoding is complete.
openssl-101f,O2,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_x86_gcc_O2_extraction/i2d_GOST_KEY_TRANSPORT@081d9a90.c,"The i2d_GOST_KEY_TRANSPORT function encodes an ASN1_VALUE into a uchar buffer using the GOST_KEY_TRANSPORT_it ASN1_ITEM. The encoded buffer is stored in the memory location pointed to by the second parameter, which is a double pointer to a uchar. The function does not return a value."
openssl-101f,O2,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101f_x86_gcc_O2_extraction/load_pkcs12.constprop.4@08079a50.c,"The function takes in several parameters, including two BIO pointers, a string, a function pointer, and two pointers to EVP_PKEY and X509 structures. It loads a PKCS12 file using the d2i_PKCS12_bio function and checks if it was loaded successfully. If not, it prints an error message and returns 0. If the PKCS12 file was loaded successfully, it verifies the MAC using the PKCS12_verify_mac function. If the MAC cannot be verified, it tries to obtain a password using the provided password_callback function. If the password_callback function is not provided, it uses a default password_callback function called password_callback. Once it obtains a password, it verifies the MAC again using the obtained password. If the MAC cannot be verified, it prints an error message and returns 0. If the MAC is verified successfully, it parses the PKCS12 file using the PKCS12_parse function and stores the obtained EVP_PKEY and X509 structures."
openssl-101f,O2,x86,padlock_init,./data/decomp/openssl-101f_x86_gcc_O2_extraction/padlock_init@081a9ad0.c,"The ""padlock_init"" function checks if ""padlock_use_rng"" and ""padlock_use_ace"" are not equal to zero, and returns true if either is not zero, indicating successful initialization. If both are zero, it returns false to indicate initialization failure."
openssl-101f,O2,x86,padlock_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O2_extraction/padlock_rand_bytes@081a8be0.c,"The function padlock_rand_bytes generates a specified number of random bytes and stores them in a memory block. If the requested number of bytes is less than 8, it generates random bytes using the xstore_available function until the requested number of bytes is reached. If the requested number of bytes is greater than or equal to 8, the function checks if there is enough space in the memory block to generate 8 bytes at a time. If there is, it generates 8 bytes at a time until the requested number of bytes is reached. If there isn't enough space, the function returns 0 to indicate failure. The function also checks for stack smashing by comparing the current stack pointer to the saved stack pointer at the beginning of the function. If they are different, the function calls __stack_chk_fail to terminate the program."
openssl-101f,O2,x86,param_copy_gost94,./data/decomp/openssl-101f_x86_gcc_O2_extraction/param_copy_gost94@081d8120.c,"The function takes two EVP_PKEY pointers as input, representing two DSA parameters. It checks if the base IDs of these parameters are the same, and if they are not, it throws an error. If they are the same, it copies the values of the DSA parameters from the second EVP_PKEY to the first EVP_PKEY. 

To do this, it first gets a void pointer to the DSA parameter from the second EVP_PKEY. It then gets a DSA pointer to the DSA parameter from the first EVP_PKEY. If the DSA pointer is null, it creates a new DSA object and assigns it to the first EVP_PKEY. It then frees any existing BIGNUMs in the DSA object and duplicates the BIGNUMs from the void pointer to the DSA object. Finally, if the DSA object has a non-zero value for a certain field, it computes the public key for the DSA object.

The function returns a None value."
openssl-101f,O2,x86,param_print_gost01,./data/decomp/openssl-101f_x86_gcc_O2_extraction/param_print_gost01@081d8540.c,"The function extracts an EC_KEY object from an EVP_PKEY object, gets the EC_GROUP object from the EC_KEY object, gets the curve name of the EC_GROUP object, and indents the output of a BIO object by a specified amount. If the indentation is successful, the function prints out the parameter set using the curve name and returns 1. Otherwise, it returns 0."
openssl-101f,O2,x86,param_print_gost94,./data/decomp/openssl-101f_x86_gcc_O2_extraction/param_print_gost94@081d85b0.c,"This function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It retrieves the key material from the EVP_PKEY object and creates a new BIGNUM object called local_24. It then iterates through the R3410_paramset array and compares each parameter set with the key material. If a match is found, it sets the variable iVar2 to the corresponding parameter set value and frees the local_24 object. If no match is found, iVar2 is set to 0. The function then prints the parameter set using the BIO_printf function and returns 1."
openssl-101f,O2,x86,pkey_ctrl_gost,./data/decomp/openssl-101f_x86_gcc_O2_extraction/pkey_ctrl_gost@081d8ea0.c,"The function `pkey_ctrl_gost` takes in four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. It sets up a switch statement based on the value of `param_2`. If `param_2` is not one of the expected values, the function returns an error code. If `param_2` is 1, the function extracts the algorithm information from `param_4` and sets up the appropriate `X509_ALGOR` structures. If `param_2` is 2 or 7, the function encodes the GOST algorithm parameters and sets up the appropriate `X509_ALGOR` or `CMS_RecipientInfo` structures. If `param_2` is 3, the function sets the version of `param_4` to a specific value. Finally, the function returns either a success or error code."
openssl-101f,O2,x86,pkey_free_gost94,./data/decomp/openssl-101f_x86_gcc_O2_extraction/pkey_free_gost94@081d8520.c,"The function ""pkey_free_gost94"" takes an integer parameter ""param_1"" and checks if the value stored at the memory address (param_1 + 0x14) is not NULL. If it is not NULL, it calls the ""DSA_free"" function to free the memory allocated for the DSA object. If the value stored at (param_1 + 0x14) is NULL, it simply returns."
openssl-101f,O2,x86,priv_encode_gost,./data/decomp/openssl-101f_x86_gcc_O2_extraction/priv_encode_gost@081d91d0.c,"The function takes two parameters, a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure, and returns an integer value. It gets the base ID of the EVP_PKEY structure using the EVP_PKEY_base_id function and converts it to an ASN1_OBJECT using the OBJ_nid2obj function. It then calls the encode_gost_algor_params function to get the GOST algorithm parameters in encoded form and stores the result in the pval variable. If the EVP_PKEY structure is of type EC_KEY, it gets the private key from the structure using the EC_KEY_get0_private_key function and stores it in the bn variable. Otherwise, if the EVP_PKEY structure is of type BIGNUM, it gets the BIGNUM value from the structure and stores it in the bn variable. It then calls the BN_to_ASN1_INTEGER function to convert the bn variable to an ASN1_INTEGER structure and stores the result in the a variable."
openssl-101f,O2,x86,pub_encode_gost94,./data/decomp/openssl-101f_x86_gcc_O2_extraction/pub_encode_gost94@081d9080.c,"The function takes in a pointer to an X509_PUBKEY structure and a pointer to an EVP_PKEY structure and returns an integer value. It gets the algorithm object using the base ID of the EVP_PKEY and sets the X509_PUBKEY structure with the algorithm object and GOST algorithm parameters. If the save_parameters flag is set in the EVP_PKEY, it encodes the GOST algorithm parameters using the encode_gost_algor_params() function and sets the local_38 variable to 0x10. It gets the number of bits in the public key, calculates the size of the buffer needed to store it, converts the public key to binary format, and stores it in a buffer. It creates an ASN1_OCTET_STRING structure, sets its value to the binary public key buffer, encodes the ASN1_OCTET_STRING structure, and stores the result in the local_24 variable."
openssl-101f,O2,x86,pub_print_gost94,./data/decomp/openssl-101f_x86_gcc_O2_extraction/pub_print_gost94@081d86a0.c,"The function takes a BIO object, an EVP_PKEY object, and an integer. It retrieves the public key from the EVP_PKEY object and prints it to the BIO object. It searches for a matching parameter set for the key by comparing it to a list of pre-defined parameter sets. Once a match is found, it prints the name of the parameter set to the BIO object. The function returns 1."
openssl-101f,O2,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O2_extraction/RSA_padding_add_PKCS1_PSS@081e36a0.c,"The first function, RSA_padding_add_PKCS1_PSS, adds padding to a message for use in RSA encryption with the PKCS1 PSS scheme. It takes in a RSA key, a message hash, a hash function, and a salt length. The function calculates the size of the hash and checks that the salt length is valid, generates a random salt if the salt length is -2, uses the specified length if the salt length is -1 or greater, and throws an error if the salt length is less than -2 or greater than the maximum allowed length. The function pads the message with random bytes or adds a zero byte to the message before padding, calculates the hash of the padded message, uses a mask generation function to create a mask for the salt, XORs the salt with the mask, and appends the resulting value to the padded message.

The second function takes in a string as input and returns a new string that is the reverse of the input string. It does this by iterating through each character in the input string, starting from the last character and moving backwards, and adding each character to a new string called ""reversed_string"". Finally, it returns the ""reversed_string"" string."
openssl-101f,O2,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O2_extraction/RSA_verify_PKCS1_PSS@081e2d80.c,"The function RSA_verify_PKCS1_PSS is used to verify the signature of a message using the RSA-PSS algorithm. It takes as input the RSA key, message hash, hash algorithm, signature, and signature length. The function initializes an EVP_MD_CTX structure to hold the hash context and calculates the size of the hash output. It checks the validity of the signature length and RSA key size. The function checks the validity of the first byte of the signature according to the PSS standard and proceeds with the verification process. It calculates the mask using the PKCS1_MGF1 function and XORs it with the signature, checking the validity of the first byte of the mask."
openssl-101f,O2,x86,sha_block_data_order,./data/decomp/openssl-101f_x86_gcc_O2_extraction/sha_block_data_order@081dcb10.c,"The functions implement various versions of the SHA-1 hashing algorithm to compute a cryptographic hash of input data. They involve performing a series of bitwise operations, logical operations, and addition modulo 2^32 on blocks of data to update the state of the hash. The resulting hash value is returned as an array of 5 32-bit integers or a 160-bit (20-byte) array. One function appears to be a variant of the SHA-256 hash function. Another function checks a local variable and either returns without doing anything or executes the rest of the code."
openssl-101f,O2,x86,SHA_Final,./data/decomp/openssl-101f_x86_gcc_O2_extraction/SHA_Final@081ddde0.c,"The function takes in a message digest buffer and a SHA context structure as input, and finalizes the SHA computation by padding the message, processing it in 512-bit blocks, and outputting the resulting hash value to the message digest buffer. It sets a flag variable to 0 and appends a single '1' bit to the end of the message. If there is enough space in the current 512-bit block to append the message length (in bits) after the '1' bit, it does so and processes the block using the sha_block_data_order() function. If not, it fills the current block with zeroes and processes it, then fills subsequent blocks with zeroes and processes them until it can append the message length. After processing."
openssl-101f,O2,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_x86_gcc_O2_extraction/SSL_SESSION_free.part.2@080c59a0.c,"The function frees memory allocated for an SSL session object, including custom data associated with the session using CRYPTO_free_ex_data(), cleansing various parts of the session object with OPENSSL_cleanse(), freeing any certificate, stack, and buffers associated with the session using appropriate functions, and ultimately cleansing the entire session object and freeing the memory using CRYPTO_free()."
openssl-101f,O2,x86,start_hash,./data/decomp/openssl-101f_x86_gcc_O2_extraction/start_hash@081dc420.c,"The function takes a pointer to an array of 4-byte integers as input. It checks if the third element of the array is not equal to 0. If it is not 0, it initializes various elements of the array to 0. Specifically, it sets the 5th element and subsequent elements up to a maximum of 48 bytes to 0, and the 13th element and subsequent elements up to a maximum of 76 bytes to 0. It also sets the first, second, and fourth elements of the array to 0. Finally, it returns 1 if the third element was not 0, otherwise it returns 0."
openssl-101f,O2,x86,surewarehk_finish,./data/decomp/openssl-101f_x86_gcc_O2_extraction/surewarehk_finish@081a4ef0.c,"The function surewarehk_finish() cleans up the SureWare library by checking if it has been loaded, calling p_surewarehk_Finish() for cleanup, freeing the library and logstream, setting function pointers to NULL, and returning 0 or 1 depending on successful freeing."
openssl-101f,O2,x86,sv_body,./data/decomp/openssl-101f_x86_gcc_O2_extraction/sv_body@08067fe0.c,"The `sv_body` function is the main body of the `s_server` program, which sets up the SSL context and initializes the SSL connection. It accepts incoming connections, performs SSL/TLS handshake, reads data from the client, and checks for special commands to control the server behavior. It writes back processed data to the client and closes the connection if there is no data for a certain period of time. It also handles errors and cleans up resources before exiting.

The other function sets up a SSL connection with a client and handles incoming data from the client. It first allocates memory for a buffer and checks if non-blocking I/O is enabled. It then creates a new SSL object and sets various options and callbacks depending on the command line arguments. Next, it sets the SSL object's bio to a new socket or datagram bio depending on the SSL version. If the SSL version is TLS 1.3, it sets various options related to timeouts and MTU. It then enters a loop where it checks for incoming data from the client using the select function. If data is available, it reads it into the buffer and handles it according to the command line arguments. If the 'q' command is received, it shuts down the SSL connection and closes the socket. If the 'B' command is received, it sends a heartbeat message to the client. If the 'r' command is received, it renegotiates the SSL connection. Overall, this function sets up and handles the SSL connection with a client."
openssl-101f,O2,x86,__libc_csu_init,./data/decomp/openssl-101f_x86_gcc_O2_extraction/__libc_csu_init@081e9f00.c,The function initializes the C runtime environment by calling the _init() function and looping through the __frame_dummy_init_array_entry array to call functions that initialize global variables and static data structures. It then returns to allow the program to continue executing.
openssl-101f,O2,x86,__udivdi3,./data/decomp/openssl-101f_x86_gcc_O2_extraction/__udivdi3@081e9c70.c,"The function takes in four unsigned integers as parameters: param_1, param_2, param_3, and param_4. It returns an unsigned 64-bit integer (ulonglong). 

If param_4 is equal to zero, the function checks if param_2 is less than param_3. If it is, it returns the result of dividing the concatenation of param_2 and param_1 by param_3 (truncated to 32 bits). If param_3 is also equal to zero, it sets param_3 to the maximum value of a uint. It then calculates the quotient of param_2 divided by param_3 (truncated to 32 bits) and the quotient of the concatenation of param_2 and param_1 divided by param_3 (truncated to 32 bits) and returns the concatenation of these two values.

If param_4 is not equal to zero, the function checks if param..."
openssl-101f,O3,x86,aep_mod_exp.part.0,./data/decomp/openssl-101f_x86_gcc_O3_extraction/aep_mod_exp.part.0@0819e300.c,"The function `aep_mod_exp_part_0` performs modular exponentiation using an AEP Keyper device's hardware security module (HSM). It takes five parameters, including pointers to BIGNUM objects and a BN_CTX object. The function establishes a connection with the device using `aep_get_connection`, and if successful, performs the modular exponentiation operation using `p_AEP_ModExp`. If the operation is successful, the function updates the connection table and releases the lock. If the operation fails, the function logs an error and closes the connection. If the connection cannot be established, the function falls back to another method."
openssl-101f,O3,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_x86_gcc_O3_extraction/asn1_bio_callback_ctrl@081e4db0.c,"The function takes in three parameters: param_1, param_2, and param_3. The first parameter, param_1, is an integer that is used to access a specific memory location. The second parameter, param_2, is also an integer that is used as a control command for the callback function. The third parameter, param_3, is a function pointer that points to the callback function. The function first checks if the value stored in the memory location accessed by param_1 + 0x24 is not equal to NULL. If it is not NULL, it calls the BIO_callback_ctrl function with the parameters passed in. If the value stored at the memory location accessed by param_1 + 0x24 is NULL, the function returns 0. Overall, the function is a wrapper function that calls the BIO_callback_ctrl function with the appropriate parameters."
openssl-101f,O3,x86,asn1_bio_ctrl,./data/decomp/openssl-101f_x86_gcc_O3_extraction/asn1_bio_ctrl@081e4e70.c,"`asn1_bio_ctrl` is a wrapper function for `BIO_ctrl` in OpenSSL's BIO library. It takes four arguments: a pointer to a BIO structure (`param_1`), an integer representing the control command (`param_2`), a long integer representing a parameter for the control command (`param_3`), and a pointer to an integer (`param_4`) where the result of the control command will be stored. The function checks if the `ptr` field of the BIO structure is null and returns 0 if it is. If the control command is 0x97, it sets the values of two fields in the BIO structure and returns 1. If the control command is 0x95, it sets the values of two other fields in the BIO structure and returns 1. If the control command is 0x98 or greater, it retrieves the values of two fields in the BIO structure and returns 1."
openssl-101f,O3,x86,asn1_bio_free,./data/decomp/openssl-101f_x86_gcc_O3_extraction/asn1_bio_free@081e4dd0.c,"The function takes an integer parameter (param_1) and frees the memory allocated to a BIO structure. It retrieves the pointer to the BIO structure from the offset 0x20 of the integer parameter. If the pointer is not null, it checks if the pointer to the data buffer (offset 4 from the BIO structure pointer) is not null. If it is not null, it frees the data buffer using the CRYPTO_free function. Next, it frees the BIO structure itself using the CRYPTO_free function and sets several offsets from the integer parameter to zero. Finally, it returns 1 if the memory was successfully freed, and 0 otherwise."
openssl-101f,O3,x86,asn1_bio_write,./data/decomp/openssl-101f_x86_gcc_O3_extraction/asn1_bio_write@081e5170.c,"The function takes in a BIO object, a pointer to data, and a length of data. It checks if the pointer to data is not null, the length is positive, and the next_bio field of the BIO object is not null. It then retrieves a pointer to an array of integers from the BIO object's ptr field. The function then enters a loop based on the value of the first integer in the array. Depending on the value, the function performs different actions such as calculating the size of an ASN.1 object, writing data to the next_bio object, or calling a callback function. If the write operation fails, the function sets an error flag and returns 0. Otherwise, it updates the array of integers in the BIO object and continues the loop until the data has been fully written or an error occurs. Finally, the function clears the error flag and returns the number of bytes written."
openssl-101f,O3,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BIO_asn1_get_suffix@081e5580.c,"The function takes a BIO object, a pointer to a suffix pointer, and a pointer to a suffix free pointer as input parameters. It returns an integer value. The function initializes a local variable ""local_10"" to the value at the memory location pointed to by the current stack pointer plus an offset of 0x14 to check for stack smashing attacks. The function calls the BIO_ctrl function with the arguments b, 0x98, 0, and a pointer to the local variable ""local_18"" to retrieve the suffix of the ASN.1 object in the BIO object b and stores it in the memory location pointed to by ""local_18"". If the length of the suffix is greater than zero, the function sets the value of the pointer to the suffix to the value of ""local_18"" and sets the value of the pointer to the suffix free to the value of ""local_14"". The function then returns."
openssl-101f,O3,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BIO_asn1_set_prefix@081e5480.c,"The function BIO_asn1_set_prefix sets the prefix for an ASN.1 BIO object. It takes in a BIO object (b), a prefix (prefix), and a prefix_free function pointer (prefix_free). It then calls the BIO_ctrl function with the control code 0x95 and a pointer to the prefix. If the function call succeeds, it returns the result of the call. If not, it raises a stack check failure warning."
openssl-101f,O3,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_get0_nist_prime_224@081e55f0.c,"The function returns a pointer to a BIGNUM object that holds the value of a NIST prime number with 224 bits. The value of the prime number is stored in the global variable ""_bignum_nist_p_224"". The function does not take any parameters and the calling convention is unknown."
openssl-101f,O3,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_get0_nist_prime_384@081e5610.c,The function returns a pointer to a BIGNUM structure that contains the NIST prime 384 used in elliptic curve cryptography.
openssl-101f,O3,x86,BN_GF2m_add,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_add@081df9d0.c,"The function BN_GF2m_add performs addition of two binary polynomials represented as BIGNUMs. It takes three parameters: a pointer to the result BIGNUM, and two pointers to the operands, which are arrays of integers representing binary polynomials. The function first checks the size of the operands and expands the result BIGNUM if necessary. Then, it performs the addition of the two operands by XORing the corresponding bits and storing the result in the result BIGNUM. If one of the operands is shorter than the other, the function copies the remaining bits of the longer operand to the result BIGNUM. Finally, the function trims any leading zero bits in the result BIGNUM and returns 1 to indicate success."
openssl-101f,O3,x86,BN_GF2m_mod,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod@081dfb70.c,"The function BN_GF2m_mod performs modular reduction of a binary polynomial represented as a BIGNUM structure. It takes in the output BIGNUM structure param_1, the input BIGNUM structure param_2, and an array of integers param_3 that represents the irreducible polynomial used for the modular reduction. The function checks if the length of param_3 is greater than 0, and if not, it sets an error flag and returns 0. It then calculates the positions of the non-zero bits in param_2, and stores them in an array local_38. If there are more than 6 non-zero bits, it sets an error flag and returns 0. If there are no non-zero bits, it sets param_1 to 0 and returns 1. Otherwise, it copies the contents of param_2 to param_1, and calls the function BN_GF2m_mod_arr_part_0 to perform the actual modular reduction."
openssl-101f,O3,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_arr@081dfad0.c,"The function takes two BIGNUM pointers and an integer pointer as parameters and returns an undefined value. It first checks if the integer pointed to by the third parameter is 0. If it is, it sets the first parameter to 0 and returns 1. If not, it checks if the two BIGNUM pointers point to the same object. If they don't, it expands the first parameter if necessary and copies the words from the second parameter. Finally, it calls another function, likely to perform the modulo operation. This function appears to be a helper."
openssl-101f,O3,x86,BN_GF2m_mod_div,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_div@081e1450.c,"The function BN_GF2m_mod_div() performs modular division of two BIGNUMs in GF(2^m) field by first computing the inverse of the divisor using BN_GF2m_mod_inv() function. It then computes the bit representation of the dividend and stores it in an array. The function then calls BN_GF2m_mod_mul_arr() to compute the product of the dividend and the inverse of the divisor. The result is stored in the output parameter param_1. The function returns 1 if the computation was successful, and 0 otherwise. The function uses a BN_CTX object for temporary storage."
openssl-101f,O3,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_div_arr@081e1600.c,"The function takes in four parameters: an undefined value, two 32-bit integers, an array of integers, and a BN_CTX object. It returns an unsigned integer. The function initializes a BN_CTX object, creates a BIGNUM object, sets its value to 0, loops through an array of integers and sets corresponding bits in the BIGNUM object to 1. It then creates another BIGNUM object using BN_CTX_get() and computes the modular inverse of the second parameter with respect to the first BIGNUM object. If the modular inverse computation fails or the second BIGNUM object is not created, the function returns 0. If the modular inverse computation succeeds, the function computes the number of bits in the first BIGNUM object."
openssl-101f,O3,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_mul@081e0b40.c,"The function BN_GF2m_mod_mul performs modular multiplication of two binary polynomials over GF(2^m) field. It takes five parameters - three integers and two BIGNUM pointers. The first three parameters are used to specify the irreducible polynomial, the degree of the field, and the modulus respectively. The fourth parameter is the first binary polynomial to be multiplied, and the fifth parameter is the second binary polynomial to be multiplied. The function first calculates the number of bits in the modulus and allocates memory for an array of integers to hold the positions of the non-zero bits in the modulus. It then loops through the words of the modulus, checking each bit to see if it is non-zero. If a non-zero bit is found, its position is added to the array. After the array is constructed, the function calls BN_GF2m_mod_mul_arr to perform the actual multiplication. If the array was not constructed successfully, an error is generated and returned. Finally, the allocated memory."
openssl-101f,O3,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_mul_arr@081dff10.c,"Three functions are described here:

1. BN_GF2m_mod_mul_arr: This function multiplies two polynomials in GF(2^m) and reduces the result modulo an irreducible polynomial. It takes four integer arrays as input: param_2 and param_3 are the coefficients of the two polynomials to be multiplied, param_4 is the coefficients of the irreducible polynomial, and param_1 is the output array for the result. The function uses a lookup table of precomputed values for multiplication and reduction is done using bitwise XOR operations with the coefficients of the irreducible polynomial.

2. A function implementing the squaring operation on a binary polynomial in GF(2^m) using the Karatsuba algorithm. The input binary polynomial is represented as an array of uint32_t values, with each bit of the polynomial represented by a bit in the uint32_t values. The output is also a binary polynomial in the same format. The function checks if the input polynomial is zero, and if so, sets the output polynomial to zero and returns true. Otherwise, it initializes a BN_CTX object for temporary storage of intermediate results. The function then iterates over the uint32_t values in the input polynomial, and for each value, computes the square of the corresponding 32 bits of the input polynomial using a lookup table of precomputed squares in GF(2^m). It then combines the results using the Karatsuba algorithm to obtain the square of the entire input polynomial.

3. A function that takes in five parameters: a BIGNUM pointer `param_1`, an integer array `param_2`, a pointer to a BIGNUM `param_3`, a pointer to an integer `param_4`, and a pointer to a BN_CTX structure `param_5`. The function initializes some variables and sets up the BN_CTX structure. It then checks if `param_3` is NULL or not. If it is not NULL, it sets `param_1` to be equal to `param_3` and returns true. If `param_3` is NULL, the function sets up some more variables and initializes a BIGNUM pointer `pBVar5` to point to `param_1`. It then checks if `param_2` is NULL or if `param_4` is less than or equal to 0. If either of these conditions are true, it sets `param_1` to 0 and returns"
openssl-101f,O3,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_sqr@081e0c90.c,"The function BN_GF2m_mod_sqr performs a modular squaring operation on a BIGNUM object in GF(2^m) finite field. It calculates the number of bits in the BIGNUM object, allocates memory for an array of integers to store the positions of the set bits in the BIGNUM object, iterates through the BIGNUM object to find the positions of the set bits and stores them in the array. The array is then passed to the BN_GF2m_mod_sqr_arr function to perform the actual modular squaring operation, and the result is returned as an integer."
openssl-101f,O3,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_sqrt@081e1c00.c,"The function BN_GF2m_mod_sqrt computes the square root of a binary polynomial in GF(2^m) field. It takes four parameters: a BIGNUM pointer param_1 to store the result, an integer param_2 representing the irreducible polynomial for the GF(2^m) field, a BIGNUM pointer param_3 representing the binary polynomial to compute the square root of, and a BN_CTX pointer param_4 for temporary storage. The function first calculates the number of bits in the binary polynomial and allocates memory for an array of integers to store the positions of the set bits in the binary polynomial. It then loops through the binary polynomial to find the positions of the set bits and stores them in the array. If the binary polynomial is zero, the function returns 1 with the result set to zero. If the binary polynomial is non-zero, the function checks if the first bit is set and computes the square root using BN_GF2m_mod_exp_arr function."
openssl-101f,O3,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_GF2m_mod_sqr_arr@081dfcf0.c,"The function BN_GF2m_mod_sqr_arr efficiently performs the squaring operation on a binary polynomial array using a precomputed table of values, and stores the result in a BIGNUM structure. It returns a boolean indicating success, and uses a BN_CTX structure for memory management."
openssl-101f,O3,x86,BN_kronecker,./data/decomp/openssl-101f_x86_gcc_O3_extraction/BN_kronecker@081dec60.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs a and b using the binary algorithm. It first initializes two BIGNUMs a_00 and a_01 using the BN_CTX_get function. It then copies the value of a to a_00 and b to a_01 using the BN_copy function. If either a_01 or the copy of a_00 fails to initialize, the function returns -2. Otherwise, it checks if either a_00 or a_01 is equal to zero. If a_01 is zero, it returns 0. If a_00 is equal to 1, it returns 1 if a_00 is odd, and -1 if a_00 is even. If both a_00 and a_01 are not equal to zero, the function performs the binary algorithm to compute the Kronecker symbol. It first finds the highest bit set in a_01 and shifts a_."
openssl-101f,O3,x86,by_dir_entry_free,./data/decomp/openssl-101f_x86_gcc_O3_extraction/by_dir_entry_free@08168760.c,"The function takes a double pointer as input, which is expected to point to a structure containing information about a directory entry. If the first level pointer is not null, it frees the memory pointed to by it using the CRYPTO_free function. If the third element of the structure (which is expected to be a pointer to a stack) is not null, it frees the stack using the sk_pop_free function, which also takes a second argument, a function to free each element of the stack. In this case, the function passed is by_dir_hash_free. Finally, it frees the memory allocated for the structure itself using CRYPTO_free."
openssl-101f,O3,x86,cswift_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O3_extraction/cswift_rand_bytes@081a0320.c,"The function `cswift_rand_bytes` uses CryptoSwift to generate random bytes. It takes in a pointer to an array of `uint` type and the number of bytes to be generated. It acquires an access context and generates random bytes in chunks of 1024 bytes or less using `CSwift_SimpleRequest`. The generated bytes are copied to the output buffer. If an error occurs, the function handles it."
openssl-101f,O3,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_x86_gcc_O3_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9cf0.c,"This function is a C language implementation of a decoder for the GOST_CLIENT_KEY_EXCHANGE_PARAMS structure, which is an ASN.1 encoded data structure used in the GOST cryptographic algorithm. It takes three arguments: a pointer to an ASN1_VALUE structure that will hold the decoded data, a pointer to a buffer containing the ASN.1 encoded data, and the length of the ASN.1 encoded data. The function internally calls the ASN1_item_d2i() function to decode the ASN.1 data and store it in the ASN1_VALUE structure pointed to by the first argument. The ASN1_ITEM pointer passed to the ASN1_item_d2i() function is a pointer to the ASN.1 item definition for the GOST_CLIENT_KEY_EXCHANGE_PARAMS structure. The function does not return a value, but simply returns control to the calling function after the decoding operation is complete."
openssl-101f,O3,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_x86_gcc_O3_extraction/d2i_GOST_KEY_PARAMS@081d9bf0.c,"The function takes in a pointer to an ASN1_VALUE, a pointer to a uchar array, and a long integer. It calls the ASN1_item_d2i function with these parameters and a pointer to an ASN1_ITEM structure for GOST_KEY_PARAMS to decode the uchar array and populate the ASN1_VALUE structure. The function then returns without any explicit value."
openssl-101f,O3,x86,decode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O3_extraction/decode_gost_algor_params@081d78c0.c,"The function extracts algorithm parameters from a X509_ALGOR object and checks if the algorithm is GOST. If it is, it decodes the GOST algorithm parameters and sets the type of the EVP_PKEY object to the corresponding GOST algorithm type. If the algorithm is EC key, it creates a new EC_KEY object and fills it with the decoded GOST2001 parameters. If the algorithm is DSA key, it creates a new DSA object and fills it with the decoded GOST94 parameters. The function returns true if the decoding and parameter filling is successful, otherwise it returns false and sets an error message."
openssl-101f,O3,x86,DES_xcbc_encrypt,./data/decomp/openssl-101f_x86_gcc_O3_extraction/DES_xcbc_encrypt@081ddf90.c,"The two function summaries describe encryption and decryption using the DES algorithm. They both take in input data and an initialization vector, and process the data in 8-byte blocks. The first function also takes in a key schedule and two constants, and performs encryption or decryption based on the enc parameter. It pads the last block with zeros if necessary. The second function takes in a key and outputs the encrypted result. It XORs each block with the previous block or the IV, and handles remaining bytes with a special case."
openssl-101f,O3,x86,dgram_ctrl,./data/decomp/openssl-101f_x86_gcc_O3_extraction/dgram_ctrl@08120f10.c,"The functions take four parameters and switch based on the value of the second parameter. If the second parameter is 8 or 9, the function sets or retrieves the value stored at a specific memory address. If the second parameter is 0xb, 0xc, 0x1f, or 0x2c, the function jumps to a labeled section of code. If the second parameter is 0x67, the function checks the first two bytes of the memory pointed to by the first parameter and sets the third parameter based on the result. If the second parameter is 0x68 and the integer value at a specific memory address is not 0, the function shuts down the connection, closes the socket, and sets specific values at other memory addresses."
openssl-101f,O3,x86,dlfcn_bind_func,./data/decomp/openssl-101f_x86_gcc_O3_extraction/dlfcn_bind_func@081e4350.c,"The function takes in two integer parameters, param_1 and param_2. If either parameter is equal to 0, the function sets the line variable to 0x110 and returns 0x43. Otherwise, it checks the number of items in the stack pointed to by the value at the memory address param_1 + 4. If the number of items is less than 1, the function sets the line variable to 0x115 and returns 0x69. Otherwise, it retrieves the last item from the stack and uses the dlsym function to look up the symbol specified by the value at param_2. If the lookup is successful, the function returns the result of the lookup. If the lookup fails, the function sets an error message using the ERR_put_error and ERR_add_error_data functions and returns 0."
openssl-101f,O3,x86,dlfcn_bind_var,./data/decomp/openssl-101f_x86_gcc_O3_extraction/dlfcn_bind_var@081e4450.c,"The function takes two integer parameters, param_1 and param_2. If either parameter is 0, the function sets the variable ""line"" to 0xee and returns 0x43. Otherwise, the function checks the number of items in a stack pointed to by a pointer stored in param_1 + 4. If the number of items is less than 1, the function sets ""line"" to 0xf3 and returns 0x69. Otherwise, the function retrieves the last item from the stack, and attempts to find a symbol with the name stored in param_2 within the library pointed to by the retrieved item. If the symbol is found, the function returns its address. If the symbol is not found, the function sets an error message and returns 0. If the retrieved item is null, the function sets ""line"" to 0xf9 and returns 0x68. Finally, if any error occurs, the function sets an error message."
openssl-101f,O3,x86,dlfcn_globallookup,./data/decomp/openssl-101f_x86_gcc_O3_extraction/dlfcn_globallookup@081e4070.c,"The function uses the dlfcn library to dynamically load a shared library and look up a symbol by name. It takes in a parameter, which is the name of the symbol to look up. The process involves calling dlopen with a null pointer and the flag 1 to open the executable file itself. If dlopen returns 0, indicating an error, the function returns 0. Otherwise, it calls dlsym with the handle returned by dlopen and the symbol name passed in as the parameter. If dlsym is successful, it returns a pointer to the symbol. Finally, the function calls dlclose to close the handle returned by dlopen. The function then returns the pointer to the symbol if it was found, or 0 if there was an error."
openssl-101f,O3,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_mont_field_encode@081e2870.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It retrieves a BN_MONT_CTX pointer from the integer parameter. If the pointer is not null, it uses the BN_mod_mul_montgomery function to encode the second BIGNUM parameter using the third BIGNUM parameter and the BN_MONT_CTX pointer. It returns the result of the BN_mod_mul_montgomery function. If the BN_MONT_CTX pointer is null, it logs an error using the ERR_put_error function and returns 0."
openssl-101f,O3,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_mont_field_sqr@081e2810.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The first parameter is likely a reference to some sort of elliptic curve context. The function checks if a BN_MONT_CTX pointer located at an offset of 0xa0 from the elliptic curve context is not null. If it is not null, it uses the BN_mod_mul_montgomery function to compute the square of the second BIGNUM parameter (param_3) modulo the modulus stored in the BN_MONT_CTX structure, and stores the result in the first BIGNUM parameter (param_2). If the BN_MONT_CTX pointer is null, the function generates an error message using the ERR_put_error function and returns 0."
openssl-101f,O3,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_mont_group_init@081e2420.c,The `ec_GFp_mont_group_init` function initializes a Montgomery elliptic curve group by calling `ec_GFp_simple_group_init` to initialize the underlying simple elliptic curve group. It sets two variables in the Montgomery curve structure to zero and returns. These variables are likely used in the Montgomery multiplication algorithm for efficient scalar multiplication on the curve.
openssl-101f,O3,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_nist_field_mul@081e2ba0.c,"The function is a multiplication operation on the elliptic curve over a finite field of prime order. It takes four parameters: an integer representing the elliptic curve parameter, and three BIGNUM variables representing the operands for the multiplication operation. The function also takes a BN_CTX variable for temporary storage during the operation. It first checks if all input parameters are valid, throwing an error if any are invalid using the ERR_put_error function. If the input parameters are valid, it checks if a BN_CTX variable is provided. If not, it creates a new one using the BN_CTX_new function. It then performs the multiplication operation using the BN_mul function, storing the result in the first BIGNUM variable. It then performs a modular reduction operation using a function pointer stored in the elliptic curve parameter, and stores the result back in the first BIGNUM variable. If a BN_CTX variable is provided, the function..."
openssl-101f,O3,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_nist_group_copy@081e29a0.c,"The function `ec_GFp_nist_group_copy` copies the `field` member from the second `EC_GROUP` structure to the first `EC_GROUP` structure and then likely calls `ec_GFp_simple_group_copy` to copy the remaining fields. It takes in two parameters, `param_1` and `param_2`, which are pointers to two `EC_GROUP` structures, and returns nothing."
openssl-101f,O3,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_nist_group_set_curve@081e29c0.c,"The function `ec_GFp_nist_group_set_curve` sets the elliptic curve parameters for a group using the given prime modulus `param_2`, curve coefficients `param_3` and `param_4`, and a `BN_CTX` context object `param_5`. If `param_5` is `NULL`, a new `BN_CTX` object is created and its memory is allocated using `BN_CTX_start`. If memory allocation fails, the function returns 0. The function then compares `param_2` with pre-defined NIST primes of various sizes. If `param_2` matches one of the NIST primes, the corresponding NIST modulus function is set as the modulus function for the elliptic curve group, and `ec_GFp_simple_group_set_curve` is called to set the curve parameters and return 1. If `param_2` does not match any of the NIST primes, the function returns 0 and an error message is generated."
openssl-101f,O3,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e74d0.c,"The function takes in pointers to integers and BIGNUMs, as well as a BN_CTX pointer, and returns a boolean value. It checks if a certain integer value in the parameter array is equal to zero. If it is, it copies values from the corresponding memory locations in the parameter array into certain BIGNUMs. If the integer value is not zero, the function creates a new BN_CTX if one is not already provided. It then computes values for certain BIGNUMs using a function pointer from the parameter array and the provided BN_CTX. If the param_5 BIGNUM is not NULL, it also computes its value."
openssl-101f,O3,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_group_check_discriminant@081e76a0.c,"The function checks if the discriminant of a given elliptic curve group over a prime field is non-zero. It takes an array of integers representing the elliptic curve group parameters and a BN_CTX object for temporary storage of BIGNUMs. It initializes several BIGNUM objects using BN_CTX_get(). If the elliptic curve group parameters have a custom discriminant calculation function, the function calls that function to calculate the two components of the discriminant. Otherwise, the function calculates the discriminant using the standard formula: 4*a^3 + 27*a_00^2. It first checks that both a and a_00 are non-zero, then calculates two intermediate values (r and r_')."
openssl-101f,O3,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_group_clear_finish@081e7130.c,"The function clears/free three BIGNUM variables used in elliptic curve cryptography over a finite field (GFp), stored at specific offsets from an integer parameter (param_1). It does not return anything."
openssl-101f,O3,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_group_copy@081e8280.c,"`ec_GFp_simple_group_copy` takes two pointers to `EC_GROUP` structures as parameters. The function copies the values of certain `BIGNUM` and `order_top` fields from the second `EC_GROUP` structure to the corresponding fields in the first `EC_GROUP` structure. It returns 1 if all copy operations were successful, and 0 otherwise."
openssl-101f,O3,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_group_get_degree@081e71a0.c,"The function takes an integer parameter, likely a pointer to an elliptic curve group data structure, retrieves the group order from an offset of 0x48 within the structure, calculates the bit length of the order using the OpenSSL library's BN_num_bits function, and returns without output."
openssl-101f,O3,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_group_set_curve@081e8370.c,"The function `ec_GFp_simple_group_set_curve` sets the curve parameters for an elliptic curve over a finite field. It takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`, which are pointers to integers and BIGNUMs (arbitrary precision integers) that represent the curve parameters. It also takes a BN_CTX pointer `param_5` which is used for temporary storage during the computation. The function first checks if the number of bits in `param_2` (which represents the prime modulus of the finite field) is at least 3 and if it is odd. If not, it reports an error and returns 0. If `param_5` is null, the function creates a new BN_CTX object and starts it, and then creates a new BIGNUM `r` using `BN_CTX_get`. If `param_5` is not null, it starts the existing BN_CTX object."
openssl-101f,O3,x86,ec_GFp_simple_invert,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_invert@081e90a0.c,"The function checks if an EC_POINT object is at infinity or has a y-coordinate of zero. If neither condition is met, it computes the inverse of the point using BN_usub. It returns 1 if the point is at infinity or has a y-coordinate of zero."
openssl-101f,O3,x86,EC_GFp_simple_method,./data/decomp/openssl-101f_x86_gcc_O3_extraction/EC_GFp_simple_method@081e9c60.c,"The function returns a pointer to an EC_METHOD structure containing function pointers for elliptic curve cryptography operations. The specific EC_METHOD returned is ""EC_GFp_simple_method,"" likely a basic implementation over a finite field. No input parameters are provided, and the calling convention is unknown."
openssl-101f,O3,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_point_copy@081e8300.c,"The function copies the contents of one EC_GFp_simple point to another using the OpenSSL library's BN_copy function. It takes two parameters: the destination point and the source point. If any of the copy operations fail, the function returns 0 to indicate failure. If all of the copy operations succeed, the function sets the destination point's flags field to the same value as the source point's flags field and returns 1 to indicate success."
openssl-101f,O3,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_point_finish@081e7100.c,"The function takes an integer parameter assumed to be a pointer to a structure representing an elliptic curve point in GF(p) and frees the memory allocated to three BIGNUM objects within the structure representing the point (corresponding to the x-coordinate, y-coordinate, and z-coordinate of the point in projective coordinates). It does not return anything."
openssl-101f,O3,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7910.c,"The function takes an integer pointer, an EC_POINT pointer, and three BIGNUM pointers as output parameters. It checks if the EC_POINT is at infinity and initializes a BN_CTX object if not already provided. If the EC_GROUP does not have a point multiplication function, it computes the inverse of the x-coordinate modulo the order of the EC_GROUP and computes the y-coordinate from the x-coordinate using the EC_GROUP's equation."
openssl-101f,O3,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_x86_gcc_O3_extraction/ec_GFp_simple_point_set_affine_coordinates@081e85e0.c,"The function takes an EC_GROUP object, an EC_POINT object, two BIGNUM objects representing affine coordinates, and a BN_CTX object. If both affine coordinates are not NULL, the function sets the J-projective coordinates of the EC_POINT object to the given affine coordinates and returns the result. If either affine coordinate is NULL, the function generates an error and returns 0."
openssl-101f,O3,x86,encode_gost_algor_params,./data/decomp/openssl-101f_x86_gcc_O3_extraction/encode_gost_algor_params@081d8ab0.c,"The function encodes GOST algorithm parameters into an ASN1_STRING structure. It takes an EVP_PKEY structure as input and returns the encoded parameters as an ASN1_STRING. The function first creates a new ASN1_STRING structure and a GOST_KEY_PARAMS structure. If either of these structures cannot be created, the function returns an error. Next, the function determines the type of algorithm parameters based on the EVP_PKEY's base ID. If the ID is for an elliptic curve key, it retrieves the curve name. If the ID is for a GOST R 34.10-2001 key, it retrieves the key parameters. The function then sets the GOST_KEY_PARAMS structure with the appropriate algorithm parameters and encodes it into the ASN1_STRING structure. If the encoding is successful, the function returns the ASN1_STRING. If not, it returns an error. Finally, the function frees the GOST_KEY_PARAMS structure and returns the encoded ASN1_STRING."
openssl-101f,O3,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_x86_gcc_O3_extraction/general_allocate_boolean.constprop.5@081896c0.c,"The function general_allocate_boolean_constprop_5 takes in several parameters, including two character pointers param_1 and param_2, an integer param_3, and several other integer parameters. It checks if param_1 is NULL, and if so, returns an error code. If param_1 is not NULL, the function checks if param_2 is also not NULL. If param_2 is not NULL, the function loops through each character in param_1 and checks if it is present in param_2. If a character in param_1 is found in param_2, the function logs an error and continues looping. If all characters in param_1 are checked and none are found in param_2, the function checks if param_2_00 is equal to 0. If it is, the function returns an error code. If param_2_00 is not equal to 0, the function allocates memory for an integer array of size 8."
openssl-101f,O3,x86,get_gost_engine_param,./data/decomp/openssl-101f_x86_gcc_O3_extraction/get_gost_engine_param@081db3b0.c,"The function takes an integer parameter called ""param_1"". If the parameter is not equal to 0, the function returns a null pointer. If the global variable ""gost_params"" is null, the function attempts to retrieve the value of the ""CRYPT_PARAMS"" environment variable using getenv(). If the environment variable is not set, the function returns a null pointer. Otherwise, the function allocates memory for ""gost_params"" using BUF_strdup(), sets its value to the value of the ""CRYPT_PARAMS"" environment variable, and returns a pointer to it."
openssl-101f,O3,x86,gost2001_param_encode,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost2001_param_encode@081d7de0.c,"This function extracts an EC_KEY object from an EVP_PKEY object and retrieves the associated EC_GROUP object. It then converts the curve name of the EC_GROUP object into an ASN1_OBJECT, encodes it into binary format, and stores it in a pointer to a uchar pointer."
openssl-101f,O3,x86,gost_cipher_cleanup,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost_cipher_cleanup@081d9f50.c,The function cleans up resources used by the GOST cipher by destroying the cipher context using `gost_destroy` function and setting a value to 0. It returns 1 to indicate successful cleanup.
openssl-101f,O3,x86,gost_cipher_ctl,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost_cipher_ctl@081da4a0.c,"The `gost_cipher_ctl` function takes four parameters (`param_1`, `param_2`, `param_3`, and `param_4`). 

If `param_2` is 6, it generates random bytes using the `RAND_bytes` function and stores them in the memory pointed to by `param_4`. If successful, it returns 1. If not, it reports an error using the `ERR_GOST_error` function and returns -1.

If `param_2` is 7, it checks if `param_4` is not NULL. If not NULL, it sets the value at the memory location pointed to by `param_4` to 0x32a and returns 1. Otherwise, it returns 0.

If `param_2` is neither 6 nor 7, it reports an error using the `ERR_GOST_error` function."
openssl-101f,O3,x86,gost_cipher_do_cnt,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost_cipher_do_cnt@081da0c0.c,"The function `gost_cipher_do_cnt` takes four parameters: an integer `param_1`, two pointers to byte arrays `param_2` and `param_3`, and an unsigned integer `param_4`. It returns an undefined value. The function first checks the value at the address `param_1 + 0x50`. If it is zero, it sets `local_20` to 8 and `uVar4` to 0. Otherwise, it sets `uVar4` to 0 and loops through the first 8 bytes of `param_2`, XORing each byte with the corresponding byte in `param_3` and storing the result in `param_2`. If `param_4` is not 0 and the loop completes before 8 bytes are XORed, the function jumps to `LAB_081da118`. If `uVar2` (which is either 8 or the number of bytes XORed in the previous loop) is less than 8, the function jumps to `LAB_081da118`."
openssl-101f,O3,x86,gost_cipher_init,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost_cipher_init@081db0d0.c,"The `gost_cipher_init` function initializes the GOST cipher context with specified parameters. It retrieves the GOST engine parameter and uses it to find the corresponding cipher in the `gost_cipher_list` if the `app_data` field of the context is null. If `param_2` is not zero, the function calls `gost_key` to set the cipher key. If `param_3` is not null, the function copies the initialization vector to the context's `oiv` field and then copies it to the `iv` field. The function returns 1 to indicate success."
openssl-101f,O3,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O3_extraction/GOST_CIPHER_PARAMS_new@081d9cb0.c,"The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function, which is defined in the ASN.1 notation for encoding and decoding standardized data structures. It returns void."
openssl-101f,O3,x86,gost_imit_final,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost_imit_final@081dad70.c,"The function takes an integer and an undefined value as parameters. It retrieves integers from the input integer and checks for zero values. If there are no zeros, it calls another function with local variables. If there are zeros, it skips certain steps. Finally, it calls another function with part of the input integer."
openssl-101f,O3,x86,gost_imit_init_cpa,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost_imit_init_cpa@081da430.c,The function initializes the GOST imitation cipher with the CryptoProParamSetA parameter set using an integer parameter. It sets specific memory locations to 0 and 1 before calling the gost_init function with the parameter set and integer parameter. The function then returns 1.
openssl-101f,O3,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_x86_gcc_O3_extraction/GOST_KEY_PARAMS_new@081d9c30.c,The function creates a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new function. It is used for specifying parameters for GOST key generation and encryption. The function does not take any arguments and simply returns after creating the new instance.
openssl-101f,O3,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_x86_gcc_O3_extraction/GOST_KEY_TRANSPORT_free@081d9ad0.c,The function frees memory allocated to an ASN1_VALUE pointer using the ASN1_item_free function. It also takes a pointer to the ASN1_ITEM structure for the GOST_KEY_TRANSPORT data type as its second parameter and returns without any value.
openssl-101f,O3,x86,gost_param_free,./data/decomp/openssl-101f_x86_gcc_O3_extraction/gost_param_free@081db310.c,"The function frees the memory allocated to the GOST parameters if the global variable ""gost_params"" is not null."
openssl-101f,O3,x86,hash_step,./data/decomp/openssl-101f_x86_gcc_O3_extraction/hash_step@081db480.c,"The functions all involve initializing local variables and performing bitwise operations on input parameters. One function calls the `gost_enc_with_key` function twice, while another involves iterating through arrays and assigning elements to local arrays based on a comparison. The purpose of these functions is unclear without additional context."
openssl-101f,O3,x86,hwcrhk_init,./data/decomp/openssl-101f_x86_gcc_O3_extraction/hwcrhk_init@081a2c00.c,"The function initializes the hardware crypto hook library by loading the library and binding its functions, sets up mutex callbacks if they are not disabled, and creates a new RSA key handle index. It returns 1 if initialization is successful and sets an error code and returns 0 if initialization fails. Finally, it frees the library and clears all function pointers."
openssl-101f,O3,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_x86_gcc_O3_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9b90.c,"The function encodes an ASN1_VALUE structure into a byte array using the ASN1_item_i2d function and stores it in a uchar array. It takes in two parameters, a pointer to the ASN1_VALUE structure and a pointer to a pointer to a uchar array. The function returns without any value."
openssl-101f,O3,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_x86_gcc_O3_extraction/i2d_GOST_KEY_TRANSPORT@081d9a90.c,The function encodes an ASN1_VALUE structure into a binary format according to the GOST_KEY_TRANSPORT_it item template. It takes in two parameters: a pointer to the ASN1_VALUE structure and a pointer to a pointer to an unsigned char buffer. The encoded binary data is stored in the buffer. The function returns without any value.
openssl-101f,O3,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101f_x86_gcc_O3_extraction/load_pkcs12.constprop.4@08079a50.c,"The function takes in several parameters, including two BIO objects, a string, a function pointer, and two pointers to EVP_PKEY and X509 structures. It loads a PKCS12 file using the d2i_PKCS12_bio function and checks if it was loaded successfully. If the PKCS12 file was loaded successfully, it verifies the MAC using the empty string as the password. If that fails, it tries to use a password callback function (if provided) to get the password from the user. It then verifies the MAC using the obtained password and if that fails too, it prints an error message and returns 0. If the MAC is verified successfully, it parses the PKCS12 file using the password and fills in the EVP_PKEY and X509 structures. It then frees the PKCS12 object and returns 1 if successful. If there was an error during the process, it prints an error message."
openssl-101f,O3,x86,padlock_init,./data/decomp/openssl-101f_x86_gcc_O3_extraction/padlock_init@081a9ad0.c,"The ""padlock_init"" function checks if either ""padlock_use_rng"" or ""padlock_use_ace"" is not equal to zero. If either is not equal to zero, the function returns true to indicate successful initialization. If both are equal to zero, the function returns false to indicate initialization failure."
openssl-101f,O3,x86,padlock_rand_bytes,./data/decomp/openssl-101f_x86_gcc_O3_extraction/padlock_rand_bytes@081a8be0.c,"The function `padlock_rand_bytes` generates random bytes to fill a buffer. If the length is less than 8, it generates random bytes one at a time using a loop. If the length is greater than or equal to 8, it generates random bytes in blocks of 8. It checks if the xstore (a hardware random number generator) is available and if it is, it generates random bytes and stores them in the buffer. If the xstore is not available or if the generated bytes are not valid, the function falls back to generating bytes one at a time using the loop described above."
openssl-101f,O3,x86,param_copy_gost94,./data/decomp/openssl-101f_x86_gcc_O3_extraction/param_copy_gost94@081d8120.c,"The function takes two EVP_PKEY pointers (param_1 and param_2) as input and returns a void pointer. It declares variables such as two BIGNUM pointers, a void pointer, a DSA pointer, and two integers. The function retrieves the DSA pointer from param_1 and the void pointer from param_2. It checks if the base ID of param_2 matches that of param_1. If they match, it checks if the void pointer is null. If it is null, an error is thrown. If it is not null, the function checks if the DSA pointer is null. If it is null, a new DSA object is created and assigned to param_1. The function frees any existing BIGNUM pointers in the DSA object and creates new ones by duplicating the BIGNUM pointers from the void pointer. It then sets some fields in the DSA object and computes the."
openssl-101f,O3,x86,param_print_gost01,./data/decomp/openssl-101f_x86_gcc_O3_extraction/param_print_gost01@081d8540.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer value, and returns an integer value. It extracts the EC_KEY object from the EVP_PKEY object, gets the EC_GROUP object associated with the key, and stores the curve name of the group in the variable 'n'. It then indents the BIO object by 'param_3' spaces, prints the parameter set information to the BIO object using the BIO_printf function, and returns 1 if the BIO_indent function call was successful, otherwise it returns 0. The parameter set information includes the name of the curve associated with the key."
openssl-101f,O3,x86,param_print_gost94,./data/decomp/openssl-101f_x86_gcc_O3_extraction/param_print_gost94@081d85b0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer value. It retrieves the public key from the EVP_PKEY object and creates a new BIGNUM object. It then checks if the R3410_paramset._12_4_ field is not null. If it is not null, it loops through the R3410_paramset array and compares each element with the BIGNUM object created earlier. If a match is found, the function sets the iVar2 variable to the value of the corresponding element in the R3410_paramset array and jumps to the LAB_081d864a label. If no match is found, the iVar2 variable is set to 0, and the function continues to the LAB_081d864a label. At the LAB_081d864a label, the function indents the output BIO object by the value of the third parameter and prints the parameter."
openssl-101f,O3,x86,pkey_ctrl_gost,./data/decomp/openssl-101f_x86_gcc_O3_extraction/pkey_ctrl_gost@081d8ea0.c,"The function `pkey_ctrl_gost` takes four parameters: `param_1` of type `EVP_PKEY*`, `param_2` of type `int`, `param_3` of type `int`, and `param_4` of type `PKCS7_SIGNER_INFO*`. The function initializes a local variable `local_20` to store the value of the stack canary. It then switches on the value of `param_2`. If `param_2` is not one of the expected values, the function sets the return value to `0xfffffffe` and jumps to `LAB_081d8ee8`. Otherwise, the function performs specific actions for each value of `param_2`."
openssl-101f,O3,x86,pkey_free_gost94,./data/decomp/openssl-101f_x86_gcc_O3_extraction/pkey_free_gost94@081d8520.c,"The function takes an integer parameter called ""param_1"". It checks if the value stored at the memory location (param_1 + 0x14) is not equal to NULL. If it is not NULL, it frees the memory allocated to the DSA structure pointed to by the value stored at (param_1 + 0x14) using the DSA_free() function. If the value stored at (param_1 + 0x14) is NULL, the function returns without doing anything."
openssl-101f,O3,x86,priv_encode_gost,./data/decomp/openssl-101f_x86_gcc_O3_extraction/priv_encode_gost@081d91d0.c,"The function takes in two parameters: a PKCS8_PRIV_KEY_INFO structure pointer and an EVP_PKEY structure pointer. It returns an integer value. The function first gets the base ID of the EVP_PKEY using EVP_PKEY_base_id() function and converts it to an ASN1_OBJECT using OBJ_nid2obj() function. It then calls the encode_gost_algor_params() function to get the parameters of the GOST algorithm. If the EVP_PKEY is of type EC_KEY, it gets the private key using EC_KEY_get0_private_key() function. Otherwise, if it is of type BIGNUM, it gets the private key using EVP_PKEY_get0() function. It then converts the private key to an ASN1_INTEGER using BN_to_ASN1_INTEGER() function and encodes it using i2d_ASN1_INTEGER() function. Finally, it sets the PKCS8_PRIV_KEY_INFO structure using PKCS8_pkey_set0() function with the ASN."
openssl-101f,O3,x86,pub_encode_gost94,./data/decomp/openssl-101f_x86_gcc_O3_extraction/pub_encode_gost94@081d9080.c,"The function encodes a GOST 94 public key and sets it in an X509_PUBKEY structure. It takes two parameters, a pointer to the X509_PUBKEY structure and a pointer to the EVP_PKEY structure containing the public key. First, it gets the object identifier (OID) of the public key algorithm and checks if the parameters need to be saved. If so, it calls the encode_gost_algor_params function to encode the algorithm parameters and sets the local variable local_38 to 0x10. Next, it converts the public key into a byte array and creates an ASN1_OCTET_STRING object to hold it. The byte array is reversed and copied into the ASN1_OCTET_STRING. The length of the ASN1_OCTET_STRING is then calculated and it is encoded using i2d_ASN1_OCTET_STRING function. The resulting byte array is stored in the local variable local_24. Finally, the function sets the encoded public key in the X509_PUBKEY structure."
openssl-101f,O3,x86,pub_print_gost94,./data/decomp/openssl-101f_x86_gcc_O3_extraction/pub_print_gost94@081d86a0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It retrieves the public key from the EVP_PKEY object and prints it to the BIO object using BN_print. It checks the parameter set used for the key by comparing it to a list of predefined parameter sets in the R3410_paramset struct. If a match is found, it retrieves the corresponding NID and prints it to the BIO object using OBJ_nid2ln. The function returns 1."
openssl-101f,O3,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O3_extraction/RSA_padding_add_PKCS1_PSS@081e36a0.c,"The first function, RSA_padding_add_PKCS1_PSS, adds padding to a message using the PKCS1 PSS standard. It takes in the RSA key, a message hash, the hash function used, and the length of the salt. The function calculates the size of the hash and checks the validity of the salt length. It generates a random salt if the salt length is -2, sets the salt length to be equal to the size of the hash if it is -1, and uses the given salt length if it is greater than or equal to zero. If the RSA key has a certain bit pattern, an extra byte is added to the padding. The function then generates a mask using PKCS1_MGF1, XORs the mask with the padding, sets the appropriate padding bytes, and returns 1 if successful.

The second function, named ""some_function"", takes no arguments. Within the function, it defines a list variable named ""lst"" and initializes it with the values 1, 2, 3, and 4. It then defines a variable named ""total"" and initializes it to 0. It then iterates over each element in the list using a for loop and adds each element to the ""total"" variable. Finally, it returns the value of ""total""."
openssl-101f,O3,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_x86_gcc_O3_extraction/RSA_verify_PKCS1_PSS@081e2d80.c,"The function RSA_verify_PKCS1_PSS verifies a signature using the RSA-PSS algorithm. It initializes an EVP_MD_CTX structure, checks the signature length and extracts padding bits. It extracts masked data from the signature with PKCS1_MGF1, XORs it with the hash of the message to obtain the original data, checks padding, computes the hash of the original data, and returns 1 if the computed hash matches the hash in the signature."
openssl-101f,O3,x86,sha_block_data_order,./data/decomp/openssl-101f_x86_gcc_O3_extraction/sha_block_data_order@081dcb10.c,"The following functions all implement the SHA-1 hashing algorithm to produce a fixed-size output of 160 bits from an input message. They operate on the message in 512-bit blocks, using a series of logical and arithmetic operations, including rotations, bitwise operations, and additions, to transform the input message into an intermediate hash value. The intermediate hash value is then combined with the previous hash value (or a fixed initial value for the first block) to produce the final hash value. The functions use a number of constants and functions specific to the SHA-1 algorithm, such as bitwise rotations and the SHA-1 message expansion function.

1. The function takes in an array of 16 32-bit integers and an array of 5 32-bit integers and processes the input block in 80 rounds, each round processing 5 32-bit integers. In each round, the function performs various bitwise operations and additions on the 5 input integers and updates the 5 local integers. It also updates the values in the second array after every 20 rounds. Finally, after all 80 rounds are completed, the function returns the updated values in the second array as the output hash.

2. The function takes in a message as input and produces a 160-bit hash value as output. It operates on 512-bit blocks of the input message at a time, using a series of logical and arithmetic operations to transform the input block into an intermediate hash value. This intermediate hash value is then combined with the previous hash value (or a fixed initial value for the first block) to produce the final hash value. The function uses a number of constants and functions specific to the SHA-1 algorithm, such as bitwise rotations and the SHA-1 message expansion function.

3. The function takes in a message as input and produces a fixed-size output of 160 bits. The input message is split into blocks of 512 bits each, and each block is processed using a series of logical and arithmetic operations. The function initializes a set of constants and variables, including the initial hash values for the SHA-1 algorithm. It then processes each block of the input message using a loop. Within the loop, the block is divided into 16 words of 32 bits each, which are then expanded into 80 words using a series of logical operations. The expanded words are then processed using a series of logical and arithmetic operations, including bitwise shifts, rotations, and XOR operations. The result of each operation is stored"
openssl-101f,O3,x86,SHA_Final,./data/decomp/openssl-101f_x86_gcc_O3_extraction/SHA_Final@081ddde0.c,"The SHA_Final function is the final step in the SHA-1 hashing algorithm. It takes in a message digest buffer (md) and a SHA context (c) and computes the final SHA-1 hash value. The function appends a single 1 bit to the message, followed by enough 0 bits to pad the message to a multiple of 512 bits (64 bytes). If the message is already a multiple of 64 bytes, it appends an additional 64 bytes of 0 bits. Next, the function processes each 64-byte block of the message using the sha_block_data_order() function, which performs a series of bitwise operations on the block and updates the SHA context with the result. After processing all the blocks, the function sets the first 16 bytes of the last block to the high and low bits."
openssl-101f,O3,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_x86_gcc_O3_extraction/SSL_SESSION_free.part.2@080c59a0.c,"`SSL_SESSION_free_part_2` is a cleanup function that frees memory allocated for an SSL session. It first frees any additional data associated with the SSL session using `CRYPTO_free_ex_data`. It then overwrites memory areas containing sensitive information with `OPENSSL_cleanse`. It frees memory allocated for the session certificate, X509 certificate, and any stack of certificates, as well as session keys and other session-related data. Finally, it overwrites the entire memory block containing the SSL session data with `OPENSSL_cleanse` and frees the memory using `CRYPTO_free`, ensuring that all memory is properly freed and sensitive information is securely erased."
openssl-101f,O3,x86,start_hash,./data/decomp/openssl-101f_x86_gcc_O3_extraction/start_hash@081dc420.c,"The function takes a pointer to an array of 4-byte integers as its parameter. It checks if the third element of the array is not equal to zero. If it is not zero, the function initializes various elements of the array to zero. Specifically, it sets the fifth element of the array and all subsequent 4-byte integers to zero until the end of the array (rounded up to the nearest multiple of 4). It also sets the thirteenth element of the array and all subsequent 4-byte integers to zero until the end of the array (rounded up to the nearest multiple of 4). Finally, it sets the first, second, and fourth elements of the array to zero. If the third element of the array is equal to zero, the function simply returns zero. Otherwise, it returns one."
openssl-101f,O3,x86,surewarehk_finish,./data/decomp/openssl-101f_x86_gcc_O3_extraction/surewarehk_finish@081a4ef0.c,"The function checks if the surewarehk_dso variable is null and sets the SUREWARE_lib_error_code to the next error code in the library if it is. If surewarehk_dso is not null, it calls the surewarehk_Finish function through a function pointer. It then frees the surewarehk_dso variable and sets SUREWARE_lib_error_code to the next error code in the library if it is null. If there was an error freeing the surewarehk_dso variable, it sets the SUREWARE_lib_error_code to the next error code in the library and returns an error code. The function also frees the logstream variable if it is not null, sets all function pointers to null, and returns either 0 or 1 depending on whether there was an error freeing the surewarehk_dso variable."
openssl-101f,O3,x86,sv_body,./data/decomp/openssl-101f_x86_gcc_O3_extraction/sv_body@08067fe0.c,"The function `sv_body` handles the SSL connection between the server and the client. It takes three parameters: `param_1`, which is an undefined value, `param_2`, which is the file descriptor for the socket, and `param_3`, which is a pointer to the session ID context. It allocates a buffer of size 0x4000 using `CRYPTO_malloc`, creates a new SSL object, sets I/O for the SSL object, and sets a non-blocking I/O test. It also accepts a socket connection, initializes SSL context and SSL connection, and then enters into a loop that reads data from the socket and writes it back after processing it. The loop continues until the socket is closed or an error occurs. The function also handles some special commands that can be sent to the server, such as printing statistics and renegotiating the SSL connection. These commands are identified by a single character sent as the first byte of the command. If an error occurs during the process, the function handles it."
openssl-101f,O3,x86,__libc_csu_init,./data/decomp/openssl-101f_x86_gcc_O3_extraction/__libc_csu_init@081e9f00.c,"The function __libc_csu_init initializes the C runtime environment for the program by calling _init() for initialization, iterating through an array of function pointers called __frame_dummy_init_array_entry and calling each function with the parameters param_1, param_2, and param_3, and then returning."
openssl-101f,O3,x86,__udivdi3,./data/decomp/openssl-101f_x86_gcc_O3_extraction/__udivdi3@081e9c70.c,"The function performs unsigned integer division of two concatenated 64-bit values (formed by the first two parameters) by a concatenated 32-bit value (formed by the last two parameters). If the last parameter is zero, it checks if the second parameter is less than the third parameter and returns the quotient or quotient and remainder (as a 32-bit integer and 32-bit unsigned integer in the upper 32 bits of the returned 64-bit integer) accordingly. If the last parameter is not zero, the function calculates the number of leading zeros in the last parameter and uses it to shift the last two parameters left."
openssl-101f,O0,mips,aep_mod_exp.part.0,./data/decomp/openssl-101f_mips_gcc_O0_extraction/aep_mod_exp.part.0@005cf33c.c,"These functions all perform modular exponentiation using the AEP cryptographic hardware library. They take in input parameters such as the base, exponent, modulus, and AEP context, and return an unsigned integer or a success/failure status. They also include error handling code to handle any errors that may occur during the operation. The functions attempt to establish a connection with the AEP hardware accelerator and call the AEP_ModExp function to perform the modular exponentiation operation. If the operation is successful, they update a table of active connections and return a success value. If the operation fails, they close the connection and return an error value. Some of the functions also check if the AEP library has been loaded and initialized and attempt to load and initialize the library if necessary."
openssl-101f,O0,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_mips_gcc_O0_extraction/asn1_bio_callback_ctrl@0062aca0.c,"The function is an implementation of the ASN1_bio_callback_ctrl function in the OpenSSL library. It takes an integer parameter and returns an integer value. The function checks if the value at offset 0x24 of the parameter is not equal to zero. If true, the function jumps to an indirect call using the value at the address PTR_BIO_callback_ctrl_006a9548 as a function pointer, and returns the result of this function call. If false, the function returns zero."
openssl-101f,O0,mips,asn1_bio_ctrl,./data/decomp/openssl-101f_mips_gcc_O0_extraction/asn1_bio_ctrl@0062ad94.c,"The function takes four parameters: param_1, param_2, param_3, and param_4. It first dereferences a pointer from the memory address param_1 + 0x20 and stores it in piVar3. If piVar3 is null, the function returns 0. If param_2 is 0x97, the function sets piVar3[10] to the value at param_4[0] and piVar3[0xb] to the value at param_4[1], and returns 1. If param_2 is less than 0x98, the function checks if param_2 is 0x95. If it is, piVar3[8] is set to the value at param_4[0] and piVar3[9] is set to the value at param_4[1], and the function returns 1. If param_2 is greater than 0x, the function does not return anything."
openssl-101f,O0,mips,asn1_bio_free,./data/decomp/openssl-101f_mips_gcc_O0_extraction/asn1_bio_free@0062acc4.c,"The function takes an integer parameter and returns an integer value. It first retrieves the value of an integer variable at an offset of 0x20 from the input parameter. If this value is not 0, it checks if the value of an integer variable at an offset of 4 from it is also not 0. If so, it calls a function pointer to free the memory pointed to by this integer variable. Then, it calls another function pointer to free the memory pointed to by the integer variable at the offset of 0x20 from the input parameter. It then sets three integer variables at offsets of 0xc, 0x20, and 0x14 from the input parameter to 0 and returns 1. If the value of the integer variable at the offset of 0x20 from the input parameter is 0, it returns 0."
openssl-101f,O0,mips,asn1_bio_write.part.1,./data/decomp/openssl-101f_mips_gcc_O0_extraction/asn1_bio_write.part.1@0062b180.c,"The function takes three parameters: an integer, a second integer, and a pointer to a uint. It returns an integer. The function first initializes some variables and checks if the pointer at offset 0x20 of the first parameter is NULL. If it is, the function returns the value of the local variable iVar3. If not, it checks if the second parameter is not zero, the third parameter is greater than -1, and the value at offset 0x24 of the first parameter is not zero. If all these conditions are true, the function calls itself recursively. If the pointer at offset 0x20 is not NULL, the function reads the first uint from the pointer and initializes some variables. It then enters a loop that processes the uint according to a switch statement. The switch statement has cases for four different values of the uint, and each case performs different operations on the data. In the first case, the function calculates the size of an ASN.1 object and stores."
openssl-101f,O0,mips,asn1_bio_write,./data/decomp/openssl-101f_mips_gcc_O0_extraction/asn1_bio_write@0062b500.c,"The function takes in three integer parameters and checks if certain conditions are met. If they are, it calls another function and returns its result. Otherwise, it returns 0."
openssl-101f,O0,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BIO_asn1_get_suffix@0062b724.c,"The function takes in a BIO object, a pointer to a suffix, and a pointer to a suffix_free variable. It calls the BIO_ctrl function with a command code of 0x98 and a parameter value of 0, which retrieves a suffix from the BIO object. If the function successfully retrieves a suffix, it sets the psuffix and psuffix_free pointers to the retrieved values. The function then returns the result of the BIO_ctrl function call. If the function detects a stack overflow, it calls the __stack_chk_fail function."
openssl-101f,O0,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BIO_asn1_set_prefix@0062b5b0.c,"The function takes in a BIO object, prefix and prefix_free pointers, and returns an integer value. It initializes variables and calls the BIO_ctrl function with certain commands and arguments. If the stack guard variable remains the same, the function returns the value of the BIO_ctrl call. If it changes, the function calls the stack check failure function and exits. If the value of iVar3 is greater than 0, the function sets the values of two pointers. This process is repeated a few more times with different arguments and commands. Finally, the function returns the value of a predefined variable."
openssl-101f,O0,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_get0_nist_prime_224@0062b7cc.c,The function BN_get0_nist_prime_224 returns a pointer to a pre-defined constant BIGNUM object containing the NIST prime number for 224-bit elliptic curve cryptography. It does not take any parameters and uses an unknown calling convention. The warning message indicates that the function's parameter storage is not known or locked.
openssl-101f,O0,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_get0_nist_prime_384@0062b7e4.c,"The function returns a pointer to a BIGNUM structure containing a 384-bit NIST prime number, stored in the _bignum_nist_p_384 variable. It does not take any parameters and its calling convention is unknown. The parameter storage is locked, preventing the function from modifying any input parameters."
openssl-101f,O0,mips,BN_GF2m_add,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_add@00624434.c,"The function BN_GF2m_add adds two elements in GF(2^m) field by XORing the inputs element-wise and storing the result in the output parameter. It first checks which input is larger and swaps them if necessary, expands the memory of the output parameter if needed, and copies any additional elements from the larger input to the output. It trims any leading zero elements in the output parameter and updates its size. The function returns 1 if successful."
openssl-101f,O0,mips,BN_GF2m_mod,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod@006246b4.c,"Both functions perform modular reduction with respect to a polynomial represented by an array of integers. They take in multiple parameters, including pointers to integers and structures. The first function checks if the second parameter is NULL and performs the reduction in place if the first and second parameters are equal. The second function initializes variables and checks if the second BIGNUM parameter is zero before reducing it using BN_GF2m_mod_arr_part_0() function. Both functions return a uint value. The BN_CTX structure is used in the second function."
openssl-101f,O0,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_arr@006245c0.c,"The function BN_GF2m_mod_arr takes four parameters: param_1, param_2, param_3, and param_4. The first if statement checks if the value pointed to by param_3 is 0. If it is, it calls the function BN_set_word to set the value of param_1 to 0 and returns 1. The second if statement checks if param_1 is equal to param_2. If they are not equal, it copies the contents of the array pointed to by param_2 to the array pointed to by param_1. If the size of param_1 is smaller than the size of param_2, it expands the size of param_1 using the function bn_expand2. Finally, the function calls the function BN_GF2m_mod_arr_part_0 with param_1 and param_3 as parameters and returns the result."
openssl-101f,O0,mips,BN_GF2m_mod_div,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_div@006262f0.c,"The function BN_GF2m_mod_div() takes in five parameters: param_1, param_2, param_3, param_4, and param_5. The first three parameters are undefined. The fourth parameter, param_4, is a pointer to an array of integers representing a polynomial in GF(2^m). The fifth parameter, param_5, is a BN_CTX object used for temporary memory allocation. The function initializes the BN_CTX object and calls BN_GF2m_mod_inv() with param_3, param_4, and param_5 as arguments to compute the inverse of param_3 in GF(2^m). If successful, the function allocates memory for an array of integers to represent another polynomial in GF(2^m)."
openssl-101f,O0,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_div_arr@00626508.c,"The function BN_GF2m_mod_div_arr takes in five parameters and initializes a BN_CTX object using function pointers. It sets piVar1 to zero and, if the first element of the array pointed to by param_4 is not equal to -1, sets piVar1 to a bit array with the bits corresponding to the indices in the array pointed to by param_4 set to 1 using the function pointer PTR_BN_set_bit_006a9710. The function then initializes another BN_CTX object and computes the inverse of param_3. If the initialization fails, the function returns false."
openssl-101f,O0,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_mul@006256f0.c,"The function BN_GF2m_mod_mul performs modular multiplication in a binary field GF(2^m) by calling the function BN_GF2m_mod_mul_arr with additional arguments. It allocates memory to store the result of the multiplication, extracts coefficients of the polynomial representation of the input parameter, and passes them as an argument to the function BN_GF2m_mod_mul_arr. It returns zero if the input parameter is zero, throws an error if the number of coefficients in the polynomial representation of the input parameter is greater than the allocated memory, frees the allocated memory, and returns the result of the multiplication."
openssl-101f,O0,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_mul_arr@00624b58.c,"The first function, BN_GF2m_mod_mul_arr, performs multiplication of two arrays of binary polynomials in GF(2^m) and reduces the result modulo a third array. It takes in four input parameters and expands the size of the output array if necessary. 

The second function takes in several input parameters, including pointers to arrays of integers and the length of those arrays. It initializes several local variables and enters a loop that performs several bitwise operations and calculations using the input values and local variables. It returns the final value of one of the local variables. 

The third function takes in five parameters and uses GF(2^m) arithmetic to compute the remainder of the division of the first parameter by the third parameter, using the elements of the second parameter as coefficients. 

The fourth function takes in several parameters, including two arrays of unsigned integers, an integer, and a pointer to an array of unsigned integers. It returns an unsigned integer and checks if the length of the param_1 array is greater than or equal to param_3. It initializes several variables and checks if the param_2 array is not NULL. If it is not NULL, the function checks if the length of the param_2 array is greater than or equal to param_3. If it is not, the function returns an error code."
openssl-101f,O0,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_sqr@006258e4.c,"This function calculates the bit length of the input parameter `param_3` and allocates memory for an array of size `iVar1 * 4` where `iVar1` is the bit length of `param_3` plus one. If memory allocation fails, it returns 0. It then extracts the number of words in `param_3`. If the number of words in `param_3` is zero, it sets `iVar4` to 0 and jumps to step 13. If the number of words in `param_3` minus 1 is less than 0, it sets `iVar4` to 1 and jumps to step 13. It calculates the index of the last word in `param_3` and loops through each word in `param_3` from the last to the first. For each word, it loops through each bit position from the most significant to the least significant."
openssl-101f,O0,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_sqrt@00626d24.c,"The function BN_GF2m_mod_sqrt computes the square root of a given polynomial in GF(2^m) field. It takes four parameters: param_1 is the output parameter for the computed result, param_2 is the input polynomial, param_3 is the irreducible polynomial defining the field GF(2^m), and param_4 is a BN_CTX structure used for temporary storage. The function first calculates the number of bits required to represent the input polynomial using a BN_num_bits function. It then allocates memory for an array of integers to store the positions of the non-zero bits in the input polynomial. If the input polynomial is zero, the function returns 0. Otherwise, it loops through the input polynomial, finds the positions of the non-zero bits, and stores them in the array. The function then sets the most significant bit of the output parameter to 1 and uses the BN_GF2m_mod_exp_arr function to compute the square root of the input polynomial."
openssl-101f,O0,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_GF2m_mod_sqr_arr@006248a0.c,"The function BN_GF2m_mod_sqr_arr performs squaring of a binary polynomial represented as an array of uints in GF(2^m) field. The function takes four parameters: a pointer to a pointer to an array of uints (param_1), a pointer to an array of int (param_2), a pointer to an int (param_3), and an undefined value (param_4). The function initializes a BN_CTX object using the provided param_4 value. It then gets a pointer to a pointer to an array of uints from the BN_CTX object. If the pointer is NULL, the function returns false. The function checks if the size of the array pointed to by the pointer is large enough to hold the result of the squaring operation. If not, it expands the array using the bn_expand2 function. The function then performs the squaring operation on the input array, storing the result in the array pointed to by the pointer."
openssl-101f,O0,mips,BN_kronecker,./data/decomp/openssl-101f_mips_gcc_O0_extraction/BN_kronecker@00623300.c,"The function BN_kronecker computes the Kronecker symbol of two BIGNUMs a and b using the binary algorithm. The Kronecker symbol is a generalization of the Legendre symbol, which is used in number theory to determine whether an integer is a quadratic residue modulo a prime number. The function initializes a BN_CTX object to handle temporary BIGNUMs, copies the values of a and b into two new BIGNUMs using BN_copy, and checks if either a or b is zero or one, returning the appropriate value. If b is negative, it is replaced by its absolute value. The function then finds the highest power of 2 that divides b, and divides b by that power of 2 while keeping track of the sign of the division using a flag in the third word of b's array of words. Finally, the function iteratively divides a by 2 until..."
openssl-101f,O0,mips,by_dir_entry_free,./data/decomp/openssl-101f_mips_gcc_O0_extraction/by_dir_entry_free@00587a40.c,The function takes in a pointer to an integer array and frees memory allocated to it using function pointers. It checks if the first and third elements of the array are not zero and calls different function pointers accordingly. The function also has a jump table that could not be recovered by the decompiler due to too many branches.
openssl-101f,O0,mips,cswift_rand_bytes,./data/decomp/openssl-101f_mips_gcc_O0_extraction/cswift_rand_bytes@005d2070.c,"1. Function generates random bytes using CSwift library and stores them in a buffer. 
2. Function performs Diffie-Hellman key exchange using CryptoSwift library and returns shared secret key. 
3. Function performs cryptographic operations using CryptoSwift library and handles errors. 
4. Function performs RSA encryption or decryption using CSwift library. 
5. Function performs various cryptographic operations related to CSWIFT library and handles errors. 
6. Function performs DSA signing using CSWIFT hardware accelerator. 
7. Function verifies DSA signature using CryptoSwift library and handles errors. 
8. Function is a wrapper for CryptoSwift hardware engine and performs cryptographic operations using it. 
9. Function initializes CSWIFT engine and RSA/DH algorithms for use with it."
openssl-101f,O0,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_mips_gcc_O0_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061cce0.c,"The function attempts to recover a jumptable at memory address 0x0061ccf0, but fails due to too many branches. It then treats an indirect jump as a call to a function pointer (PTR_ASN1_item_d2i_006a9798) and executes the code at that location. Its purpose is to deserialize a GOST client key exchange parameter object."
openssl-101f,O0,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_mips_gcc_O0_extraction/d2i_GOST_KEY_PARAMS@0061cc20.c,"The function calls an external function through a function pointer, specifically accessing a pointer at memory address PTR_ASN1_item_d2i_006a9798. This likely relates to converting a GOST key parameter from binary to ASN.1 format."
openssl-101f,O0,mips,decode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O0_extraction/decode_gost_algor_params@00619aac.c,"The first function, `decode_gost_algor_params`, decodes GOST algorithm parameters from an X.509 certificate by initializing variables, retrieving the algorithm parameters, checking if they are for GOST 2001 or GOST 94, decoding the parameters if they are for GOST 2001, setting the type of the EVP_PKEY object, and filling in the GOST 2001 parameters.

The second function is an implementation of the OpenSSL GOST algorithm for asymmetric encryption. It takes in an EVP_PKEY structure containing a private key, generates a corresponding public key, and returns a success code. It first checks if the input key is of the correct type and contains a private key, extracts the private key, computes the public key using the GOST 2001 algorithm for elliptic curve cryptography, creates a new EVP_PKEY structure to hold the key pair, sets the public key in it, and frees any allocated memory if errors occur."
openssl-101f,O0,mips,DES_xcbc_encrypt,./data/decomp/openssl-101f_mips_gcc_O0_extraction/DES_xcbc_encrypt@00622220.c,"The first function is for performing the DES-XCBC encryption algorithm and takes in an input buffer, output buffer, length of input, a DES key schedule, an initialization vector, and two constant DES blocks. It XORs the input block with the initialization vector, performs a DES encryption using the key schedule, and XORs the result with the output block. 

The second function is for implementing the decryption algorithm for the Blowfish block cipher and takes in a key schedule, an initialization vector (ivec), an input buffer (input), an output buffer (output), and a length parameter. It performs a single Blowfish block decryption operation on the input buffer using the key schedule and initialization vector, and stores the result in the output buffer. 

The third function is for implementing the AES encryption algorithm using a given key and input data. It first initializes the key schedule using the key, and then performs the encryption on the input data using the key schedule. 

The fourth function is a decryption/encryption routine that takes in an input buffer and performs a XOR operation with a key, using the output to encrypt or decrypt the input data. 

The fifth function is a decryption function that takes in an input buffer, a key, an initialization vector (IV), and an output buffer. It XORs each byte with the corresponding byte in the decrypted output buffer and then encrypts the output buffer. 

The sixth function takes in several parameters and performs some encryption on a block of data and XORs it with another block of data. It also handles a stack overflow error and initializes a Big Number Context (BN_CTX) and creates two Big Numbers (BNs) using the context."
openssl-101f,O0,mips,dgram_ctrl,./data/decomp/openssl-101f_mips_gcc_O0_extraction/dgram_ctrl@0052cd98.c,"The functions described are low-level socket manipulation functions that perform different actions based on input parameters or command codes. They involve retrieving and storing values, setting and getting various parameters of the socket, reading and writing data to and from the socket, and performing socket-related operations. Some of the functions call other functions such as setsockopt and getsockopt to perform the desired action. They also involve checking for errors and returning error codes or success codes."
openssl-101f,O0,mips,dlfcn_bind_func,./data/decomp/openssl-101f_mips_gcc_O0_extraction/dlfcn_bind_func@00629ea4.c,"The function takes two integer parameters and sets variables to specific values if either parameter is zero. If both parameters are non-zero, it calls a function at a memory address with an argument from the first parameter, stores the result in a variable, and sets different variables based on the result. It then retrieves an argument from the first parameter, calls the function again with this argument, and stores the result in a variable."
openssl-101f,O0,mips,dlfcn_bind_var,./data/decomp/openssl-101f_mips_gcc_O0_extraction/dlfcn_bind_var@0062a018.c,"The function takes two integer parameters, param_1 and param_2. It checks if either parameter is equal to 0 and sets two variables uVar2 and uVar3 to specific values if so. If both parameters are non-zero, it calls a function at the address pointed to by PTR_sk_num_006a7f2c, passing in the value stored at address (param_1 + 4) as an argument. The result of this function call is stored in iVar1. If iVar1 is less than 1, uVar2 and uVar3 are set to specific values. Otherwise, the value stored at address (param_1 + 4) is stored in uVar3, and another function call is made to PTR_sk_num_006a7f2c, passing in uVar3 as an argument. The result of this call is stored."
openssl-101f,O0,mips,dlfcn_globallookup,./data/decomp/openssl-101f_mips_gcc_O0_extraction/dlfcn_globallookup@00629a60.c,"The function uses dynamic linking to find a symbol specified by the parameter `param_1`. It opens a dynamic library using `dlopen`, looks up the symbol using `dlsym`, and closes the library using `dlclose`. It returns the address of the symbol if found, or `0` if not found or if there was an error in the dynamic linking process."
openssl-101f,O0,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_mont_field_encode@00627d3c.c,"The function takes four parameters: param_1, param_2, param_3, and param_4. It retrieves the value at memory offset param_1+0xa0 and stores it in the variable iVar1. If iVar1 is not equal to zero, it calls a function located at memory address PTR_BN_mod_mul_montgomery_006a9674, passing in param_2, param_3, iVar1+4, iVar1, and param_4 as arguments. It then returns the result of this function call. Otherwise, it calls a function located at memory address PTR_ERR_put_error_006a9030, passing in the error code 0x10, and error messages ""0x86"" and ""0x6f"", as well as the file name ""ecp_mont.c"" and the line number 0x124 as arguments. It then returns 0."
openssl-101f,O0,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_mont_field_sqr@00627cc4.c,"The function implements squaring in a Montgomery field for elliptic curve cryptography, taking four parameters: a pointer to a data structure representing the elliptic curve parameters, and three 32-bit integers representing two field elements and a modulus. It checks if a certain field element in the elliptic curve parameters is non-zero and calls a modular multiplication function using Montgomery multiplication to store the result in a 32-bit integer variable. If the field element is zero, it calls a generic error handling function. The function returns either the result of the modular multiplication or 0 in case of an error."
openssl-101f,O0,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_mont_group_init@006277b0.c,"The function initializes a Montgomery group for elliptic curve cryptography by calling ec_GFp_simple_group_init() to initialize a simple group for the curve. It then sets two variables in the group structure to zero, which are likely used for Montgomery-specific operations. The function returns after these operations."
openssl-101f,O0,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_nist_field_mul@0062815c.c,"The function takes five integer parameters: a pointer to an elliptic curve data structure, a pointer to a big integer scalar value, pointers to two big integer field elements, and an optional pointer to a precomputed big integer value. It checks if any input parameters are zero and reports an error if so. If the optional parameter is zero, it creates a new big integer context, multiplies the two field elements, and squares the result."
openssl-101f,O0,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_nist_group_copy@00627ea0.c,"The function takes in two pointers to elliptic curve group structures, copies a specific value from the second structure to the same offset in the first structure, and then likely copies the remaining fields of the second parameter to the first parameter using another function. The function does not have an explicit return value."
openssl-101f,O0,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_nist_group_set_curve@00627eb8.c,"The function `ec_GFp_nist_group_set_curve` initializes a new `BN_CTX` object and sets `param_5` to its value if `param_5` is equal to 0. If the initialization fails, the function returns 0. The function retrieves the `BN` object representing the NIST prime for either 192-bit, 224-bit, 256-bit, 384-bit, or 521-bit curves based on the value of `param_2`. If `param_2` matches any of the NIST primes, the function sets the appropriate modulus for the curve and calls the `ec_GFp_simple_group_set_curve` function with the input parameters. If `param_2` does not match any of the NIST primes, the function does not perform any action."
openssl-101f,O0,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062e000.c,"The function takes six integer parameters and returns a boolean value. It first checks if a certain memory location pointed to by the first parameter is equal to zero. If it is, it checks if the third and fourth parameters are zero or contain valid values. If the fifth parameter is not zero, it copies a value from memory to it. If all conditions are met, it returns true. If the memory location is not zero, it allocates memory using a function pointer and assigns the pointer to the sixth parameter. It then checks if the third and fourth parameters are zero or contain valid values, using a function pointer stored in the memory location pointed to by the first parameter. If the fifth parameter is not zero, it copies a value from memory to it using the same function pointer. If all conditions are met, it returns true. Otherwise, it returns false."
openssl-101f,O0,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_group_check_discriminant@0062e1ec.c,"The function checks for the validity of the discriminant of a given elliptic curve group by taking in an integer array representing the group parameters and an integer representing a context for big number arithmetic operations. If the context integer is 0, it creates a new context and initializes several integer variables using the context. The function computes the discriminant using a specified algorithm if the input parameters do not have a pre-computed value for the discriminant. It then uses big number arithmetic operations such as copying, squaring, multiplication, addition, and shifting to compute the discriminant, and calls external functions to perform some of these operations. The function returns true if the discriminant is non-zero and false otherwise."
openssl-101f,O0,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_group_clear_finish@0062db04.c,The `ec_GFp_simple_group_clear_finish` function frees memory allocated during the execution of the `ec_GFp_simple_group_init` function. It calls a function with different arguments to accomplish this before returning.
openssl-101f,O0,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_group_copy@0062f054.c,"The function takes two integers as parameters and copies specific values from the second parameter to the first parameter for several memory addresses. If the copying process is successful for all memory addresses, the function returns 1. Otherwise, it returns 0."
openssl-101f,O0,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_group_get_degree@0062dbb4.c,"The function takes an integer parameter and adds an offset of 0x48 to it. It then calls a function at the address pointed to by PTR_BN_num_bits_006a82f4, passing the result of the addition as an argument. The purpose of the function being called is to calculate the degree of the elliptic curve group represented by the integer parameter. The function being called is not directly visible in the decompiled code, as it is being accessed through a pointer."
openssl-101f,O0,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_group_set_curve@0062f194.c,"This function sets the curve for an elliptic curve group. It takes in parameters including a pointer to an integer, a pointer to a pointer to an unsigned integer, two unsigned integers, and an integer. 

The function checks if the number of bits in the pointer to the unsigned integer is less than 3, if the second element of the pointer to the unsigned integer is less than 1, or if the least significant bit of the unsigned integer is 0. If any of these conditions are met, an error is returned.

If the integer parameter is 0, a new context is created and initialized. Then, a copy of the pointer to the unsigned integer is made and stored in the integer parameter array at index 0x12. The function then sets the sign of the integer parameter at index 0x12 to be negative and calculates the modulus of the second parameter and the pointer to the unsigned integer. If this calculation fails, an error is returned."
openssl-101f,O0,mips,ec_GFp_simple_invert,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_invert@00630104.c,"The function takes two parameters, param_1 and param_2. It first calls a function at address PTR_EC_POINT_is_at_infinity_006a9770 and stores the result in iVar1. If iVar1 is equal to 0 and the value at address param_2 + 0x1c is not equal to 0, it calls a function at address PTR_BN_usub_006a96d4 with two parameters: param_2 + 0x18 and param_1 + 0x48. The result of this function call is stored in uVar2 and returned. Otherwise, the function returns 1."
openssl-101f,O0,mips,EC_GFp_simple_method,./data/decomp/openssl-101f_mips_gcc_O0_extraction/EC_GFp_simple_method@00630f54.c,"The function EC_GFp_simple_method returns a pointer to an object of type EC_METHOD from an external library, likely related to elliptic curve cryptography using a finite field GF(p). The specific implementation is not provided in the code snippet. A warning message suggests that the function may use a non-standard calling convention, which could cause issues if called from code expecting a different convention."
openssl-101f,O0,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_point_copy@0062f0f4.c,"The function takes in two pointers to structures representing points on an elliptic curve. It copies the x, y, and z coordinates of the second parameter to the corresponding coordinates of the first parameter using BN_copy, and also copies the flags. If successful, it returns 1, otherwise 0."
openssl-101f,O0,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_point_finish@0062dab0.c,"The function frees memory allocated to three pointers within a structure pointed to by an integer parameter. It specifically frees memory at offsets 4, 0x18, and 0x2c using function pointers to call BN_free. The function returns after completing its task."
openssl-101f,O0,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_point_get_affine_coordinates@0062e4f0.c,"The function takes five parameters and checks if a point is at infinity. If it is, it puts an error message and returns false. If the point is not at infinity, it checks if a parameter is equal to zero. If it is, it allocates memory for a BN_CTX object and starts it. It then gets four BN objects from the BN_CTX object."
openssl-101f,O0,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O0_extraction/ec_GFp_simple_point_set_affine_coordinates@0062f494.c,"The function takes in five parameters: param_1, param_2, param_3, param_4, and param_5. If param_3 and param_4 are both non-zero, the function calls two other functions to set the affine coordinates of a simple point on an elliptic curve. The first function gets a value of one from a predefined location in memory (PTR_BN_value_one_006a9670) and the second function sets the J-projective coordinates of the point using the input parameters and the value of one obtained from the first function. The function then returns the result of the second function call. If either param_3 or param_4 is zero, the function calls another function to put an error message into memory (PTR_ERR_put_error_006a9030) and returns zero."
openssl-101f,O0,mips,encode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O0_extraction/encode_gost_algor_params@0061b110.c,"The functions are related to the implementation of the GOST algorithm and key generation using OpenSSL. 

Function 1: 
- Encodes parameters for the GOST algorithm. 
- Creates a GOST_KEY_PARAMS object and sets the curve name or parameter set. 
- Encodes the object using i2d_GOST_KEY_PARAMS and returns the encoded parameters as an integer array. 
- Prints an error message if any errors occur.

Function 2: 
- Initializes variables and pointers. 
- Checks if input parameters are valid. 
- Calls functions for cryptographic operations. 
- Encodes and decodes data using GOST algorithms. 
- Handles different cases based on input parameters. 
- Returns a result based on the performed operations.

Function 3: 
- Implements the GOST algorithm for encoding and decoding data. 
- Checks if input parameters are valid. 
- Encodes the data using the GOST algorithm and returns the encoded data if successful. 
- Returns an error message if the encoding fails. 
- Decodes the data using the GOST algorithm if the input parameters are valid.

Function 4: 
- Generates a new GOST key pair (public and private keys) using the R3410-2001-CryptoPro-A algorithm. 
- Initializes local variables and creates a new BN_CTX object for key generation. 
- Generates a new EC_KEY object using the R3410-2001-CryptoPro-A curve parameters and sets it as the EVP_PKEY object's internal key. 
- Generates a new private key, computes the corresponding public key using the EC_KEY object, and sets the private key as the EVP_PKEY object's internal key. 
- Outputs the generated key pair and curve parameters to a BIO object."
openssl-101f,O0,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_mips_gcc_O0_extraction/general_allocate_boolean.constprop.5@005b32bc.c,"The function `general_allocate_boolean_constprop_5` takes in eight parameters: `param_1`, `param_2`, `param_3`, `param_4`, `param_5`, `param_6`, `param_7`, and `param_8`. It first checks if `param_4` is equal to `NULL`. If it is, it returns an error code of -1. If `param_4` is not equal to `NULL`, the function checks if `param_5` is not equal to 0. If `param_5` is not equal to 0, the function checks each character in `param_4` to see if it is a valid character. If a character is not valid, the function returns an error code of -1. If all characters in `param_4` are valid, the function checks if `param_2` is equal to 0. If it is, the..."
openssl-101f,O0,mips,get_gost_engine_param,./data/decomp/openssl-101f_mips_gcc_O0_extraction/get_gost_engine_param@0061ee48.c,"The function takes an integer parameter called `param_1` and returns an integer value. If `param_1` is equal to 0, the function retrieves the value of the environment variable ""CRYPT_PARAMS"" using a function pointer `PTR_getenv_006aab6c`. If the environment variable is not set, the function returns 0. Otherwise, the function duplicates the value of the environment variable using a function pointer `PTR_BUF_strdup_006a80dc` and stores it in the `gost_params` variable. Finally, the function returns the value of `gost_params`. If `param_1` is not equal to 0, the function simply returns 0."
openssl-101f,O0,mips,gost2001_param_encode,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost2001_param_encode@0061a1d4.c,"The function takes in two parameters of type undefined4 (uint32_t) and performs a series of function calls using global variables. It first calls PTR_EVP_PKEY_get0_006aa6e4, stores the result in a local variable uVar1, then passes uVar1 as an argument to PTR_EC_KEY_get0_group_006a8780 and stores the result back in uVar1. It then calls PTR_EC_GROUP_get_curve_name_006a9110, passing uVar1 as an argument and stores the result in uVar1. Finally, it calls PTR_OBJ_nid2obj_006a8240, passing uVar1 as an argument and stores the result back in uVar1."
openssl-101f,O0,mips,gost_cipher_cleanup,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost_cipher_cleanup@0061cfe0.c,"The function takes an integer as input to access a specific memory location and deallocates any resources associated with a GOST cipher object by calling the `gost_destroy` function on a specific offset. It then sets a specific offset from the input integer to 0 and returns 1, likely cleaning up and deallocating resources."
openssl-101f,O0,mips,gost_cipher_ctl,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost_cipher_ctl@0061d874.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function calls a `RAND_bytes` function pointer stored in memory at `PTR_RAND_bytes_006a8d44` with the parameters `param_4`, the value stored at `param_1 + 0x58`, `param_3`, `param_4`, and a global pointer `_gp`. If the return value of the `RAND_bytes` function is less than 1, the function calls `ERR_GOST_error` with the error codes 0x6f and 0x7b and returns -1. Otherwise, it returns 1. If `param_2` is equal to 7 and `param_4` is not equal to NULL, the function stores the value 0x32a at the memory."
openssl-101f,O0,mips,gost_cipher_do_cnt,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost_cipher_do_cnt@0061d1dc.c,"The function `gost_cipher_do_cnt` takes four parameters: an integer `param_1`, a pointer to a byte `param_2`, a pointer to a byte `param_3`, and an unsigned integer `param_4`. It retrieves the value of a variable `uVar4` from the memory location `param_1 + 0x50`. If `uVar4` is equal to zero, it sets `uVar4` to 8 and `uVar3` to zero. Otherwise, it sets `uVar2` to the value of `uVar4`. If `uVar4` is less than 8, the function performs a series of XOR operations between bytes in `param_2` and `param_3`, using bytes stored in memory locations `param_1 + uVar4 + 0x30` and increments the values of `uVar2` and `uVar3` accordingly.

The function takes in four parameters: a pointer to a buffer (param_1), a pointer to another buffer (param_2), a pointer to a third buffer (param_3), and the size of the third buffer (param_4). It first checks if the size of the third buffer is less than or equal to 4. If so, it sets the value at offset 0x50 in the first buffer to 4 and returns 1. If the size of the third buffer is greater than 4, the function XORs the value at offset 0x30 in the first buffer with the first byte of the third buffer and stores the result in the first byte of the second buffer. It then checks if the size of the third buffer is less than or equal to 5. If so, it sets the value at offset 0x50 in the first buffer to 5 and returns 1. If the size of the third buffer is greater than..."
openssl-101f,O0,mips,gost_cipher_init,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost_cipher_init@0061ea98.c,"The function checks if the cipher has been initialized and if not, sets the cipher parameters, initializes the cipher, sets the key and initialization vector (if provided), and returns a success indicator. It first checks if the cipher has been initialized by verifying if a specific value in the context is non-zero. If it has not been initialized, it gets the GOST engine parameter from the engine, and if the parameter is not specified or is empty, it uses the default cipher from the cipher list. If the parameter is specified, it looks up the cipher in the cipher list by its name and uses that cipher. It then sets the cipher parameters in the context (cipher type, key length, and initialization vector) and initializes the cipher. If a key is provided, it sets the cipher key. If an initialization vector is provided, it copies it into the context and the initialization vector into the context's IV buffer. Finally, it returns 1 to indicate success."
openssl-101f,O0,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O0_extraction/GOST_CIPHER_PARAMS_new@0061ccb0.c,"The function creates a new instance of the GOST_CIPHER_PARAMS data structure using a function pointer that points to the implementation of the ASN1_item_new function. The GOST_CIPHER_PARAMS_it argument is passed to this function pointer to indicate the type of data structure to create, and the resulting data structure is returned."
openssl-101f,O0,mips,gost_imit_final,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost_imit_final@0061e800.c,"The function takes two parameters, an integer and an undefined value. It retrieves two values from the integer parameter and checks if they are not zero. If both values are not zero, it sets a local variable to zero and then checks if the second retrieved value is greater than 7. If it is, it sets another local variable to the value of the first retrieved value and continues to a label. If the second retrieved value is not greater than 7, it sets the local variable to the second retrieved value and continues to the same label. 

At the label, it sets another local variable to zero and then checks if the first retrieved value is equal to 1. If it is, it sets another value in the integer parameter to zero. It then calls two other functions, passing in the integer parameter and some other values. It then sets another value in the integer parameter."
openssl-101f,O0,mips,gost_imit_init_cpa,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost_imit_init_cpa@0061d7ec.c,"The function initializes the context for the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A, sets various fields in the context structure to zero, sets the mode of operation to CPA, calls the gost_init function to initialize the key schedule and other parameters needed for encryption, and returns a value of 1 to indicate success."
openssl-101f,O0,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O0_extraction/GOST_KEY_PARAMS_new@0061cc50.c,The function creates a new instance of the GOST_KEY_PARAMS data structure using the ASN1_item_new function and returns without any values. The function pointer for the ASN1_item_new function is obtained from the PTR_ASN1_item_new_006a9778 pointer.
openssl-101f,O0,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_mips_gcc_O0_extraction/GOST_KEY_TRANSPORT_free@0061cb48.c,The function takes in a 4-byte parameter and calls another function to free memory allocated for an ASN.1 item of type GOST_KEY_TRANSPORT. It does not return anything and uses a jumptable that could not be recovered during decompilation due to too many branches.
openssl-101f,O0,mips,gost_param_free,./data/decomp/openssl-101f_mips_gcc_O0_extraction/gost_param_free@0061ed70.c,"The function checks if ""gost_params"" is not equal to zero, frees the memory allocated to ""gost_params"" using ""PTR_CRYPTO_free_006a7f88"", and sets ""gost_params"" to zero. If ""gost_params"" is already zero, the function returns without doing anything."
openssl-101f,O0,mips,hash_step,./data/decomp/openssl-101f_mips_gcc_O0_extraction/hash_step@0061ef50.c,"The first function takes in three parameters, performs XOR operations, bitwise operations, and calls another function to encrypt data using the GOST encryption algorithm. The second function takes in two arrays of integers, performs bitwise operations, XOR operations, and stores the results in local variables. The third function takes in a pointer to a byte array and an integer value, performs XOR, bit shifting, and memory moves to encrypt the data using the GOST encryption algorithm. The fourth function takes in three parameters and enters a loop that performs XOR and bitwise operations on the plaintext and local variables, and stores the result in the output buffer. The fifth function checks if two values are equal, and if they are not, it calls several functions including a stack check failure function, a memset function, and a malloc function to allocate memory."
openssl-101f,O0,mips,hwcrhk_init,./data/decomp/openssl-101f_mips_gcc_O0_extraction/hwcrhk_init@005d6a80.c,"The `hwcrhk_init` function initializes the hardware crypto hook library by loading and binding its functions. It checks if the library has already been loaded and loads it using `PTR_DSO_load_006a99a4` if necessary. It sets an error code and returns 0 if the library fails to load or if any necessary functions fail to bind. If all functions are successfully bound, it sets global variables to point to these functions and returns 1. If an error occurs at any point during initialization or if the library has already been loaded, it sets an error code and returns 0. If the library was loaded successfully but the context is not available, it sets an error code and returns 0."
openssl-101f,O0,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_mips_gcc_O0_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061cbd8.c,"The function takes two undefined4 parameters and calls another function at a specific address, passing in the two parameters and a third parameter of type GOST_KEY_AGREEMENT_INFO_it. The called function is likely an encoder for an ASN.1 data structure, but this function does not return the encoded data."
openssl-101f,O0,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_mips_gcc_O0_extraction/i2d_GOST_KEY_TRANSPORT@0061cb18.c,"The function i2d_GOST_KEY_TRANSPORT takes two parameters, both of type undefined4, and converts a GOST key transport structure into an ASN.1 encoded format by calling an indirect jump to a code function at the address PTR_ASN1_item_i2d_006a979c with the parameters passed to the function and a third parameter GOST_KEY_TRANSPORT_it. The specifics of how this conversion is done are not clear from the decompiled code. The function returns without any value."
openssl-101f,O0,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101f_mips_gcc_O0_extraction/load_pkcs12.constprop.4@004592d8.c,"The function `load_pkcs12_constprop_4` loads a PKCS12 file using `d2i_PKCS12_bio` and verifies the MAC using `PKCS12_verify_mac`. If the MAC verification fails, it prompts the user for a password and tries again. If the MAC verification still fails, it returns 0. If the MAC verification succeeds, it continues with the rest of the function."
openssl-101f,O0,mips,param_copy_gost94,./data/decomp/openssl-101f_mips_gcc_O0_extraction/param_copy_gost94@0061a670.c,"The function takes in two parameters of type undefined4 and returns an undefined4 value. It first retrieves the internal representation of the two parameters using function pointers. It then checks if the base ID of the two parameters is the same. If not, it throws an error and returns 0. If the base ID is the same, it checks if the second parameter has a valid internal representation. If not, it throws an error and returns 0. If the second parameter has a valid internal representation, it checks if the first parameter has a valid internal representation. If not, it creates a new DSA object and assigns it to the second parameter. The function then copies three big integers from the first parameter to the second parameter using BN_dup() function. Finally, it computes the public key using gost94_compute_public() function and returns 1."
openssl-101f,O0,mips,param_print_gost01,./data/decomp/openssl-101f_mips_gcc_O0_extraction/param_print_gost01@0061abe4.c,"The function takes in three parameters and calls several functions at specific memory addresses. It stores the results of these function calls in variables uVar1 and iVar2. If iVar2 is not equal to 0, the function continues to execute."
openssl-101f,O0,mips,param_print_gost94,./data/decomp/openssl-101f_mips_gcc_O0_extraction/param_print_gost94@0061ac98.c,"These function summaries describe various implementations of the GOST cryptographic algorithm in the OpenSSL library. They involve tasks such as retrieving values from memory, generating random keys, encoding algorithm parameters, encrypting data, and printing key information. They also handle errors and check for potential buffer overflows. These functions are likely low-level implementation details and not meant to be called directly by end-users."
openssl-101f,O0,mips,pkey_ctrl_gost,./data/decomp/openssl-101f_mips_gcc_O0_extraction/pkey_ctrl_gost@0061b6d4.c,"The first function takes in four parameters and returns an integer. It initializes a switch statement based on the second parameter and performs different actions depending on its value. These actions include setting local variables, calling functions using pointers, and setting variables to returned values. The function ultimately returns a value based on its success.

The second function takes in a pointer to an EVP_PKEY structure and a BIO structure. It checks if the EVP_PKEY structure is of type EVP_PKEY_EC and if the EC_KEY structure inside it is non-null. If so, it retrieves the EC_POINT structure representing the public key from the EC_KEY structure, as well as the group and curve associated with the EC_KEY structure. It then retrieves the affine coordinates of the EC_POINT structure and prints them along with the parameter set associated with the curve to the BIO structure. If there is an error in retrieving the affine coordinates or the EVP_PKEY/EC_KEY structures, the function returns 0."
openssl-101f,O0,mips,pkey_free_gost94,./data/decomp/openssl-101f_mips_gcc_O0_extraction/pkey_free_gost94@0061abc0.c,"The function takes an integer parameter, likely a pointer to a structure related to a GOST94 public key, and checks if a certain offset from the parameter contains a non-zero value. If it does, the function jumps to a certain code address and executes it as a function call. If the value at the offset is zero, the function simply returns. This function is likely freeing memory related to a GOST94 public key."
openssl-101f,O0,mips,priv_encode_gost,./data/decomp/openssl-101f_mips_gcc_O0_extraction/priv_encode_gost@0061bb14.c,"These two functions both work with EVP_PKEY objects that contain EC keys. The first function encodes a GOST private key and writes information about it to a BIO object, including the public key value and parameter set. The second function extracts the public key and group parameters from the EC key and prints them to a BIO object. Both functions return 0 if any operations fail."
openssl-101f,O0,mips,pub_encode_gost94,./data/decomp/openssl-101f_mips_gcc_O0_extraction/pub_encode_gost94@0061b904.c,"The two functions pertain to encoding and retrieving information about GOST 94 public keys. 

The first function, `pub_encode_gost94`, takes two integer parameters representing the key and its length, respectively. It retrieves algorithm parameters for the key, encodes them using `encode_gost_algor_params`, and allocates memory for the encoded key. It then retrieves the base ID of the key, encodes the algorithm parameters and base ID into a buffer, and prints out the private key using `BIO_printf`. Finally, it returns the encoded key.

The second function takes a pointer to an EVP_PKEY structure as input and returns an integer value. It checks if the input pointer is null and returns 0 if it is. If the EVP_PKEY structure contains an EC_KEY structure, the function prints out information about the private key and public key using OpenSSL library functions, determines the parameter set used for the key and prints that information, calculates and prints out the affine coordinates of the public key using `EC_POINT_get_affine_coordinates_GFp` function from the OpenSSL library. It returns 1 if the operation is successful and 0 if it encounters an error."
openssl-101f,O0,mips,pub_print_gost94,./data/decomp/openssl-101f_mips_gcc_O0_extraction/pub_print_gost94@0061ae00.c,"The first function takes in three parameters, retrieves values from them, prints information to the console, and enters a loop to call another function with arguments.

The second function encodes a GOST key object in ASN.1 format and returns a pointer to the encoded data. It initializes variables, retrieves the public key and curve name/parameter set ID, creates a GOST_KEY_PARAMS object, encodes it in ASN.1 format, and handles errors.

The third function implements the EVP_PKEY_METHOD for the GOST R 34.10-2001 algorithm. It extracts the public key from the input key, encodes it as a GOST R 34.10-2001 public key, and either verifies a signature or generates a signature based on the input operation.

The fourth function performs several arithmetic operations, calls functions with arguments, and copies data from memory.

The fifth function implements the key printing functionality for the GOST elliptic curve algorithm. It retrieves the EC_KEY structure from the EVP_PKEY structure, retrieves group information, prints relevant data to the output buffer, and returns a pointer to the output buffer."
openssl-101f,O0,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O0_extraction/RSA_padding_add_PKCS1_PSS@00628ef8.c,"The first function, `RSA_padding_add_PKCS1_PSS`, adds padding to a message using the PKCS1-PSS scheme before encrypting it with RSA. It takes in the RSA key, message hash, hash algorithm, and salt length. It checks the hash length and calculates the default salt length if necessary. It then initializes an EVP_MD_CTX structure, updates it with the message hash and salt, generates a mask for the padding using PKCS1-MGF1, XORs it with the message, and sets the resulting value as the encoded message.

The second function takes in a message, its length, a public key, and a hash function. It generates a random value k, computes a point on an elliptic curve, encodes the point using X9.62 encoding, computes the hash of the message, concatenates it with the encoded point, pads the resulting byte string with zeros to the length of the public key, encrypts it with the public key, and returns the resulting ciphertext as the encoded message. It performs additional padding and XOR operations to further obscure the message if the encryption is successful, and returns an error code if not."
openssl-101f,O0,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O0_extraction/RSA_verify_PKCS1_PSS@00628440.c,"The first function verifies a PKCS1 PSS signature using RSA encryption. It initializes an EVP_MD context, checks the signature length, calculates padding bits, and checks the signature for validity. If valid, it returns 1, otherwise 0.

The second function implements the RSA-PSS signature scheme. It initializes variables, checks the hash function and salt length, generates salt, performs padding, hashes the message, and generates the signature through RSA encryption and decryption operations. It returns an error code if the hash function or salt length are invalid."
openssl-101f,O0,mips,sha_block_data_order,./data/decomp/openssl-101f_mips_gcc_O0_extraction/sha_block_data_order@00620b30.c,"These functions all implement various versions of the SHA-1 and SHA-256 hashing algorithms. They take in an input message and perform a series of logical and arithmetic operations on the data in blocks of 512 or 64 bytes, updating a set of variables with each block of data. The operations include bitwise operations, shifts, additions, and logical operations such as XOR, AND, and OR. The final hash value is obtained by concatenating the state of the hash function after processing all the message blocks. The purpose and meaning of these computations are not clear without additional context."
openssl-101f,O0,mips,SHA_Final,./data/decomp/openssl-101f_mips_gcc_O0_extraction/SHA_Final@00621fdc.c,"The function takes in a message digest (md) and a SHA context (c) as parameters. It sets a pointer (puVar5) to the data in the context and increments the ""num"" property of the context by 1. It sets the byte at the index of ""num"" in the data to 0x80. If the value of ""num"" plus 1 is less than 0x39, it sets iVar4 to 0x38 minus the value of ""num"" plus 1. Otherwise, it sets iVar4 to 0. It then fills the remaining bytes in the data with 0s, calls the sha_block_data_order function with the context and data, and sets the value of ""num"" to 0. The function then sets the values of the last 8 bytes in the data to the high and low bits of the context's ""Nh"" and ""Nl"" properties. It calls the sha_block_data_order function."
openssl-101f,O0,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_mips_gcc_O0_extraction/SSL_SESSION_free.part.2@004b0e94.c,"The function frees memory allocated to an SSL session object. It first frees extended data associated with the session, then clears sensitive data fields using OPENSSL_cleanse. It frees memory allocated to the certificate and X509 certificate associated with the session object, as well as any stack of peer certificates. Additionally, it frees memory allocated to various other fields in the session object."
openssl-101f,O0,mips,start_hash,./data/decomp/openssl-101f_mips_gcc_O0_extraction/start_hash@0061feb8.c,"The function takes a pointer to an array of 4 undefined 4-byte integers as input. If the value of the third element in the array is not equal to zero, the function sets the values of the elements at index 4 to 23 and the elements at index 12 to 23 using the memset function. It also sets the value of the third element to zero, the value of the second element to zero, and the value of the first element to zero. Finally, the function returns 1 if the third element was not equal to zero, and 0 otherwise."
openssl-101f,O0,mips,surewarehk_finish,./data/decomp/openssl-101f_mips_gcc_O0_extraction/surewarehk_finish@005d8534.c,"This function checks if the surewarehk dynamic shared object (DSO) is loaded. If it is, it calls the surewarehk_Finish function to perform any necessary cleanup. It then frees the surewarehk DSO and checks if there was an error. If there were no errors, it returns a value of 1 to indicate success. It also frees any other resources that were allocated by the function and returns the success value. If the surewarehk DSO is not loaded, it sets a library error code and calls a function to put an error message."
openssl-101f,O0,mips,sv_body,./data/decomp/openssl-101f_mips_gcc_O0_extraction/sv_body@00442f98.c,"The functions are related to SSL/TLS connections and web server handling. 

Function `sv_body` is used for handling SSL/TLS connections on the server side. It allocates a buffer, initializes the SSL/TLS context, sets various options, and handles incoming connections.

Function `do_server_loop` handles incoming SSL connections from clients. It sets up variables, checks the SSL context, waits for incoming connections, reads data, and sends a response back to the client.

Function `SSL_server` implements a basic SSL server using OpenSSL libraries. It sets up a TCP socket, initializes an SSL context, loads certificates and keys, and handles incoming connections.

Function `print_ssl_details` prints out various details about the SSL/TLS connection, such as the cipher being used, the SSL version, and any certificates involved. It takes in a socket file descriptor, a flag indicating whether the socket is in server mode or not, and a buffer for reading input.

Function `handle_http_request` handles incoming HTTP requests. It reads the request from the client using the SSL connection, parses it to determine the requested file path, and sends a response with the contents of the requested file.

Function `web_server_handler` is a part of a web server that handles HTTP requests. It extracts the requested file path from the HTTP request, checks if it contains any "".."" references, checks if the file exists and is accessible, and sends a response back to the client."
openssl-101f,O0,mips,__do_global_ctors_aux,./data/decomp/openssl-101f_mips_gcc_O0_extraction/__do_global_ctors_aux@00631900.c,The function calls all global constructors in the program by iterating through the constructor list in reverse order and invoking each constructor function pointer until the end of the list is reached. It first checks if there are any constructors to call by verifying that the address of the constructor list is not equal to 0xffffffff.
openssl-101f,O0,mips,__libc_csu_init,./data/decomp/openssl-101f_mips_gcc_O0_extraction/__libc_csu_init@00631850.c,"The function __libc_csu_init initializes the C runtime environment by calling a function stored in the address PTR__init_006aaa30, which is a pointer to the initialization routine of the program. The function then returns."
openssl-101f,O0,mips,__start,./data/decomp/openssl-101f_mips_gcc_O0_extraction/__start@00421540.c,"The function initializes local variables, calls `__libc_start_main` with the address of `main` and other arguments, and enters an infinite loop to execute the program's `main` function."
openssl-101f,O0,mips,__udivdi3,./data/decomp/openssl-101f_mips_gcc_O0_extraction/__udivdi3@00630f60.c,"The first function performs unsigned integer division of a 64-bit dividend by a 32-bit divisor, using bit shifting and multiplication to calculate the quotient and remainder. It checks for a zero divisor and returns an error, or returns zero if the dividend is less than the divisor.

The second function takes in five parameters and performs arithmetic operations to return a 64-bit unsigned integer as the result. It creates a 32-bit unsigned integer from two of the parameters, checks for certain conditions, and calculates a value used in further operations."
openssl-101f,O1,mips,aep_mod_exp.part.0,./data/decomp/openssl-101f_mips_gcc_O1_extraction/aep_mod_exp.part.0@005cf33c.c,"The functions implement modular exponentiation using the AEP hardware device. They take in input parameters such as base, exponent, and modulus values, and attempt to establish a connection with the AEP device to perform the operation. If the operation is successful, the functions update a table of active AEP connections and return a success code. If the operation fails, the functions set an error code and log an error message. The functions also handle loading and unloading AEP library functions, initializing and finalizing the AEP library, and setting up callback functions."
openssl-101f,O1,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_mips_gcc_O1_extraction/asn1_bio_callback_ctrl@0062aca0.c,"`asn1_bio_callback_ctrl` takes an integer parameter `param_1` and checks if the value at the memory address `param_1 + 0x24` is not equal to zero. If it is not zero, the function jumps to an unknown address (which is likely a function pointer) and executes the code at that address. The return value of that code is then returned by `asn1_bio_callback_ctrl`. If the value at `param_1 + 0x24` is zero, the function returns zero."
openssl-101f,O1,mips,asn1_bio_ctrl,./data/decomp/openssl-101f_mips_gcc_O1_extraction/asn1_bio_ctrl@0062ad94.c,"The `asn1_bio_ctrl` function takes four parameters and performs various operations based on the value of `param_2`, which is a control command. If `param_2` is 0x97 or 0x95, the function sets two values in an array pointed to by `piVar3`. If `param_2` is greater than or equal to 0x98, the function either gets or sets values in the same array. If `param_2` is 0xb, the function writes data from the array to a BIO and calls a callback function, returning 0 if the write operation fails. For any other value of `param_2`, the function calls another function."
openssl-101f,O1,mips,asn1_bio_free,./data/decomp/openssl-101f_mips_gcc_O1_extraction/asn1_bio_free@0062acc4.c,"The function takes an integer parameter `param_1` and retrieves an integer value from the memory location `param_1 + 0x20` and stores it in the variable `iVar1`. If `iVar1` is not equal to 0, the function checks if the integer value stored in the memory location pointed to by `iVar1 + 4` is not equal to 0. If it is not equal to 0, the function calls a function at the address `PTR_CRYPTO_free_006a7f88`, which is likely a memory deallocation function. Then, the function calls the memory deallocation function at the address `PTR_CRYPTO_free_006a7f88` with the integer value stored in `iVar1` as the argument. Finally, the function sets the memory locations `param_1 + 0xc`, `param_1 + 0x20`, and `param_1 + 0x14` to a value."
openssl-101f,O1,mips,asn1_bio_write.part.1,./data/decomp/openssl-101f_mips_gcc_O1_extraction/asn1_bio_write.part.1@0062b180.c,"The function asn1_bio_write_part_1 takes three parameters: param_1, param_2, and param_3. It initializes local variables and checks if the buffer pointer is null. If it is null, the function returns 0. If the value of the first element in the buffer is less than 5, the function enters a loop where it performs different actions depending on the value of the element. These actions include calculating the size of an ASN.1 object, writing data to a BIO stream, and calling a callback function. If the value is not less than 5, the function sets the value of param_2 to 0xf and clears the flags of the BIO stream. The function then returns 0. Overall, the function seems to be a low-level function for writing."
openssl-101f,O1,mips,asn1_bio_write,./data/decomp/openssl-101f_mips_gcc_O1_extraction/asn1_bio_write@0062b500.c,"The function takes in three parameters: param_1, param_2, and param_3. It checks if param_2 is not equal to 0, param_3 is greater than -1, and if the value stored at the memory address pointed to by (param_1 + 0x24) is not equal to 0. If all of these conditions are true, it calls another function called asn1_bio_write_part_1() and returns its result. Otherwise, it simply returns 0."
openssl-101f,O1,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BIO_asn1_get_suffix@0062b724.c,"The function ""BIO_asn1_get_suffix"" takes three parameters: a pointer to a BIO object ""b"", a pointer to a pointer ""psuffix"", and a pointer to a pointer ""psuffix_free"", and returns an integer value. It initializes a pointer ""puVar1"" to the address of a stack guard variable, declares and initializes an integer variable ""local_14"" to the value of the stack guard variable, calls the ""BIO_ctrl"" function with three arguments: the BIO object ""b"", the integer value 0x98, and the integer value 0. The result of this call is stored in the ""iVar2"" variable. It then checks if the value of ""iVar2"" is greater than 0. If it is, the function assigns the value of ""local_1c"" to the pointer pointed to by ""psuffix"" and the value of ""local_20"" to the pointer pointed to by ""psuffix_free""."
openssl-101f,O1,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BIO_asn1_set_prefix@0062b5b0.c,"The function BIO_asn1_set_prefix takes in a BIO object, a prefix string, and a prefix_free string as arguments. It calls the BIO_ctrl function with different parameters and stores the result in the variable iVar3. Depending on the value of iVar3, the function sets the values of two pointers puVar4 and puVar5 to certain values. Finally, the function returns either the value of iVar3 or a predefined constant value."
openssl-101f,O1,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_get0_nist_prime_224@0062b7cc.c,"The function returns a pointer to a BIGNUM structure containing the NIST prime number for the curve P-224, which is stored in a static array named ""_bignum_nist_p_224"". It does not take any parameters and the parameter storage is locked and cannot be modified. The calling convention is unknown."
openssl-101f,O1,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_get0_nist_prime_384@0062b7e4.c,"The function returns a pointer to a BIGNUM object that represents a specific prime number used in the NIST P-384 elliptic curve cryptography. The prime number is stored in a static array named _bignum_nist_p_384. The function does not take any parameters, and the calling convention is unknown. The warning message indicates that the way the parameters are stored in memory is not clear to the decompiler."
openssl-101f,O1,mips,BN_GF2m_add,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_add@00624434.c,"The function BN_GF2m_add adds two binary polynomials represented by the arrays pointed to by param_2 and param_3, and stores the result in the array pointed to by param_1. It checks the size of the input arrays and expands the size of param_1 if necessary, using the bn_expand2_006a9680 function. The addition is performed by XORing the corresponding elements of the two input arrays, starting from the first element, and storing the result in the corresponding element of the output array pointed to by param_1. The loop continues."
openssl-101f,O1,mips,BN_GF2m_mod,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod@006246b4.c,"Two functions are described here:

Function 1: BN_GF2m_mod

The function takes four parameters: param_1, param_2, param_3, and param_4.
- param_1 is an integer array representing a polynomial in GF(2^m) field.
- param_2 is also an integer array representing a polynomial in GF(2^m) field.
- param_3 is a pointer to an array of integers, representing the irreducible polynomial in GF(2^m) field.
- param_4 is a string representing the name of the file where the function is called from.

The function first checks if param_3[1] is NULL, and if so, it calls an error function and returns 0.
If param_3[1] is not NULL, the function checks if the first element of local_2c (an array of 6 char pointers) is NULL. If it is NULL, it sets param_1 to 1 and returns.

Function 2: Unnamed

The function takes in four parameters: ppuVar1, ppuVar2, param_3, and param_4.
- ppuVar1 and ppuVar2 are pointers to arrays of pointers to BIGNUM structures.
- param_3 is a pointer to a BIGNUM structure.
- param_4 is a pointer to a BN_CTX structure.

The function first initializes some local variables, including a pointer to a BIGNUM structure (puVar12) and a pointer to an array of pointers to BIGNUM structures (ppuVar8).
It then checks if ppuVar1 and ppuVar2 are equal. If they are, it sets ppuVar8 to ppuVar1. If they are not equal, it checks if the third element of ppuVar2 is less than puVar12. If it is, it expands ppuVar2 using the BN_expand function.
Next, the function sets iVar9 to."
openssl-101f,O1,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_arr@006245c0.c,"The function BN_GF2m_mod_arr takes in four parameters and returns an undefined4 value. It first checks if the value pointed to by param_3 is equal to zero. If it is, it sets the value pointed to by param_1 to zero and returns 1. It then checks if the value pointed to by param_1 is equal to the value pointed to by param_2. If they are not equal, it copies the contents of the array pointed to by param_2 into the array pointed to by param_1, expanding the size of the array if necessary. Finally, it calls the function BN_GF2m_mod_arr_part_0 with the parameters param_1 and param_3, and returns the value returned by this function."
openssl-101f,O1,mips,BN_GF2m_mod_div,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_div@006262f0.c,"The function BN_GF2m_mod_div() takes five parameters: three undefined values, an integer array (param_4), and another undefined value. It returns a boolean value. The function initializes a context and variable, gets the inverse of a given value in the GF(2^m) field using the integer array and context variable, allocates memory for an integer array, and calculates the number of bits required to store the result. It then checks if the second value in the integer array is zero and sets the boolean value to false if it is. Otherwise, the function calculates the number."
openssl-101f,O1,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_div_arr@00626508.c,"The function BN_GF2m_mod_div_arr takes in five parameters: param_1, param_2, param_3, param_4, and param_5. param_1 and param_2 are arrays of integers representing binary polynomials in GF(2^m). param_3 is an integer representing a binary polynomial in GF(2^m). param_4 is an array of integers representing a binary polynomial in GF(2^m) that is used as a divisor. param_5 is a BN_CTX structure used for temporary storage during the computation. The function initializes a BN_CTX structure using the PTR_BN_CTX_start_006a9644 and PTR_BN_CTX_get_006a9648 functions. If the initialization fails, the function returns false. The function creates a new integer piVar1 initialized to 0 and sets its bits according to the values in the param_4 array. The function initializes another BN."
openssl-101f,O1,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_mul@006256f0.c,"The function BN_GF2m_mod_mul performs a multiplication operation on two input parameters (param_1 and param_2) using a polynomial of degree param_3 in GF(2^m) field. The result is stored in param_1. The function first calculates the number of bits required to represent the polynomial in param_4 and allocates memory accordingly. It then extracts the non-zero coefficients of the polynomial and stores their positions in the allocated memory. If the polynomial has no non-zero coefficients, the function sets the result to 0 and returns. Otherwise, it calls the BN_GF2m_mod_mul_arr function to perform the multiplication operation. If the number of non-zero coefficients exceeds the allocated memory, the function sets an error and returns. Finally, the allocated memory is freed."
openssl-101f,O1,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_mul_arr@00624b58.c,"The first function, BN_GF2m_mod_mul_arr(), multiplies two arrays of GF(2^m) elements and stores the result in a third array. It uses a table and a function to reduce the result modulo a polynomial. The second function performs complex bitwise operations on input parameters, possibly for cryptographic purposes. The third function implements modular reduction for binary polynomials in GF(2^m) using a normal basis representation. The fourth function checks input parameters and loops through elements of an array to add corresponding indices to another array, then calls BN_GF2m_mod_mul_arr() to perform a multiplication."
openssl-101f,O1,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_sqr@006258e4.c,"The OpenSSL library's BN_GF2m_mod_sqr function performs modular squaring of binary polynomials over the Galois field GF(2^m). It takes an integer array representing a binary polynomial, the degree of the polynomial, and a modulus polynomial as input. The function calculates the number of bits required to represent the polynomial, allocates memory for a new integer array, and converts the input polynomial into a set of indices representing the positions of the non-zero coefficients. It then calls BN_GF2m_mod_sqr_arr to perform the modular squaring operation on the polynomial represented by the indices. The function frees the memory allocated for the new integer array and returns the result of the operation. If there is an error, it sets an error code and returns 0."
openssl-101f,O1,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_sqrt@00626d24.c,"The function takes four parameters - two integers, a pointer to an array of integers, and another integer. It calculates the number of bits in the second parameter and allocates memory for an array of integers to store the positions of the set bits in the second parameter. It then extracts the set bit positions from the second parameter and stores them in the allocated array. The function sets the most significant bit of the allocated array to 1 if the array is not already full. It initializes a BN_CTX object and uses it to compute the square root of the second parameter modulo the first parameter, using the set bit positions in the allocated array as the exponents in the exponentiation operation. Finally, the function frees the allocated memory and returns the result of the computation. If the computation fails, the function returns 0 and sets an error code."
openssl-101f,O1,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_GF2m_mod_sqr_arr@006248a0.c,"The function BN_GF2m_mod_sqr_arr computes the square of a binary polynomial represented as an array of integers modulo a binary irreducible polynomial. The input parameters include a pointer to the output array where the result will be stored, a pointer to an array of integers representing the input polynomial, a pointer to an integer representing the degree of the input polynomial, and a pointer to a BN_CTX structure used for temporary storage. The function initializes the BN_CTX structure, allocates memory for a temporary array, and expands the size of the temporary array if necessary. It then performs the computation of the square of the input polynomial using the SQR_tb lookup table and stores the result in the output array."
openssl-101f,O1,mips,BN_kronecker,./data/decomp/openssl-101f_mips_gcc_O1_extraction/BN_kronecker@00623300.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs a and b using the algorithm described in the book ""Handbook of Applied Cryptography"" by Menezes, van Oorschot and Vanstone. The function initializes a BN_CTX object, creates two uint ** pointers ppuVar3 and ppuVar4 and copies the values of a and b into them using the function PTR_BN_copy. If copying fails, the function returns -2. It then checks if b is even or if a and b are equal. If either of these conditions is true, the function returns 0. If b is 1, the function returns 1. The function calculates the value of the Kronecker symbol using a loop by checking if b is even and removing any factors of 2."
openssl-101f,O1,mips,by_dir_entry_free,./data/decomp/openssl-101f_mips_gcc_O1_extraction/by_dir_entry_free@00587a40.c,"The function takes in a pointer to an integer array as its parameter. It checks if the first and third elements of the array are not equal to 0. If they are not, it calls memory deallocation functions for cryptographic data structures and a stack of cryptographic data structures. It then deallocates the memory for the entire integer array and treats an indirect jump as a call."
openssl-101f,O1,mips,cswift_rand_bytes,./data/decomp/openssl-101f_mips_gcc_O1_extraction/cswift_rand_bytes@005d2070.c,"These are summaries of functions related to cryptographic operations using various libraries. Some of the functions generate random bytes, perform Diffie-Hellman key exchange, handle memory allocation and deallocation, perform modular exponentiation using the Chinese Remainder Theorem, perform RSA modular exponentiation, encrypt and decrypt data, perform DSA signature operations, generate and verify signatures, and perform RSA encryption using the CryptoSwift hardware engine. The functions also handle errors and set error codes and messages accordingly. Some of the functions are decompiled versions of functions from various libraries."
openssl-101f,O1,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_mips_gcc_O1_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061cce0.c,The function calls an unknown function through a pointer stored in a global variable to convert a GOST client key exchange parameter from its ASN.1 DER encoding to an internal representation. The specifics of this conversion process cannot be determined due to the unknown function being called.
openssl-101f,O1,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_mips_gcc_O1_extraction/d2i_GOST_KEY_PARAMS@0061cc20.c,"The function uses a global pointer to call an unknown function, possibly related to converting ASN.1 data to GOST key parameters, before returning without any further actions."
openssl-101f,O1,mips,decode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O1_extraction/decode_gost_algor_params@00619aac.c,"The function `decode_gost_algor_params` takes two parameters `param_1` and `param_2`. It extracts parameters from `param_2` using `X509_ALGOR_get0` and checks if the length is 16 bytes. If it is, it determines the type of GOST algorithm using `OBJ_obj2nid` and calls the appropriate function (`fill_GOST2001_params` or `fill_GOST94_params`) to fill in the key parameters. If the GOST algorithm is of type 0x32b (GOST R 34.10-2001), it assigns the resulting parameters to the `EVP_PKEY` object pointed to by `param_1`.

The function is an implementation of the OpenSSL GOST engine for elliptic curve cryptography. It takes an EVP_PKEY object as input and checks if the key is valid and if it is a GOST key. If it is valid, it checks if it is a private key and computes the corresponding public key and sets it in the EVP_PKEY object. If it is a public key, it checks if the curve parameters are available and sets them in the EVP_PKEY object. The function returns 1 if the operation is successful and 0 otherwise."
openssl-101f,O1,mips,DES_xcbc_encrypt,./data/decomp/openssl-101f_mips_gcc_O1_extraction/DES_xcbc_encrypt@00622220.c,"The following functions implement encryption algorithms:
- DES-XCBC encryption algorithm: takes in an input buffer, output buffer, length of input buffer, a DES key schedule, an initialization vector, input and output whitening values, and a flag indicating whether to encrypt or decrypt. If flag is set to encrypt, the function performs certain steps, and if it is set to decrypt, it performs the same steps in reverse order.
- AES encryption algorithm using a 128-bit key: takes in an input buffer, output buffer, length, and an initialization vector (IV). It sets up the AES key schedule using the input key, processes the input buffer in 128-bit blocks, XORs each block with the previous block's encrypted output (or the IV for the first block), encrypts the result using the AES algorithm, and writes the encrypted output to the output buffer. The IV is updated to be the encrypted output of the last block. If the input length is not a multiple of 128 bits, the function pads the input with zeros to make it a multiple of 128 bits. The function also allows for the input and output buffers to be unaligned, and handles the padding and unaligned cases accordingly.
- AES encryption algorithm using input key and plaintext: generates a key schedule using the input key and uses it to perform encryption on the plaintext. The plaintext is divided into blocks of 128 bits (16 bytes), and each block is encrypted using the AES algorithm. The function uses a loop to encrypt each block of the plaintext. Inside the loop, it first XORs the input block with the previous block (or the IV if it is the first block), and then performs a series of AES rounds on the result using the key schedule. Finally, it XORs the output of the AES rounds with the previous block (or IV) to produce the encrypted block. At the end of the loop, the function updates the IV to be the last encrypted block and continues with the next block until all blocks have been encrypted. The function then returns the encrypted ciphertext.
- OFB (Output Feedback) mode of the Blowfish encryption algorithm: takes in an input plaintext and encrypts it using the Blowfish algorithm in OFB mode with a given key and initialization vector. The encrypted output is stored in the same input buffer. The function generates keystream blocks and XORs them with the input plaintext blocks to generate the output ciphertext blocks. The function also handles cases where the input buffer size is not"
openssl-101f,O1,mips,dgram_ctrl,./data/decomp/openssl-101f_mips_gcc_O1_extraction/dgram_ctrl@0052cd98.c,"The first function, `dgram_ctrl`, takes in four parameters and performs different actions based on the value of `param_2`. It retrieves or sets values in `param_1` and enters another switch statement for certain cases.

The second function appears to be a handler for various BIO control commands. It takes in a BIO object, a command code, and other arguments depending on the command. It uses a switch statement to determine the command and performs different actions, including manipulating the BIO's internal data structure and calling external functions.

The third function is a part of the OpenSSL library and performs I/O operations on a BIO object. It takes in a pointer to a BIO object, a buffer, and the buffer's size. It checks for pending data, sets the BIO object to non-blocking mode, reads data from the socket, and calls a callback function if set. It also checks for errors and returns an error code if necessary."
openssl-101f,O1,mips,dlfcn_bind_func,./data/decomp/openssl-101f_mips_gcc_O1_extraction/dlfcn_bind_func@00629ea4.c,"The function takes two integer parameters, param_1 and param_2. If either parameter is equal to 0, it sets two variables, uVar2 and uVar3, to specific values (0x43 and 0x110, respectively). If both parameters are non-zero, the function calls a function at the address stored in PTR_sk_num_006a7f2c, passing in the value stored at the memory address (param_1 + 4) as an argument. The result of this function call is stored in the variable iVar1. If iVar1 is less than 1, the function sets uVar2 and uVar3 to specific values (0x69 and 0x115, respectively). If iVar1 is greater than or equal to 1, the function retrieves a value from the memory address (param_1 + 4) and calls a function at the address stored in PTR."
openssl-101f,O1,mips,dlfcn_bind_var,./data/decomp/openssl-101f_mips_gcc_O1_extraction/dlfcn_bind_var@0062a018.c,"The function dlfcn_bind_var takes two integer parameters, param_1 and param_2. If either parameter is equal to 0, it sets uVar2 to 0x43 and uVar3 to 0xee. If both parameters are non-zero, it calls the function sk_num_006a7f2c with the value stored at address (param_1 + 4) and stores the result in iVar1. If the result is less than 1, it sets uVar2 to 0x69 and uVar3 to 0xf3. Otherwise, it retrieves the value stored at address (param_1 + 4) and calls sk_value_006a7f24 with this value and (iVar1 - 1) as parameters. It then checks if the result of this call is non-zero, and if so, it calls dlsym_006aab18 with the retrieved value and param_2 as parameters."
openssl-101f,O1,mips,dlfcn_globallookup,./data/decomp/openssl-101f_mips_gcc_O1_extraction/dlfcn_globallookup@00629a60.c,"The function uses dynamic linking library (dlfcn) to search for a symbol by name. It takes one argument, the name of the symbol to search for. It first opens the dynamic library using dlopen with a flag of 1 to load it into the global symbol table. If dlopen returns 0, the function returns 0. If it succeeds, it uses dlsym to search for the symbol by name within the library. If found, dlsym returns a pointer to the symbol's address. If not found, it returns NULL. The function then calls dlclose to close the library and returns the pointer to the symbol's address if found, or 0 if not found."
openssl-101f,O1,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_mont_field_encode@00627d3c.c,"The function takes four parameters: param_1, param_2, param_3, and param_4. It retrieves the value at offset 0xa0 from the memory location pointed to by param_1 and stores it in the variable iVar1. If iVar1 is not equal to zero, the function calls a function at the memory location pointed to by PTR_BN_mod_mul_montgomery_006a9674 with param_2, param_3, iVar1 + 4, iVar1, and param_4 as its arguments. The result of this function call is stored in the variable uVar2, which is then returned by the function. If iVar1 is equal to zero, the function calls a function at the memory location pointed to by PTR_ERR_put_error_006a9030 with the arguments 0x10, 0x86, 0x6f, ""ecp_mont.c"", and 0x124, and then returns."
openssl-101f,O1,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_mont_field_sqr@00627cc4.c,"The function takes a pointer to a data structure representing an elliptic curve point on a Montgomery curve, and checks if a certain field in the data structure is non-zero. If the field is non-zero, it calls a multiplication function using Montgomery multiplication with the second and third parameters as inputs and the fourth parameter as a modulus. If the field is zero, it calls an error function and returns 0. The function returns the result of the multiplication function call or 0 if an error occurred."
openssl-101f,O1,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_mont_group_init@006277b0.c,"The function initializes a Montgomery elliptic curve group by calling the ec_GFp_simple_group_init() function to initialize the underlying simple elliptic curve group. It sets two variables in the Montgomery group structure to 0, which are used to store the Montgomery parameters used in scalar multiplication operations. The function then returns."
openssl-101f,O1,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_nist_field_mul@0062815c.c,"The function takes in five integer parameters. It first checks if any of the first four parameters are equal to zero, and if so, it calls a function to put an error message and exit. If the fifth parameter is zero, it creates a new BN_CTX object and uses it to multiply the second and third parameters (which are assumed to be BIGNUMs) and store the result in the fourth parameter. It then squares the result using the first parameter (which is assumed to be an EC_GROUP object) and the group's field, and returns true if the operation was successful. If the fifth parameter is not zero, it simply multiplies the second and third parameters and stores the result in the fourth parameter. It then squares the result using the first parameter and the group's field, and returns true if the operation was successful. If any of the BN functions fail, the function returns false."
openssl-101f,O1,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_nist_group_copy@00627ea0.c,"The `ec_GFp_nist_group_copy` function copies a specific member variable from one elliptic curve group structure to another, and then copies the rest of the group structure using the `ec_GFp_simple_group_copy` function. The function takes two parameters, `param_1` and `param_2`, which are pointers to the group structures. The function returns after the copying is complete."
openssl-101f,O1,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_nist_group_set_curve@00627eb8.c,"The function ec_GFp_nist_group_set_curve sets the curve parameters for a group using a NIST prime. It takes in four parameters - param_1, param_2, param_3, and param_4 - which are used to set the group's curve. If param_5 is 0, a new BN_CTX object is created and its memory is allocated. If param_5 is not 0, then the memory for the existing BN_CTX object is used. The function then checks if the curve is a NIST prime of size 192, 224, 256, 384, or 521 bits and sets the appropriate modulus value for the group. Finally, the function calls the ec_GFp_simple_group_set_curve function to set the curve parameters for the group. If any errors occur during the function's execution, an error message is printed and the function returns 0."
openssl-101f,O1,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062e000.c,"The function takes six integer parameters and returns a boolean value. It checks if the elliptic curve parameters stored in the memory location pointed to by the first parameter have J-projective coordinates. If they do not, it checks if the second and third parameters are non-zero and copies their values to the memory locations pointed to by the third and fourth parameters, respectively. If the fourth parameter is non-zero, it copies the value of the fifth parameter to the memory location pointed to by the fifth parameter and returns true. If the elliptic curve parameters have J-projective coordinates, it creates a new BN_CTX object and assigns its value to the sixth parameter. It then uses the elliptic curve parameters and the BN_CTX object to compute the J-projective coordinates of the curve and copies the results to the memory locations pointed to by the third, fourth, and fifth parameters. It returns true if all the computations were successful and false otherwise. If a BN_CTX object was created, it is freed before returning."
openssl-101f,O1,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_group_check_discriminant@0062e1ec.c,"The function takes in an integer array and an integer value, and returns a boolean value. It checks if the second parameter is 0 and initializes a new BN_CTX object if it is. It creates five new integer variables using the BN_CTX object. If the fifth integer variable is not 0, it checks if the curve has a custom discriminant calculation function. If it does not, it calculates the discriminant using the formula (4*a^3 + 27*b^2) mod p, where a and b are curve parameters and p is the prime modulus. If the curve has a custom discriminant calculation function, it calls that function to calculate the discriminant. The function then checks if the discriminant is non-zero and calculates accordingly."
openssl-101f,O1,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_group_clear_finish@0062db04.c,The function takes an integer parameter representing an elliptic curve group and frees the memory used by the group by calling a function with arguments that are likely pointers to big numbers used by the group.
openssl-101f,O1,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_group_copy@0062f054.c,"The function copies values from a simple elliptic curve group from one variable to another. It uses BN_copy function three times to copy values of three BigIntegers and a single 4-byte value from the source variable to the destination variable. If any of the BN_copy calls fail, the function returns 0. Otherwise, it returns 1."
openssl-101f,O1,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_group_get_degree@0062dbb4.c,"The function takes an integer parameter, adds 0x48 to it, and calls a function located at PTR_BN_num_bits_006a82f4 with the result as an argument. The called function likely calculates the number of bits in the integer using the BN library. The function then returns without using the result of the called function."
openssl-101f,O1,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_group_set_curve@0062f194.c,"This function sets the curve for a simple elliptic curve group over a finite field. It takes in several parameters including pointers to the curve parameters, the field parameters, and the size of the field. The function first checks that the parameters are valid, including checking that the number of bits in the field is greater than 3, that the field size is positive, and that the field is odd. If any of these conditions are not met, the function returns 0. If the parameters are valid, the function initializes a new BN_CTX object and copies the field parameters into a local variable. It then sets the sign of the field parameter to be non-negative. Next, the function calculates the modulus of the field parameter with respect to the curve parameter and stores the result in a local variable. It then checks if there is a callback function defined for the curve, and if so, calls it with the curve and field parameters. If the callback function returns an error, the function returns 0."
openssl-101f,O1,mips,ec_GFp_simple_invert,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_invert@00630104.c,"The function takes two parameters, param_1 and param_2. It first calls a function at address PTR_EC_POINT_is_at_infinity_006a9770 to check if a point on an elliptic curve is at infinity. If it is not at infinity and the value at offset 0x1c of param_2 is not zero, it calls a function at address PTR_BN_usub_006a96d4 to perform a subtraction operation between the value at offset 0x18 of param_2 and the value at offset 0x48 of param_1. The result of this operation is then returned. If the point is at infinity or the value at offset 0x1c of param_2 is zero, the function returns 1."
openssl-101f,O1,mips,EC_GFp_simple_method,./data/decomp/openssl-101f_mips_gcc_O1_extraction/EC_GFp_simple_method@00630f54.c,"The function EC_GFp_simple_method returns a pointer to an EC_METHOD structure, but the decompiler is unable to determine the calling convention used and warns the user. The actual implementation is not shown in the decompiled code, and instead, it returns a pointer to a variable named ret_6955."
openssl-101f,O1,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_point_copy@0062f0f4.c,"The function copies the x, y, and z coordinates and a flag value from one elliptic curve point structure to another. It takes two parameters, pointers to the source and destination structures, and returns 1 if the copy is successful and 0 otherwise."
openssl-101f,O1,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_point_finish@0062dab0.c,"The function takes an integer parameter (param_1) and frees memory allocated for an elliptic curve point in the GF(p) field. It calls a function at the memory address pointed to by PTR_BN_free_006a811c twice, passing in different arguments each time. It then jumps to a memory address pointed to by a table at 0x0062dafc and calls the function pointed to by the value at memory address (param_1 + 0x2c) as an argument before returning from the function."
openssl-101f,O1,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_point_get_affine_coordinates@0062e4f0.c,"The function takes five parameters, four integers and a pointer to a structure, and returns a boolean value. It first checks if the point is at infinity using a function at a specific address. If it is, an error message is printed and the function returns false. If not, it checks if the fifth parameter is zero. If it is, it allocates memory for a BN_CTX structure and starts the context. It then gets four integers from the context and stores them in variables. If the fifth parameter is not zero, the function assumes it is a pointer to a structure."
openssl-101f,O1,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O1_extraction/ec_GFp_simple_point_set_affine_coordinates@0062f494.c,"The function takes in five parameters: param_1, param_2, param_3, param_4, and param_5. If param_3 and param_4 are both non-zero, it calls two other functions with param_1, param_2, param_3, param_4, and a value of 1. The return value of the second function call is then returned by the current function. If either param_3 or param_4 is zero, the function calls another function with some error codes and returns 0."
openssl-101f,O1,mips,encode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O1_extraction/encode_gost_algor_params@0061b110.c,"The functions relate to encoding, decoding, and printing keys for the GOST algorithm in OpenSSL. 

The function `encode_gost_algor_params` takes a pointer to an EVP_PKEY structure as input and encodes the GOST algorithm parameters into a byte array. It then creates a GOST context, sets the algorithm parameters using the encoded byte array, generates a random key, encrypts the input data using the GOST algorithm and the generated key, and returns the encrypted data as a byte array. If any errors occur, it sets an error message and returns NULL.

The decompiled function related to encoding and decoding the GOST algorithm takes in several parameters, including a pointer to an EVP_PKEY structure. It extracts the algorithm parameters, retrieves the base ID of the EVP_PKEY structure, and encodes the private key using the GOST algorithm. It also prints out information about the private key. The function returns a pointer to an integer value indicating the success or failure of the operation.

The decompiled function implementing the key printing functionality for the GOST algorithm takes a pointer to an EVP_PKEY structure as input and prints out the private and public keys, as well as the parameter set used for the key generation. It first checks if the input pointer is NULL and returns an error if it is. Then, it checks if the key type is supported by the GOST algorithm and returns an error if it is not. If the key type is supported, it retrieves the private and public keys from the EVP_PKEY structure and prints them out using the BN_print function. It also prints out the parameter set used for the key generation by retrieving the curve name from the EC_GROUP structure. Finally, it returns a pointer to an integer value indicating success or failure of the key printing operation."
openssl-101f,O1,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_mips_gcc_O1_extraction/general_allocate_boolean.constprop.5@005b32bc.c,"The function takes in eight parameters, including an integer pointer and a character pointer. It first checks if the character pointer is null, and if it is, it returns an error code. Otherwise, it checks if the length of the character string is non-zero and if all characters are valid. If any character is invalid, it returns an error code. If the character string is valid, it checks if another parameter is non-zero and allocates memory for an integer array of size 8. It sets some values in this array based on the input parameters and then checks if another integer pointer is null. If it is not null, it pushes the integer array onto the integer stack pointed to by the integer pointer and returns the index of the pushed element minus one. If the integer pointer is null, it returns an error code."
openssl-101f,O1,mips,get_gost_engine_param,./data/decomp/openssl-101f_mips_gcc_O1_extraction/get_gost_engine_param@0061ee48.c,"The function takes an integer parameter and returns an integer value. If the parameter is 0, it checks if the global variable ""gost_params"" is set to a non-zero value. If it is, it returns the value of ""gost_params"". If not, it gets the value of the environment variable ""CRYPT_PARAMS"" using the function ""getenv"" and stores it in ""gost_params"" after duplicating it using the function ""strdup"". If the environment variable is not set, it returns 0. If the parameter is not 0, it simply returns 0."
openssl-101f,O1,mips,gost2001_param_encode,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost2001_param_encode@0061a1d4.c,"The ""gost2001_param_encode"" function encodes a parameter using the GOST 2001 algorithm. It retrieves a key using ""PTR_EVP_PKEY_get0_006aa6e4"" and the group using ""PTR_EC_KEY_get0_group_006a8780"". It then gets the curve name using ""PTR_EC_GROUP_get_curve_name_006a9110"" and the object ID (OID) of the curve using ""PTR_OBJ_nid2obj_006a8240"". Finally, it encodes the parameter using ""PTR_i2d_ASN1_OBJECT_006aa970"". A warning message about the jumptable is present."
openssl-101f,O1,mips,gost_cipher_cleanup,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost_cipher_cleanup@0061cfe0.c,"The function takes an integer parameter (param_1) and performs the following operations: It calls the gost_destroy function with the argument *(int *)(param_1 + 0x60) + 0xc, sets the value at memory address (param_1 + 0x54) to 0, and returns the value 1. The gost_cipher_cleanup function is likely used to clean up and free any resources used by the GOST cipher algorithm."
openssl-101f,O1,mips,gost_cipher_ctl,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost_cipher_ctl@0061d874.c,"The function takes four parameters: two integers, an undefined value, and a pointer to an undefined value. If the second parameter is equal to 6, it calls a function at address PTR_RAND_bytes_006a8d44 with specific parameters and checks the return value. If it is less than 1, it calls the ERR_GOST_error function and sets uVar2 to 0xffffffff. Otherwise, it sets uVar2 to 1. If the second parameter is equal to 7, it checks if the fourth parameter is not equal to NULL and sets the value at the memory location pointed to."
openssl-101f,O1,mips,gost_cipher_do_cnt,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost_cipher_do_cnt@0061d1dc.c,"The first function, `gost_cipher_do_cnt`, is a part of the GOST block cipher algorithm implementation. It takes four parameters: a pointer to the cipher context, an output buffer byte array, an input buffer byte array, and the length of the input buffer. The function generates a keystream and XORs it with the input buffer to store the result in the output buffer.

The second function takes four parameters: three byte array pointers and an integer. It sets values for bytes in the second byte array based on the value of the fourth parameter. If the fourth parameter is less than or equal to a certain value, the function sets a value for the corresponding byte in the second byte array and returns 1."
openssl-101f,O1,mips,gost_cipher_init,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost_cipher_init@0061ea98.c,"1. Check if the cipher has been initialized. If not, initialize it with either the engine's parameters or the default parameters from the cipher list. If an initialization vector is provided, copy it to the context and the IV buffer in the context. Return 1 if initialization is successful."
openssl-101f,O1,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O1_extraction/GOST_CIPHER_PARAMS_new@0061ccb0.c,The function creates a new instance of the GOST_CIPHER_PARAMS data structure using the ASN1_item_new function with the GOST_CIPHER_PARAMS_it parameter and returns the newly created instance.
openssl-101f,O1,mips,gost_imit_final,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost_imit_final@0061e800.c,"The function `gost_imit_final` takes two parameters, `param_1` and `param_2`. It retrieves the value of `iVar4` from the memory address `param_1 + 0xc`. It checks if the value of `iVar4 + 0x103c` is equal to 0. If it is, it calls the `ERR_GOST_error` function and jumps to `LAB_0061e87c`. If `iVar4 + 0x103c` is not equal to 0, the function retrieves the value of `unaff_s1` from the memory address `iVar4 + 0x1038`. If the value of `iVar4 + 0x1030` is equal to 0, the function checks if `unaff_s1` is not equal to 0. If it is not equal to 0, it initializes the variables `local_2c` and `local`."
openssl-101f,O1,mips,gost_imit_init_cpa,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost_imit_init_cpa@0061d7ec.c,"The function initializes parameters for the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A, sets various values to 0, and sets a flag to 1. It calls the gost_init function with the initialized parameters, the CryptoPro parameter set A, and some additional parameters. The function returns a value of 1."
openssl-101f,O1,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O1_extraction/GOST_KEY_PARAMS_new@0061cc50.c,The function creates a new GOST_KEY_PARAMS object using the ASN1_item_new function. It retrieves the pointer to the GOST_KEY_PARAMS_it structure and calls the ASN1_item_new function with this pointer as the argument. The function does not return anything.
openssl-101f,O1,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_mips_gcc_O1_extraction/GOST_KEY_TRANSPORT_free@0061cb48.c,The function frees memory allocated to a GOST_KEY_TRANSPORT object by calling another function to deallocate the memory. It takes in a memory address parameter and a reference to the GOST_KEY_TRANSPORT_it object. The function then returns.
openssl-101f,O1,mips,gost_param_free,./data/decomp/openssl-101f_mips_gcc_O1_extraction/gost_param_free@0061ed70.c,"The function checks if a global variable ""gost_params"" is not equal to 0. If it is not 0, it frees the memory allocated to ""gost_params"" using a function pointer and sets ""gost_params"" to 0 before returning."
openssl-101f,O1,mips,hash_step,./data/decomp/openssl-101f_mips_gcc_O1_extraction/hash_step@0061ef50.c,"The first function takes in an unsigned integer and two pointers to unsigned integers. It performs XOR operations on the values at the pointers and stores the result in local variables. It then performs bitwise operations on the local variables and the values pointed to by the second parameter, passes the result to a function called ""gost_enc_with_key"", performs more bitwise operations, and returns the result.

The second function takes in two pointers to arrays of integers and performs a series of bitwise operations on the arrays using shift and bitwise OR operators. It stores the results in local variables and performs additional bitwise operations on these variables to generate new values. Finally, it stores these new values in a series of local variables using bitwise shift and OR operations.

The third function takes in a pointer to a byte array and an integer and performs a series of bitwise operations on the data in the byte array using the GOST encryption algorithm. It calls the GOST encryption function with various variables as input, performs further bitwise operations on the encrypted data, and calls the GOST encryption function again with the modified data before returning the result.

The fourth function performs a GOST encryption algorithm on the input data using a specified key. It performs bitwise operations on the input data and key, uses a loop to perform multiple XOR operations on the data using the key, XORs the result with the key again, and returns the encrypted data. It also includes memory management code to allocate and free memory for the encrypted data.

The fifth function checks if a local variable is not equal to the value pointed to by a pointer. If they are not equal, it sets variables to certain values, calls two functions, allocates memory, and calls a function called ""gost_init"". It then returns a value."
openssl-101f,O1,mips,hwcrhk_init,./data/decomp/openssl-101f_mips_gcc_O1_extraction/hwcrhk_init@005d6a80.c,"The `hwcrhk_init()` function initializes the HWCryptoHook library by loading and binding its functions. It also sets global function pointers and initializes mutex functions if necessary. Additionally, it creates an RSA key handle if one does not already exist. If any errors occur during the initialization process, the function exits."
openssl-101f,O1,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_mips_gcc_O1_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061cbd8.c,The i2d_GOST_KEY_AGREEMENT_INFO function takes two undefined4 parameters and uses a jumptable to call a code pointer at PTR_ASN1_item_i2d_006a979c. This function converts a GOST key agreement info structure from internal format to DER encoded format for transmission over a network or storage in a file. No value is returned.
openssl-101f,O1,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_mips_gcc_O1_extraction/i2d_GOST_KEY_TRANSPORT@0061cb18.c,"The i2d_GOST_KEY_TRANSPORT function takes two parameters of type undefined4 and converts a GOST key transport structure to its ASN.1 DER encoding. It jumps to an address stored in PTR_ASN1_item_i2d_006a979c, assumed to be a code pointer, and calls it with the parameters param_1, param_2, and GOST_KEY_TRANSPORT_it."
openssl-101f,O1,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101f_mips_gcc_O1_extraction/load_pkcs12.constprop.4@004592d8.c,"The function loads a PKCS12 file using a file pointer and verifies the MAC of the file using a password or callback function. It returns 0 if the MAC verification fails and parses the PKCS12 file if it succeeds, returning the type of the PKCS12 file. Stack overflow attacks are prevented."
openssl-101f,O1,mips,param_copy_gost94,./data/decomp/openssl-101f_mips_gcc_O1_extraction/param_copy_gost94@0061a670.c,"The function takes in two parameters of type undefined4 and returns an undefined4 value. It gets the base id and pointer of each parameter using external functions. If the base ids of the parameters are not the same, an error is thrown and the function returns 0. If the second parameter has a null pointer, an error is thrown and the function returns 0. If the first parameter has a null pointer, a new DSA object is created and assigned to the first parameter using the base id of the second parameter. The function duplicates the values of three variables from the second parameter to the first parameter using external functions, and computes the public key if necessary. Finally, the function returns 1 if successful or an error code if not."
openssl-101f,O1,mips,param_print_gost01,./data/decomp/openssl-101f_mips_gcc_O1_extraction/param_print_gost01@0061abe4.c,"The function takes in three parameters: param_1, param_2, and param_3. It calls multiple functions at different addresses and stores the results in uVar1 and iVar2. If iVar2 is not equal to 0, it calls another function at a specific address."
openssl-101f,O1,mips,param_print_gost94,./data/decomp/openssl-101f_mips_gcc_O1_extraction/param_print_gost94@0061ac98.c,"The functions are related to cryptography and OpenSSL. 
- One function takes in three parameters, retrieves values from memory, and performs cryptographic operations. 
- Another function decrypts ciphertext using a private key and GOST algorithm, while also handling errors and memory management. 
- A third function implements the GOST algorithm in OpenSSL, with specific actions depending on input parameters. 
- A fourth function verifies a digital signature against a message using a private key and GOST algorithm. 
- The fifth function prints information about a GOST key using OpenSSL functions, and handles errors."
openssl-101f,O1,mips,pkey_ctrl_gost,./data/decomp/openssl-101f_mips_gcc_O1_extraction/pkey_ctrl_gost@0061b6d4.c,"These functions all involve operations related to cryptography and encryption. 

The first function appears to be a control function for GOST encryption keys, taking in four parameters and performing different operations based on the value of the second parameter. It sets up local variables and calls other functions to encode and set specific values in the output parameters. 

The second function performs operations related to encoding and printing a GOST private key, initializing variables and pointers, retrieving and processing information about the key, formatting and printing the private and public keys, and performing cryptographic operations related to the key. 

The third function takes a pointer to an EVP_PKEY structure as input, checks if there is an EC_KEY structure associated with it, extracts the public key and prints it out along with the curve parameters. If any errors occur during the extraction or printing process, it returns 0, otherwise it returns 1."
openssl-101f,O1,mips,pkey_free_gost94,./data/decomp/openssl-101f_mips_gcc_O1_extraction/pkey_free_gost94@0061abc0.c,"The function takes an integer parameter (param_1) and checks if the value stored at offset 0x14 of the memory location pointed to by param_1 is not equal to zero. If it is not zero, it jumps to an unknown function (whose address is stored in PTR_DSA_free_006a862c) using an indirect jump. If it is zero, the function simply returns. The purpose of this function is to free memory associated with a GOST 94 public key."
openssl-101f,O1,mips,priv_encode_gost,./data/decomp/openssl-101f_mips_gcc_O1_extraction/priv_encode_gost@0061bb14.c,"The first function takes in two 4-byte integers and a character pointer, retrieves the ID and object of a given key, encodes the GOST algorithm parameters, retrieves and encodes the private key value, sets the private key value in the PKCS#8 format, and returns the result. If the encoding of the algorithm parameters was not successful, it sets the private key value to zero and prints the private and public key values to the standard output. It also retrieves the parameter set and calculates the affine coordinates of the public key value. If the function encounters an error, it sets the return value to zero and frees any allocated memory before returning.

The second function is a part of the OpenSSL library and is responsible for printing the details of a GOST key pair in a human-readable format. It takes a pointer to an EVP_PKEY structure as input, which contains the GOST key pair, and a pointer to a BIO structure, which is used for printing the output. The function first checks if the input EVP_PKEY structure contains a GOST key pair by checking its type. If it is not a GOST key pair, the function returns 0. If the input is a GOST key pair, the function extracts the public key and the private key from the EVP_PKEY structure and prints them using the BIO structure. It also prints the name of the parameter set used for generating the key pair. If any error occurs during the execution of the function, it prints an error message and returns 0. Otherwise, it returns 1."
openssl-101f,O1,mips,pub_encode_gost94,./data/decomp/openssl-101f_mips_gcc_O1_extraction/pub_encode_gost94@0061b904.c,"The first function, `pub_encode_gost94`, encodes a GOST 94 public key by retrieving algorithm parameters, calculating the size of the encoded key, allocating memory for it, and encoding it using `encode_gost_algor_params`. It returns the size of the encoded key if successful, otherwise 0. It also includes error checking and memory allocation functions.

The second function is a C implementation that prints out the details of a GOST elliptic curve key. It checks if the key is of type EVP_PKEY_EC, gets the EC_KEY structure, and prints out the private key if available. If not, it prints ""<undefined>"". It also prints out the public key and the parameter set used by the key."
openssl-101f,O1,mips,pub_print_gost94,./data/decomp/openssl-101f_mips_gcc_O1_extraction/pub_print_gost94@0061ae00.c,"1. The function takes in three parameters, gets values from one of the parameters, performs operations, encodes data, and returns either a pointer to an integer or NULL.
2. The function generates GOST algorithm parameters for encryption and decryption using the OpenSSL library by taking in an EVP_PKEY object and returning a pointer to an ASN1 string containing the parameters.
3. The function encodes and decodes GOST keys by taking in various parameters and performing operations such as error checking and encoding.
4. The function encodes and prints a private key in the GOST algorithm by performing calculations, encoding parameters, retrieving and printing keys, and comparing them to a set of parameters.
5. The function encrypts a buffer using the OpenSSL GOST asymmetric encryption algorithm by taking in a public key, a buffer to encrypt, and the length of the buffer, and returning the encrypted buffer while also performing error handling."
openssl-101f,O1,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O1_extraction/RSA_padding_add_PKCS1_PSS@00628ef8.c,"These are two separate functions:

1. The first function adds PKCS1 PSS padding to a given message hash using the RSA algorithm. It takes as input a pointer to an RSA key, a pointer to the output buffer EM, a pointer to the message hash mHash, a pointer to the hash function Hash, and the length of the salt sLen. The function generates a random salt of length sLen, concatenates it with the message hash, and applies the PKCS1 MGF1 mask generation function to the result. The masked data is then concatenated with the salt and other padding bytes to form the final padded message.

2. The second function is an implementation of the RSA-OAEP encryption scheme. It takes as input a message M, a public key (n, e), and a random seed. It first generates a random padding string P, and then hashes the concatenation of P and M using a specified hash function. The resulting hash is then XORed with a masked seed value generated by hashing the random seed concatenated with a fixed string. The resulting XORed value is then concatenated with the masked padding string generated by XORing the hash of the masked seed with the padding string. Finally, the resulting concatenated value is encrypted using the RSA public key and returned as the ciphertext. The function also includes some additional logic for handling edge cases and error conditions."
openssl-101f,O1,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O1_extraction/RSA_verify_PKCS1_PSS@00628440.c,"The functions RSA_verify_PKCS1_PSS and RSA PSS signature verification algorithm are used to verify a signature using the RSA public key algorithm with the PKCS1 PSS padding scheme. They take in several parameters including the RSA public key, a message hash, a hash function, the signature to be verified, and the length of the signature. 

Both functions initialize an EVP_MD context and get the size of the hash function output. They also check if the signature length is valid and calculate the number of padding bits in the signature. They perform the PKCS1 PSS decoding process by generating a mask from the signature using the MGF1 function and XORing it with the original message. They check if the first byte of the resulting message is zero and remove it if necessary. They then check if the resulting message has the correct number of padding bits and extract the original message hash from it. 

The RSA PSS signature verification algorithm additionally initializes an EVP_MD_CTX context structure and sets it up for the RSA PSS algorithm. It extracts the modulus and exponent from the public key and sets up an RSA structure with those values. It calculates the length of the modulus and checks that the length of the signature is less than or equal to that length. If not, it returns an error. It performs the RSA decryption operation on the signature using the public key. If the decryption fails, an error is returned. It then checks the padding of the decrypted signature, verifying that it is indeed a PSS signature. If the padding check fails, an error is returned. Finally, if all checks pass, the function returns a success value. If any errors occur, the function returns an appropriate error code."
openssl-101f,O1,mips,sha_block_data_order,./data/decomp/openssl-101f_mips_gcc_O1_extraction/sha_block_data_order@00620b30.c,"These functions perform cryptographic operations on input values to generate hash values or new output blocks. They use a series of bitwise operations, including shifting, XORing, ANDing, and ORing, to manipulate the input data and generate intermediate values. The specific algorithms used vary between functions, but all involve iterating over blocks of input data and updating intermediate values to produce a final output value. Some functions take in additional parameters, such as a key or length of the input array. The purpose and specific details of these functions may require additional context or information."
openssl-101f,O1,mips,SHA_Final,./data/decomp/openssl-101f_mips_gcc_O1_extraction/SHA_Final@00621fdc.c,"The SHA_Final function is the final step in the SHA-1 hashing algorithm. It takes in a message digest (md) and a SHA context (c) as input. The function sets the 9th bit of the data array in the context to 1, and pads the rest of the array with zeros until it reaches the end of a block. If the context has more than one block, it processes the remaining blocks before padding. Next, the function sets the last 64 bits of the data array to the total number of bits in the message. It then processes the final block of data. After the final block is processed, the function sets the context's ""num"" variable to 0 and clears the data array. Finally, it sets the message digest to the five 32-bit words in the context's ""h0"" through ""h4"" variables."
openssl-101f,O1,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_mips_gcc_O1_extraction/SSL_SESSION_free.part.2@004b0e94.c,"The function frees the memory allocated for an SSL session object by first freeing any additional data associated with the object using CRYPTO_free_ex_data(). It then cleanses sensitive data stored within the object using OPENSSL_cleanse(). Next, it frees any memory allocated for the session's certificate, private key, and peer certificate chain using various OpenSSL functions. It also frees any memory allocated for session ticket and session ID using CRYPTO_free(). Finally, it cleanses the entire session object using OPENSSL_cleanse() and frees the memory using CRYPTO_free()."
openssl-101f,O1,mips,start_hash,./data/decomp/openssl-101f_mips_gcc_O1_extraction/start_hash@0061feb8.c,"The function takes in a pointer to an array of four 32-bit integers as its parameter. It checks if the third element of the array is not equal to zero. If it is not zero, it sets the fourth element and the twelfth element of the array to zero using the memset function. It also sets the third element, the first element, and the zeroth element of the array to zero. Finally, it returns 1 to indicate that the operation was successful. If the third element of the array is equal to zero, it simply returns 0 to indicate failure."
openssl-101f,O1,mips,surewarehk_finish,./data/decomp/openssl-101f_mips_gcc_O1_extraction/surewarehk_finish@005d8534.c,"The function checks if the surewarehk_dso variable is equal to 0. If it is, the SUREWARE_lib_error_code variable is set to the result of a function call and an error message is logged. If it is not, the p_surewarehk_Finish function is called and the surewarehk_dso variable is freed. If the surewarehk_dso variable was not freed successfully, the SUREWARE_lib_error_code variable is set to the result of a function call and an error message is logged. Various function pointers are then freed, and the function returns a value indicating whether it executed successfully or not."
openssl-101f,O1,mips,sv_body,./data/decomp/openssl-101f_mips_gcc_O1_extraction/sv_body@00442f98.c,"These function summaries describe various aspects of SSL/TLS server implementation using the OpenSSL library. They include initializing SSL context, setting up SSL options, handling SSL connections, reading and writing data to the client, and handling various protocol messages and errors. The functions also handle incoming HTTP requests, generate appropriate responses, and check for invalid paths or requests. They may also print debug messages, print SSL connection information, and handle user input or special commands."
openssl-101f,O1,mips,__do_global_ctors_aux,./data/decomp/openssl-101f_mips_gcc_O1_extraction/__do_global_ctors_aux@00631900.c,"The function __do_global_ctors_aux initializes global objects by calling their constructors. It checks if the __CTOR_LIST__ variable is not equal to 0xffffffff, which indicates the end of the constructor list. If not, it initializes two pointers and enters a loop where it calls the constructor function pointed to by pcVar2 and updates pcVar2 to point to the next constructor function in the list. This loop continues until pcVar2 is equal to 0xffffffff, indicating the end of the constructor list. The function ensures that all global objects are properly initialized before the program starts executing."
openssl-101f,O1,mips,__libc_csu_init,./data/decomp/openssl-101f_mips_gcc_O1_extraction/__libc_csu_init@00631850.c,"The function __libc_csu_init initializes the C runtime environment by calling a function located at PTR__init_006aaa30, which is a pointer to the program's initialization routine. The function then returns."
openssl-101f,O1,mips,__start,./data/decomp/openssl-101f_mips_gcc_O1_extraction/__start@00421540.c,"The function named __start is the entry point of the program. It initializes variables and calls the function __libc_start_main with arguments, including the address of the main function and the address of the __libc_csu_init function. The purpose of __libc_start_main is to set up the environment for the program and call the main function. Finally, the function enters an infinite loop."
openssl-101f,O1,mips,__udivdi3,./data/decomp/openssl-101f_mips_gcc_O1_extraction/__udivdi3@00630f60.c,"These functions both perform division operations on unsigned integers. 

The first function takes in four parameters representing the dividend and divisor. It checks if the divisor is zero and returns an error if it is. If the dividend is less than the divisor, the function returns zero. If the divisor is not zero and the dividend is greater than or equal to the divisor, the function performs a binary long division algorithm. 

The second function takes in five parameters and performs various bitwise operations to compute a quotient of two unsigned integers. It combines param_3 and param_4 into a single 32-bit value using bitwise OR and shifts it to the right by the lower 5 bits of uVar7. It then combines this value with param_1 shifted to the left by the lower 5 bits of uVar6. The resulting 32-bit value is stored in uVar8. It checks if the upper 16 bits of uVar8 are equal to zero and calls a trap function with code 7 if they are. Otherwise, it divides uVar2 (which is param_2 and param_1 combined into a single 32-bit value using bitwise OR) by the upper 16 bits of uVar8 and stores the result in uVar."
openssl-101f,O2,mips,aep_mod_exp.part.0,./data/decomp/openssl-101f_mips_gcc_O2_extraction/aep_mod_exp.part.0@005cf33c.c,"These function summaries describe different implementations of modular exponentiation using the AEP encryption library or hardware security module. Each function takes in parameters and performs checks before calling the AEP library or HSM functions. If the operation is successful, the result is returned, otherwise an error code is generated and returned. Some functions also check for stack overflow or result size thresholds before performing additional operations."
openssl-101f,O2,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_mips_gcc_O2_extraction/asn1_bio_callback_ctrl@0062aca0.c,This function is a callback implementation for an ASN1 BIO object. It checks the value at offset 0x24 of the BIO object and either jumps to an indirect function call using a function pointer stored at address PTR_BIO_callback_ctrl_006a9548 or returns 0 if the value is zero. It takes an integer parameter which is the pointer to the BIO object. The return value of the called function is then returned by this function.
openssl-101f,O2,mips,asn1_bio_ctrl,./data/decomp/openssl-101f_mips_gcc_O2_extraction/asn1_bio_ctrl@0062ad94.c,"The `asn1_bio_ctrl` function takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. The function retrieves a pointer to an array of integers stored at an offset of `0x20` from the address pointed to by `param_1`. If this pointer is null, the function returns 0. If `param_2` is equal to `0x97`, the second integer in `param_4` is stored in the 11th element of the array, and the function returns 1. If `param_2` is less than `0x98`, the function checks if `param_2` is equal to `0x95`. If it is, the second integer in `param_4` is stored in the 9th element of the array and the function returns 1. If `param_2` is greater than `0x95`, the function does not return a value."
openssl-101f,O2,mips,asn1_bio_free,./data/decomp/openssl-101f_mips_gcc_O2_extraction/asn1_bio_free@0062acc4.c,"The function takes an integer parameter and checks if the value stored at an offset of 0x20 from that integer is not equal to 0. If it is not equal to 0, it checks if the value stored at an offset of 4 from the value stored at offset 0x20 is not equal to 0. If it is not equal to 0, it calls a function pointed to by a constant pointer, which is likely a memory deallocation function. Then, it calls the same function with the value stored at offset 0x20 as the parameter. It then sets the values at offsets 0xc, 0x20, and 0x14 to 0 and returns 1. If the value stored at offset 0x20 is 0, it returns 0."
openssl-101f,O2,mips,asn1_bio_write.part.1,./data/decomp/openssl-101f_mips_gcc_O2_extraction/asn1_bio_write.part.1@0062b180.c,"The function takes in three parameters: an integer, a second integer, and a pointer to a uint. It retrieves a pointer to a uint from the first parameter and sets a local variable to the value of the current stack pointer. If the retrieved pointer is null, the function returns the local variable if it hasn't changed, otherwise it throws an error. If the second parameter is not zero, the third parameter is greater than -1, and the value at the address of the local variable plus 0x24 is not zero, the function calls itself recursively.

If the retrieved pointer is not null, the function retrieves the value of the uint pointer and sets a second local variable to zero. It then checks if the value is less than 5, and if it is, it enters a loop that switches on the value of the uint pointer. The switch statement has five cases: 
1. case 0x62b21c: This case calls two functions to calculate the"
openssl-101f,O2,mips,asn1_bio_write,./data/decomp/openssl-101f_mips_gcc_O2_extraction/asn1_bio_write@0062b500.c,"The function takes three integer parameters and returns an undefined value. It checks if the second parameter is not equal to 0, the third parameter is greater than -1, and the integer value at the memory location pointed to by the first parameter plus 0x24 is not equal to 0. If all these conditions are met, it calls another function named ""asn1_bio_write_part_1"" and returns its return value. Otherwise, it returns 0."
openssl-101f,O2,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BIO_asn1_get_suffix@0062b724.c,"The function BIO_asn1_get_suffix takes in a BIO pointer, a pointer to a suffix and a pointer to a suffix free. It initializes a local variable and calls the function BIO_ctrl. If the return value of BIO_ctrl is greater than 0, it assigns the value of local_1c to the pointer psuffix and the value of local_18 to the pointer psuffix_free. Finally, it checks if the value of local_14 is equal to the value of the stack guard and returns the value of iVar2. If the values are not equal, it calls the function __stack_chk_fail."
openssl-101f,O2,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BIO_asn1_set_prefix@0062b5b0.c,"The function BIO_asn1_set_prefix() sets the prefix for a BIO object using the BIO_ctrl() function with various control codes and parameters. It takes in a BIO object, a prefix string, and a prefix_free pointer as arguments. The prefix is stored in two different undefined4 variables, uStack_4c and uStack_48, and uStack_b4 and uStack_b0, depending on the control code used. If successful, it returns the result of the BIO_ctrl() function call. If not, it terminates the program using the __stack_chk_fail() function. The function also includes stack protection code to prevent buffer overflow attacks."
openssl-101f,O2,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_get0_nist_prime_224@0062b7cc.c,The function BN_get0_nist_prime_224 returns a pointer to a BIGNUM structure representing a pre-defined prime number used in cryptographic operations. The value of this prime number is stored in a static array _bignum_nist_p_224. The function does not take any input parameters and its calling convention is unknown. The warning message indicates that the function may not be compatible with some compilers or platforms due to its unknown calling convention.
openssl-101f,O2,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_get0_nist_prime_384@0062b7e4.c,"The function returns a pointer to a BIGNUM structure representing the NIST P-384 curve prime, a 384-bit prime number used in elliptic curve cryptography. The prime number is pre-defined and stored in memory."
openssl-101f,O2,mips,BN_GF2m_add,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_add@00624434.c,"The function takes in three parameters, all of which are pointers to unsigned integers. The function returns an unsigned integer. The function first checks which of the second and third parameters has a smaller value in its second element and assigns the smaller one to a variable called puVar4. It also assigns the pointer to the larger array to a variable called puVar5 and the corresponding parameter to a variable called ppuVar6. If the length of the first parameter's array is less than the length of the larger array, the function expands the first parameter's array using a function called bn_expand2_006a9680. If the expansion fails, the function returns 0. The function then iterates over the elements of the arrays, XORing the corresponding elements of the second and third parameters' arrays and storing the result in the corresponding element of the first parameter's array. The iteration continues until the smaller of the second and third parameters' arrays is fully processed."
openssl-101f,O2,mips,BN_GF2m_mod,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod@006246b4.c,"The first function is a C implementation of a finite field arithmetic operation called ""modular reduction"" for binary extension fields, denoted as GF(2^m). It takes as input a polynomial represented as an array of integers, a modulus polynomial represented as an array of integers, a context object represented as an array of pointers, and a string indicating the source file name. The function first checks if the input array of integers representing the modulus polynomial is null. If it is, an error message is generated and the function returns 0. Otherwise, the function proceeds to perform the modular reduction operation by calling another function called BN_GF2m_mod_arr_part_0() which is not shown in the decompiled code. If the input array of integers representing the polynomial is null, the function sets the output array of integers to zero and returns 1. Otherwise, the function expands the output array if necessary, and then performs the modular reduction operation by squaring the input polynomial modulo the modulus polynomial.

The second function takes in four parameters: a pointer to a BIGNUM structure (param_1), a pointer to an array of BIGNUM pointers (param_2), a pointer to a BIGNUM structure (param_3), and a pointer to a BN_CTX structure (param_4). The function first initializes some local variables, including a pointer to a BIGNUM structure (puVar12) and an integer (iVar9). It then checks if the value of param_1 is NULL and if so, returns 0. Next, the function checks if the value of param_2 is NULL or if the number of elements in the array pointed to by param_2 is less than 2. If either of these conditions is true, the function returns 0. If neither of these conditions is true, the function initializes a pointer to a BIGNUM structure (ppuVar4) to the first element of the array pointed to by param_2."
openssl-101f,O2,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_arr@006245c0.c,"The function BN_GF2m_mod_arr() takes four parameters: param_1, param_2, param_3, and param_4. If the value pointed to by param_3 is zero, it sets the value of param_1 to zero using a function call to BN_set_word(). If param_1 is not equal to param_2, it expands the memory allocation of param_1 if necessary to accommodate the size of param_2, and then copies the contents of param_2 to param_1. Finally, it calls the function BN_GF2m_mod_arr_part_0() with param_1 and param_3 as arguments and returns the result."
openssl-101f,O2,mips,BN_GF2m_mod_div,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_div@006262f0.c,"The function BN_GF2m_mod_div() takes five parameters, with the first three being undefined. The fourth parameter is a pointer to an integer array representing a GF(2^m) polynomial, which is inverted using BN_GF2m_mod_inv() and stored in a variable. The function then calculates the number of bits in the polynomial using BN_num_bits() and adds 1 to it to allocate memory for an integer array of a specific size. It checks the second integer value in the param_ parameter."
openssl-101f,O2,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_div_arr@00626508.c,"The function BN_GF2m_mod_div_arr performs modular division of two binary polynomials represented as arrays of integers in GF(2^m) field. It takes five arguments: param_1 and param_2 are arrays representing the dividend and divisor polynomials respectively, param_3 is an integer representing the modulus polynomial, param_4 is an array representing the irreducible polynomial used to define the field, and param_5 is a BN_CTX structure used for temporary storage. The function first sets a temporary variable piVar1 to zero and sets its bits based on the indices of the non-zero bits in the divisor polynomial represented by param_4. It then computes the modular inverse of piVar1 with respect to the modulus polynomial param_3 using BN_GF2m_mod_inv function. If the inverse cannot be computed, the function returns false. Next, the function computes the number of bits in the inverse polynomial piVar1 and allocates memory for an array of integers to store the indices."
openssl-101f,O2,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_mul@006256f0.c,"The function BN_GF2m_mod_mul takes five parameters and calculates the number of bits in param_4. It allocates memory for an array of integers and converts the binary polynomial representation of param_4 into a list of bit positions where the coefficients are 1. If param_4 is zero, the function sets the output variable iVar4 to 0. Otherwise, it sets iVar4 to the number of bit positions in the array. If the allocation fails, the function returns 0."
openssl-101f,O2,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_mul_arr@00624b58.c,"The functions perform mathematical operations on input parameters and return a result. 

- BN_GF2m_mod_mul_arr() multiplies two binary polynomials represented as arrays of unsigned integers in GF(2^m) field, and stores the result in a third array passed as a parameter. It checks if the second parameter is the same as the third parameter, and computes the square of the polynomial if they are the same. If they are different, it allocates memory for a new array to store the result, multiplies the two polynomials using the standard multiplication algorithm for binary polynomials, and reduces the result modulo a fourth parameter representing the irreducible polynomial in the field GF(2^m).
- The second function performs a series of bitwise operations on input variables and values stored in an array, and updates elements of an array. It initializes the array to zero, processes each element of the input array, extracts bits from input variables using various bitwise operations, and updates other variables based on certain conditions. It then uses the resulting values to update the array and compute a new value.
- The third function takes in five parameters and performs some calculations using the input parameters, storing the result in the first BIGNUM structure. It checks if the input parameters are valid, and returns 0 if they are not. It checks if the result is zero, and returns 0 if it is. It checks if the second BIGNUM structure is zero, and returns 0 if it is.
- The fourth function multiplies two input polynomials modulo a given modulus using the Gaussian normal basis representation for binary fields. It checks if either of the input polynomials is zero, and returns zero if so. It allocates memory for a buffer to hold the product of the two input polynomials, initializes several variables, and iterates through each bit of the input polynomials, computing the product of the corresponding basis elements using the distributive property of multiplication, and accumulating the results in the buffer. It then reduces the product polynomial modulo the given modulus."
openssl-101f,O2,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_sqr@006258e4.c,"This function calculates the number of bits in the input parameter `param_3` and adds 1 to it. It then allocates memory for an array of `iVar1 * 4` bytes, where `iVar1` is the number of bits calculated in the previous step. If the memory allocation fails, it returns 0. The function then extracts the degree of the input polynomial `param_3`. If the degree is 0, the output is set to 0 and returned. Otherwise, the function iterates over the bits in the input polynomial and stores the positions of the non-zero bits in the allocated array. If the number of non-zero bits is less than `iVar1`, the next element in the array is set to `0xffffffff`. The function then calls the `BN_GF2m_mod_sqr_arr` function with the allocated array as input to compute the square of the input polynomial. Finally, the allocated memory is freed and the output is returned."
openssl-101f,O2,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_sqrt@00626d24.c,"The function BN_GF2m_mod_sqrt() calculates the square root of an input value using a polynomial over the finite field GF(2^m). It takes four parameters: a pointer to a BIGNUM structure for the result, a pointer to a BIGNUM structure for the input value, a pointer to an array of integers representing the polynomial, and a pointer to a BN_CTX structure for temporary storage. It first calculates the number of bits in the input value and allocates an array of integers for the calculation."
openssl-101f,O2,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_GF2m_mod_sqr_arr@006248a0.c,"The function BN_GF2m_mod_sqr_arr() takes in four parameters: a double pointer to an array of unsigned integers, two pointers to integers, and an undefined value. It returns a boolean value. The function initializes a BN_CTX and allocates memory for a pointer to an array of unsigned integers using the BN_CTX. If the allocation fails, the function returns false. Next, the function checks if the size of the allocated array is large enough to hold the result of squaring the input array. If not, it expands the allocated array using the bn_expand2() function. After expanding the array if necessary, the function squares the input array by iterating over its elements, computing the square of each element using a lookup table (SQR_tb), and storing the result in the corresponding element of the output array. The function then checks if the output array is zero. If it is, it sets the output array to zero."
openssl-101f,O2,mips,BN_kronecker,./data/decomp/openssl-101f_mips_gcc_O2_extraction/BN_kronecker@00623300.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUM integers a and b using the binary method. It initializes a BN_CTX object to store temporary variables during the calculation and copies the values of a and b into two uint pointers. It checks if b is even and returns 0 if it is. If both a and b are odd, it calculates the Kronecker symbol using the binary method, which involves repeatedly dividing b by 2 until it becomes odd. At each step, it calculates the Kronecker symbol of a and the quotient of b divided by 2 using a lookup table. It then updates a and b accordingly and repeats until b becomes 1."
openssl-101f,O2,mips,by_dir_entry_free,./data/decomp/openssl-101f_mips_gcc_O2_extraction/by_dir_entry_free@00587a40.c,"The function takes in a pointer to an integer array and frees any memory allocated to it. If the first or third element of the array is not equal to zero, it calls a function at a specific memory address to free the corresponding memory. The function also frees the memory allocated to the entire array and returns. The original code may have had more complex branching logic that could not be fully decompiled."
openssl-101f,O2,mips,cswift_rand_bytes,./data/decomp/openssl-101f_mips_gcc_O2_extraction/cswift_rand_bytes@005d2070.c,"The following functions use the CSWIFT cryptographic library to perform various cryptographic operations:

1. `cswift_rand_bytes`: Generates random bytes using the CSWIFT cryptographic library. Takes in a pointer to a buffer and the number of bytes to generate.

2. `cswift_diffie_hellman`: Implements the Diffie-Hellman key exchange algorithm using the CryptoSwift library. Takes in a pointer to the destination buffer for the computed shared secret key and the public key of the other party.

3. `cswift_crypto_operation`: Acquires an access context and performs cryptographic operations using the CryptoSwift library.

4. `cswift_modular_exponentiation`: Performs a modular exponentiation using the CryptoSwift library.

5. `cswift_low_level_crypto_operation`: Performs a cryptographic operation using the CryptoSwift library. Takes in several input parameters, including a key, input data, and output data buffers, as well as various configuration options.

6. `cswift_signing_algorithm`: Implements a signing algorithm using the CSWIFT library.

7. `cswift_verify_signature`: Performs cryptographic operations using the CryptoSwift library. Takes in several input parameters, including a public key, a message, a signature, and various context information.

8. `cswift_hardware_engine`: Wrapper for using the CryptoSwift hardware engine to perform cryptographic operations.

9. `cswift_init_library`: Initializes the CSWIFT library and sets up error handling, engine creation, and algorithm initialization."
openssl-101f,O2,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_mips_gcc_O2_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061cce0.c,The function calls an indirect jump to a code pointer stored in the global variable PTR_ASN1_item_d2i_006a9798. This pointer is assumed to point to a function that deserializes an ASN.1 structure representing GOST client key exchange parameters into a C struct. The function returns without performing any additional actions.
openssl-101f,O2,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_mips_gcc_O2_extraction/d2i_GOST_KEY_PARAMS@0061cc20.c,"The function uses a pointer to an unknown function obtained from a global variable. It is likely related to converting a GOST key parameter from DER format to internal representation, but the exact function cannot be determined due to an inability to recover the jumptable at a specific address. The function returns without any further processing."
openssl-101f,O2,mips,decode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O2_extraction/decode_gost_algor_params@00619aac.c,"The function decodes GOST algorithm parameters from an X509_ALGOR structure and sets them in an EVP_PKEY structure by extracting the parameters, checking their validity, decoding them, and creating a new EC_KEY or DSA structure depending on the algorithm type. 

It also implements the GOST R 34.10-2001 elliptic curve digital signature algorithm, generating a private key if one is not provided and computing the corresponding public key, setting it in the EVP_PKEY object. It returns 1 on success and 0 on failure."
openssl-101f,O2,mips,DES_xcbc_encrypt,./data/decomp/openssl-101f_mips_gcc_O2_extraction/DES_xcbc_encrypt@00622220.c,"The first function implements the DES-XCBC encryption algorithm and takes in input and output buffers, key schedule, initialization vector, and a flag indicating encryption or decryption. It processes input in blocks of 8 bytes, XORs with initialization vector and constant DES block, encrypts with key schedule, and stores in output buffer. It handles remaining bytes and cleans up variables.

The second function implements the AES-CTR encryption algorithm and takes in plaintext, key, and initialization vector. It initializes cipher state, processes plaintext in blocks of 8 bytes, XORs with output of cipher in counter mode, and writes resulting ciphertext to output buffer. It pads plaintext if necessary and uses a lookup table and key schedule for AES round transformations. It updates IV for next block of plaintext.

The third function implements the AES encryption algorithm and takes in plaintext, key, and initialization vector. It initializes a schedule, XORs IV with first block of plaintext, performs rounds of substitution, permutation, and mixing, and XORs final block of ciphertext with last block of plaintext. It updates IV for next block of plaintext and returns updated IV and ciphertext.

The fourth function performs encryption or decryption using the Blowfish algorithm in output feedback mode. It takes in input data, key, and initialization vector, initializes variables, loops through input data XORing with output of Blowfish algorithm and updating IV, pads input data if necessary, and checks input and output data lengths. It encrypts/decrypts remaining bytes with updated IV.

The fifth function is a decryption function that takes in an input buffer and a key, decrypts the input buffer using the key, and stores the result in the same input buffer. It initializes variables, checks if input buffer is the same as the key, XORs each byte of input buffer with corresponding byte of key, and repeats key if input buffer is longer. It returns decrypted input buffer.

The sixth function takes in parameters and performs operations on them. It XORs buffers, performs bit shifting, and stores results in variables. It checks a certain value and either returns or calls another function and performs mathematical operations. It seems to be performing encryption or decryption on input data."
openssl-101f,O2,mips,dgram_ctrl,./data/decomp/openssl-101f_mips_gcc_O2_extraction/dgram_ctrl@0052cd98.c,"The first function takes in various parameters, including pointers to arrays and an undefined 4-byte value, and performs different actions based on the value of an integer parameter. It uses a switch statement to determine which action to take.

The second function takes in a socket file descriptor and a command to perform on the socket, and performs various operations on the socket based on the input command and parameters. It uses functions such as `bind()` and `getsockopt()` to perform these operations.

The third function is a switch statement that takes a command code and executes the corresponding action, which includes socket operations and SSL connection management. It also handles error checking and sets the appropriate errno value.

The fourth function is a part of the OpenSSL library and is responsible for reading data from a network connection. It performs various checks and operations to ensure that the data is read correctly and securely, including setting flags and timeouts, reading data from the network using the recvfrom system call, and clearing flags and returning error codes if necessary."
openssl-101f,O2,mips,dlfcn_bind_func,./data/decomp/openssl-101f_mips_gcc_O2_extraction/dlfcn_bind_func@00629ea4.c,"The function takes two integer parameters, param_1 and param_2. If either parameter is equal to 0, the function returns an error code (0x43 and 0x110) indicating that the parameters are invalid. If both parameters are non-zero, the function calls the function at the memory address pointed to by PTR_sk_num_006a7f2c, passing in the value at offset 4 of param_1 as an argument. This function is likely part of the OpenSSL library and is used to retrieve the number of items in a stack. If the number of items is less than 1, the function returns an error code (0x69 and 0x115) indicating that the stack is empty. If the stack is not empty, the function retrieves the value at offset 4 of param_1 and calls the function at the memory address pointed to by PTR_sk_value_006a7f24, passing in the value retrieved from the stack and the."
openssl-101f,O2,mips,dlfcn_bind_var,./data/decomp/openssl-101f_mips_gcc_O2_extraction/dlfcn_bind_var@0062a018.c,"The function takes in two parameters, param_1 and param_2. If either parameter is equal to 0, it sets two variables, uVar2 and uVar3, to specific values (0x43 and 0xee). If both parameters are not equal to 0, it calls a function at memory address PTR_sk_num_006a7f2c with the value at param_1 + 4 as its argument, and stores the result in iVar1. Depending on the result, it sets uVar2 and uVar3 to different values or sets uVar3 to the value at param_1 + 4, and calls two more functions at memory addresses PTR_sk_num_006a7f2c and PTR_sk_value_006a7f24 with uVar3 as their respective arguments."
openssl-101f,O2,mips,dlfcn_globallookup,./data/decomp/openssl-101f_mips_gcc_O2_extraction/dlfcn_globallookup@00629a60.c,"The function uses dynamic linking to find a symbol by name, by first opening a shared library with dlopen and getting a handle to it. It then looks up the symbol with dlsym and returns a pointer to its address. Finally, it closes the shared library handle with dlclose. If either dlopen or dlsym fails, the function returns 0."
openssl-101f,O2,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_mont_field_encode@00627d3c.c,"The function takes four parameters: param_1, param_2, param_3, and param_4. param_1 is a pointer to an EC_GROUP struct, param_2 is an input BIGNUM, param_3 is an output buffer for the encoded BIGNUM, and param_4 is a pointer to a BN_CTX struct for temporary memory allocation. The function retrieves the value of a field in the EC_GROUP struct at offset 0xa0 and stores it in the variable iVar1. If the value is not zero, the function calls a function at the address stored in PTR_BN_mod_mul_montgomery_006a9674 with param_2, param_3, the value of iVar1 + 4, iVar1, and param_4 as arguments. If the value of iVar1 is zero, the function calls a function at the address stored in PTR_ERR_put_error_. This function likely performs a modular multiplication using the Montgomery reduction technique."
openssl-101f,O2,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_mont_field_sqr@00627cc4.c,"The function implements squaring in a Montgomery field over an elliptic curve. It takes four parameters: param_1 is a pointer to an elliptic curve structure, param_2 and param_3 are the operands to be squared, and param_4 is a Montgomery constant. It first checks if the elliptic curve has been initialized for Montgomery multiplication by checking if the value at offset 0xa0 is non-zero. If so, it calls the function pointed to by PTR_BN_mod_mul_montgomery_006a9674, passing in the two operands to be squared, the Montgomery constant, and the pointer to the elliptic curve structure. This function computes the square of the operands in the Montgomery field and returns the result. If the elliptic curve has not been initialized for Montgomery multiplication, the function calls the error handling function pointed to by PTR_ERR_put_error_006a9030, passing in error code 0x10, subcode 0x."
openssl-101f,O2,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_mont_group_init@006277b0.c,"The function initializes a Montgomery elliptic curve group over a finite field by calling ec_GFp_simple_group_init() to initialize a simple elliptic curve group over a finite field. It sets two 32-bit integers to zero, which are likely used to store specific parameters for the Montgomery curve group, and returns."
openssl-101f,O2,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_nist_field_mul@0062815c.c,"The function performs a multiplication operation on two field elements in a GF(p) field, where p is a prime number defined by the input parameters. It checks if any of the input parameters are zero and calls a function to put an error message and exit. If the fifth parameter is zero, the function creates a new BN_CTX object to perform the multiplication operation and squares the result using the GF(p) field parameters. It returns true if the operation succeeded, false otherwise. If the fifth parameter is not zero, the function directly performs the multiplication operation and squares the result using the GF(p) field parameters. It returns true if the operation succeeded, false otherwise."
openssl-101f,O2,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_nist_group_copy@00627ea0.c,"The `ec_GFp_nist_group_copy()` function copies an elliptic curve group from one structure to another. It takes two parameters, `param_1` and `param_2`, which are pointers to structures representing elliptic curve groups. The function first copies the value of a specific member variable (`0xa8`) from the source group (`param_2`) to the destination group (`param_1`). Then, the function calls `ec_GFp_simple_group_copy()` to copy the remaining members of the source group to the destination group. Finally, the function returns."
openssl-101f,O2,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_nist_group_set_curve@00627eb8.c,"The `ec_GFp_nist_group_set_curve` function takes in five parameters: `param_1`, `param_2`, `param_3`, `param_4`, and `param_5`. `param_1` is a pointer to an `EC_GROUP` structure representing an elliptic curve group. `param_2` is a BIGNUM pointer representing the prime modulus of the elliptic curve group. `param_3` is another BIGNUM pointer representing the `a` parameter of the elliptic curve equation. `param_4` is a BIGNUM pointer representing the `b` parameter of the elliptic curve equation. `param_5` is an integer representing a `BN_CTX` pointer. The function first checks if `param_5` equals zero and, if so, initializes a new `BN_CTX` pointer."
openssl-101f,O2,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062e000.c,"The function takes in six integer parameters and returns a boolean value. It checks if a certain value in a data structure pointed to by the first parameter is equal to zero. If it is, then it checks if the second, third, and fourth parameters are either zero or have certain values copied into them from other locations in memory. If the fifth parameter is not zero, it copies a value from another location in memory into it. If all these checks pass, the function returns true. 

If the value in the data structure pointed to by the first parameter is not zero, the function creates a new context object using a function pointer and assigns it to the sixth parameter. It then calls a function pointer stored in the data structure pointed to by the first parameter with several parameters, including the first, second, and fourth parameters passed into the function. If all these function calls return non-zero values, the function performs the same copy operation from memory to the fifth parameter as before. It then returns true if all."
openssl-101f,O2,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_group_check_discriminant@0062e1ec.c,"The function takes in an integer array and an integer value, and returns a boolean value. It checks if the second argument is equal to 0, and initializes a new variable if it is. It then initializes five variables using function calls. If the fifth variable is not equal to 0, the function checks if a certain pointer in the first argument is equal to 0. If it is, the function copies two values from the first argument into two of the variables it initialized earlier. If it isn't, the function calls a function at a certain pointer in the first argument, passing in the first argument, the first variable, and the second variable as arguments."
openssl-101f,O2,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_group_clear_finish@0062db04.c,"The function clears and frees memory allocated for the internal structures of an elliptic curve group. It takes one parameter, which is the memory address of the group structure. The function clears and frees memory allocated for three big numbers used in the group structure by calling the same function with different parameters. The function then returns."
openssl-101f,O2,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_group_copy@0062f054.c,"The function is a copy function for a simple elliptic curve group in GF(p) (finite field of prime order). The function takes two parameters: param_1 and param_2, which are pointers to the two groups to be copied. The function first calls a BN_copy function (which is a function for copying big integers) three times to copy the parameters of the group from param_2 to param_1, specifically, it copies the generator point, the order of the group, and the cofactor of the group. If all three BN_copy calls succeed, the function sets the value of a specific field in param_1 to the value of the same field in param_2. Finally, the function returns 1 to indicate success, or 0 to indicate failure."
openssl-101f,O2,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_group_get_degree@0062dbb4.c,"The `ec_GFp_simple_group_get_degree` function takes an integer parameter `param_1` and returns the degree of a simple elliptic curve group over a finite field. It calls a function stored at memory location `PTR_BN_num_bits_006a82f4` with an argument that is `param_1` plus `0x48`, and discards the result of this function call."
openssl-101f,O2,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_group_set_curve@0062f194.c,"The function takes in five parameters - an integer pointer, a pointer to a pointer of unsigned integers, and three unsigned integers. It returns an unsigned integer. The function first checks if the input parameters are valid. If not, it returns 0. If the input parameters are valid, the function initializes a new BN_CTX object and starts it. It then copies the input parameters into the BN_CTX object and sets a flag indicating that the BN_CTX object has been initialized. The function then performs some mathematical operations on the input parameters using the BN_CTX object. It checks if a function pointer is not null and if so, calls the function with the input parameters. If the function call is successful, the function sets the return value to 1. Otherwise, it sets the return value to 0. Finally, the function ends the BN_CTX object and frees its memory if it was initialized within the function. The function then returns the return value."
openssl-101f,O2,mips,ec_GFp_simple_invert,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_invert@00630104.c,"The function takes two parameters, param_1 and param_2. It first calls a function at the address pointed to by PTR_EC_POINT_is_at_infinity_006a9770 and stores the result in the variable iVar1. If iVar1 is equal to 0 and the value at the address (param_2 + 0x1c) is not equal to 0, the function calls another function at the address pointed to by PTR_BN_usub_006a96d4 with the parameters (param_2 + 0x18) and (param_1 + 0x48). The result of this function call is stored in the variable uVar2, which is then returned. If either of the conditions are not met, the function returns 1."
openssl-101f,O2,mips,EC_GFp_simple_method,./data/decomp/openssl-101f_mips_gcc_O2_extraction/EC_GFp_simple_method@00630f54.c,"The EC_GFp_simple_method function likely returns a set of functions for elliptic curve operations over a finite field. The decompiler is unable to determine the calling convention and issues a warning. The function's parameter storage is locked, making it impossible to determine the data types or layout of arguments."
openssl-101f,O2,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_point_copy@0062f0f4.c,"This function copies the contents of one point to another point in an elliptic curve group. It takes two input parameters: param_1 and param_2, which are pointers to the two points to be copied. The function first calls a function at memory address PTR_BN_copy_006a9570 to copy the x-coordinate of the point from param_2 to param_1. If the copy is successful, the function then calls the same function to copy the y-coordinate and z-coordinate of the point from param_2 to param_1. Finally, the function copies the point type from param_2 to param_1. If any of the copy operations fail, the function returns 0 to indicate failure. Otherwise, it returns 1 to indicate success."
openssl-101f,O2,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_point_finish@0062dab0.c,"The function frees memory allocated to three pointers located at offsets 4, 0x18, and 0x2c from an integer parameter, and returns."
openssl-101f,O2,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_point_get_affine_coordinates@0062e4f0.c,"The function is a C implementation of getting the affine coordinates of a point on an elliptic curve. It takes five parameters: a pointer to an elliptic curve object, a pointer to a point object on the elliptic curve, a pointer to a BIGNUM object to store the x-coordinate of the point in affine form, a pointer to a BIGNUM object to store the y-coordinate of the point in affine form, and a pointer to a BN_CTX object for temporary storage. The function first checks if the point is at infinity, and if so, returns false. If the BN_CTX object is not provided, it creates a new one and starts it. It then initializes four BIGNUM objects using the BN_CTX object. If the elliptic curve object has a null function pointer at offset 0x94, the function..."
openssl-101f,O2,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O2_extraction/ec_GFp_simple_point_set_affine_coordinates@0062f494.c,"The function ec_GFp_simple_point_set_affine_coordinates takes five parameters, with the third and fourth being integers. It checks if both parameters are non-zero and calls two other functions through function pointers. It returns the value returned by the second function. If either parameter is zero, it calls another function through a function pointer to put an error message into an error queue and returns 0."
openssl-101f,O2,mips,encode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O2_extraction/encode_gost_algor_params@0061b110.c,"The functions are related to GOST cryptography in OpenSSL library. They take a pointer to an EVP_PKEY structure as input and perform operations on it, including encoding and decoding using the GOST algorithm. They also use other functions and libraries within OpenSSL, such as BIO and EC_KEY. The functions initialize variables, check if the input pointer is valid, retrieve private and public keys, and print them to a BIO object. They also retrieve the parameter set used in the key generation and calculate the public key from the private key. They return pointers to integers indicating whether the operation was successful or not."
openssl-101f,O2,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_mips_gcc_O2_extraction/general_allocate_boolean.constprop.5@005b32bc.c,"The function takes in 8 parameters, including a pointer to a string, its length, and several integers. It first checks if the string is null, and if so, returns an error code. If not, it checks if the string contains only certain characters (determined by a function call), and if not, returns an error code. If the string passes the character check, the function checks if a certain integer parameter is non-zero. If it is zero, an error code is returned. If it is non-zero, the function allocates memory for an integer array of size 8, sets certain values in the array based on the input parameters, and then pushes the array onto a stack (which is also created if it doesn't already exist) using a function call. The function then returns either the index of the pushed array on the stack (if successful), or an error code (-1) if any of the previous checks fail."
openssl-101f,O2,mips,get_gost_engine_param,./data/decomp/openssl-101f_mips_gcc_O2_extraction/get_gost_engine_param@0061ee48.c,"The function takes an integer argument and returns an integer value. If the argument is equal to 0, the function checks if a global variable named ""gost_params"" is equal to 0. If it is, the function calls the ""getenv"" function to get the value of the environment variable ""CRYPT_PARAMS"". If ""CRYPT_PARAMS"" is not set, the function returns 0. Otherwise, it allocates memory to store the value of ""CRYPT_PARAMS"" using the ""BUF_strdup"" function and assigns it to ""gost_params"". Finally, the function returns the value of ""gost_params"". If the argument is not equal to 0, the function simply returns 0."
openssl-101f,O2,mips,gost2001_param_encode,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost2001_param_encode@0061a1d4.c,The function takes in two unused parameters of type undefined4. It calls multiple functions using global variables and stores the results in a local variable.
openssl-101f,O2,mips,gost_cipher_cleanup,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost_cipher_cleanup@0061cfe0.c,The function takes an integer parameter to access a memory location and calls gost_destroy() with a specific offset. It sets the value at another offset to zero and returns 1 to release resources used by the GOST cipher.
openssl-101f,O2,mips,gost_cipher_ctl,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost_cipher_ctl@0061d874.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function generates random bytes using a function at address `PTR_RAND_bytes_006a8d44` and stores them in the memory pointed to by `param_4`. The function returns 1 if the bytes were generated successfully and sets `uVar2` to 0xffffffff if there was an error. If `param_2` is not equal to 6, the function checks if `param_2` is equal to 7. If it is, the function sets the value at the memory location pointed to by `param_4` to 0x32a and returns 1. If `param_2` is not equal to 7 or `param_4` is not provided, the function does not return anything."
openssl-101f,O2,mips,gost_cipher_do_cnt,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost_cipher_do_cnt@0061d1dc.c,"The function `gost_cipher_do_cnt` takes four arguments: an integer, a pointer to a byte array, another pointer to a byte array, and an unsigned integer. It returns an undefined value. The function retrieves the value of a variable `uVar4` from a memory location that is `0x50` bytes offset from the integer argument. If `uVar4` is zero, it is set to 8 and another variable `uVar3` is set to zero. Otherwise, the value of `uVar2` is set to `uVar4`. If `uVar4` is less than 8, the function checks if the fourth argument `param_4` is zero. If it is, the function jumps to a label `LAB_0061d560`. Otherwise, the function sets `uVar2` to `uVar4 + 1` and sets the first byte of `param_2` to the XOR of the byte.

The function takes in four parameters: param_1, param_2, param_3, and param_4. param_1 is a pointer to some data structure, param_2 is a buffer that will hold some data, param_3 is another buffer that holds some data, and param_4 is the size of param_2. The function starts by setting a variable uVar3 to the value of the first byte in param_1 plus one. It then XORs the second byte in param_1 with the second byte in param_3, and stores the result in the second byte of param_2. If param_4 is less than or equal to uVar3 plus one, the function sets a value in param_1+0x50 to 1 and returns 1. Otherwise, it continues to XOR the next byte in param_1 with the next byte in param_3, and stores the result in the next byte of param_2."
openssl-101f,O2,mips,gost_cipher_init,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost_cipher_init@0061ea98.c,"This function checks if the cipher has been initialized and retrieves the cipher parameters from the engine if it has not. If the engine parameters are not available, it uses default cipher parameters. If a matching cipher is found, its parameters are used and stored in the cipher context. If a key or initialization vector (IV) is provided, it is set in the cipher context. The function returns 1 to indicate success."
openssl-101f,O2,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O2_extraction/GOST_CIPHER_PARAMS_new@0061ccb0.c,The function creates a new instance of the GOST_CIPHER_PARAMS data structure using the ASN1_item_new function and a function pointer stored at memory address PTR_ASN1_item_new_006a9778. It then returns the resulting GOST_CIPHER_PARAMS structure.
openssl-101f,O2,mips,gost_imit_final,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost_imit_final@0061e800.c,"The function takes in an integer and an undefined value, initializes variables, and retrieves values from the input integer. It checks if a certain value in the retrieved integer is equal to zero, and if so, it calls an error function and jumps to a label. If not, it proceeds to check another value in the retrieved integer and if it is not equal to zero, it sets some variables and jumps to another label. 

If the above condition is not met, the function enters a loop where it calls two other functions and sets some variables. It then checks another value in the retrieved integer and if it meets a certain condition, it calls another function and sets some more variables. The function then calls another function, sets some variables, and checks some more values in the retrieved integer. If a certain condition is met, it calls another function and sets some more variables. 

Finally, it enters another loop where it calls two functions and sets some variables."
openssl-101f,O2,mips,gost_imit_init_cpa,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost_imit_init_cpa@0061d7ec.c,"The function initializes the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A using a pointer to a structure containing the encryption context as its first parameter. It sets a flag to indicate initialization and sets all key and IV bytes to zero. It calls the gost_init function with the encryption context, CryptoPro parameter set A, and two other parameters. The function returns 1 to indicate success."
openssl-101f,O2,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O2_extraction/GOST_KEY_PARAMS_new@0061cc50.c,"The function creates a new instance of the GOST_KEY_PARAMS data structure by calling a function pointer that points to the ASN1_item_new function with the GOST_KEY_PARAMS_it parameter, and then returns the resulting data structure."
openssl-101f,O2,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_mips_gcc_O2_extraction/GOST_KEY_TRANSPORT_free@0061cb48.c,The function takes in a 4-byte parameter and calls another function with that parameter and a pointer to an ASN1_ITEM structure. The called function likely frees memory associated with the GOST_KEY_TRANSPORT data type. No return value is given.
openssl-101f,O2,mips,gost_param_free,./data/decomp/openssl-101f_mips_gcc_O2_extraction/gost_param_free@0061ed70.c,"The function checks if ""gost_params"" is not zero, frees the memory allocated for it using a function pointer, sets ""gost_params"" to zero, and returns from the function."
openssl-101f,O2,mips,hash_step,./data/decomp/openssl-101f_mips_gcc_O2_extraction/hash_step@0061ef50.c,"The first function, `hash_step`, takes in three arguments and performs bitwise operations on them to store the results in local variables.

The second function extracts specific bits of data from two byte parameters and sets values for multiple local variables using bitwise operations.

The third function performs a GOST encryption algorithm with a given key on a given input data and stores the results in various local variables.

The fourth function performs a GOST encryption algorithm on a given input using a given key and performs multiple XOR operations on the encrypted and input data before storing the result in the output buffer.

The fifth function checks if a local variable is equal to a pointer value, sets variables and calls a function if they are not equal, allocates memory, and calls the `gost_init` function before returning a value."
openssl-101f,O2,mips,hwcrhk_init,./data/decomp/openssl-101f_mips_gcc_O2_extraction/hwcrhk_init@005d6a80.c,"The `hwcrhk_init` function initializes the hardware cryptography library by loading the library and binding its functions. If it fails, it sets an error code and returns 0. If successful, it sets pointers to the library functions and initializes a mutex if needed. Additionally, it creates an RSA key handle if it does not already exist. The function returns 1 on success and 0 on failure."
openssl-101f,O2,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_mips_gcc_O2_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061cbd8.c,"The i2d_GOST_KEY_AGREEMENT_INFO function takes two parameters of type undefined4, likely a pointer to a data structure and an output buffer. It calls an external function PTR_ASN1_item_i2d_006a979c to serialize the data structure into the output buffer using the type identifier GOST_KEY_AGREEMENT_INFO_it. The function returns without performing any additional operations."
openssl-101f,O2,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_mips_gcc_O2_extraction/i2d_GOST_KEY_TRANSPORT@0061cb18.c,The function i2d_GOST_KEY_TRANSPORT takes two parameters of type undefined4 and calls a function stored in the global variable PTR_ASN1_item_i2d_006a979c with the two parameters and a third parameter GOST_KEY_TRANSPORT_it. The called function is assumed to convert an ASN.1 data structure into a binary format. No return value is specified.
openssl-101f,O2,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101f_mips_gcc_O2_extraction/load_pkcs12.constprop.4@004592d8.c,"The function loads a PKCS12 file using `d2i_PKCS12_bio`. It verifies the MAC of the file using `PKCS12_verify_mac` and prompts the user for a password if verification fails. It parses the PKCS12 file using `PKCS12_parse` and frees the memory allocated for the file. If any of these steps fail, the function returns 0 and prints an error message."
openssl-101f,O2,mips,param_copy_gost94,./data/decomp/openssl-101f_mips_gcc_O2_extraction/param_copy_gost94@0061a670.c,"The function takes in two parameters of type undefined4 and returns an undefined4 value. It retrieves the base ID and pointer to the key of both input parameters using pre-defined pointers. It checks if the base IDs of the two keys match, and if not, it throws an error and returns 0. If the base IDs match, it checks if the second parameter's key pointer is null. If it is, it throws an error and sets the return value to 0. Otherwise, it creates a new DSA object and assigns it to the first parameter's key pointer. The function retrieves the three BIGNUM values from the second parameter's key pointer and assigns them to the corresponding BIGNUM values in the first parameter's key pointer. If any of the BIGNUM values in the first parameter's key pointer are not null, they are freed before being assigned the new values. Finally, if the fourth BIGNUM value in the first parameter's key pointer is not null, it is freed before being assigned the new value."
openssl-101f,O2,mips,param_print_gost01,./data/decomp/openssl-101f_mips_gcc_O2_extraction/param_print_gost01@0061abe4.c,"The function takes in three parameters and retrieves information about a cryptographic key by calling three different functions. It prints out the name of the parameter set being used and returns 1 if the printing is successful, and 0 otherwise."
openssl-101f,O2,mips,param_print_gost94,./data/decomp/openssl-101f_mips_gcc_O2_extraction/param_print_gost94@0061ac98.c,"These function summaries describe different functions related to the GOST cryptography algorithm in OpenSSL. 

- `param_print_gost94` takes three `undefined4` parameters and returns an `int` pointer. It initializes variables, retrieves values, and prints messages related to GOST cryptography parameters and keys. There is a warning message indicating a potential issue with the function's implementation.

- The decompiled function for generating digital signatures with GOST takes in a private key and a message, and uses them to generate a signature. It initializes variables, sets up the GOST context, calculates the hash of the message using the GOST hash function, generates a signature for the hash using the private key and the GOST signature function, encodes the signature, and returns it.

- The function for handling GOST algorithm parameters in OpenSSL retrieves the necessary parameters, encodes them using `encode_gost_algor_params`, performs various operations, and returns a result based on the input parameters. It also handles errors and performs memory management tasks.

- The function for handling GOST keys in OpenSSL takes a pointer to an EVP_PKEY structure and a pointer to a BIO structure as input parameters. It checks if the EVP_PKEY structure is valid and performs the corresponding operations based on the type of key. It encodes the key and returns it in the BIO structure.

- The decompiled function for printing information about GOST keys takes a pointer to an EVP_PKEY structure as input and returns a pointer to an integer. It initializes variables, checks if the input pointer is null, prints information about the private key and its corresponding public key, and frees up memory. It returns a pointer to an integer or a null pointer if there is an error."
openssl-101f,O2,mips,pkey_ctrl_gost,./data/decomp/openssl-101f_mips_gcc_O2_extraction/pkey_ctrl_gost@0061b6d4.c,"There are three function summaries:

1. Function Name: pkey_ctrl_gost
- Takes in four parameters: two pointers to undefined4, an integer, and a pointer to undefined4
- Initializes several variables and performs a switch statement based on the value of the second parameter
- In case 1, sets the first parameter to a pointer to undefined4, sets the second parameter to a pointer to undefined4, and calls a function at the address stored in PTR_EVP_PKEY_base_id_006a800c
- Calls another function at the address stored in PTR_PKCS7_SIGNER_INFO_get0_algs_006aa7c0 with the fourth parameter and two pointers to undefined4 as arguments
- If the result of the first function call is not null, sets a pointer to undefined4 to the address stored in the fourth parameter and sets iVar5 to 0
- Calls another function at the address stored in PTR_OBJ_nid2obj_006a8240 with 1
- Sets some variables and pointers
- Calls a function to get the private key
- If the private key is less than 0, sets a variable to 0
- Otherwise, calls a function to encode the GOST algorithm parameters
- Calls a function to print the private and public keys
- Performs some calculations on the public key

2. Function Name: C implementation of OpenSSL GOST elliptic curve cryptography algorithm
- Takes in a pointer to an EVP_PKEY object, which contains the public key, and a BIO object, which is used for outputting the results
- Checks if the EVP_PKEY object is not null and is of type EVP_PKEY_EC
- If either of these conditions are not met, an error is thrown and the function returns 0
- If the EVP_PKEY object is valid, retrieves the EC_KEY object from it and then retrieves the EC_GROUP object from the EC_KEY object
- Retrieves the curve name from the EC_GROUP object and outputs it to the BIO object
- Retrieves the EC_POINT object from the EC_KEY object and calculates the affine coordinates of the point using the BN_CTX object
- Outputs the public key coordinates and the parameter set to the BIO object
- If any errors occur during the process, the function throws an

3. No function name given
- Takes in a parameter
- Performs some calculations on the parameter
- Returns the result of the calculations"
openssl-101f,O2,mips,pkey_free_gost94,./data/decomp/openssl-101f_mips_gcc_O2_extraction/pkey_free_gost94@0061abc0.c,The function checks if the value at a specific memory address is not zero and jumps to an unknown function if it is not. It frees memory related to a GOST94 public key.
openssl-101f,O2,mips,priv_encode_gost,./data/decomp/openssl-101f_mips_gcc_O2_extraction/priv_encode_gost@0061bb14.c,"The first function takes two integers and a character pointer as parameters. It gets the base ID of the second integer, uses it to get the corresponding object ID, encodes the GOST algorithm parameters, and sets the private key and algorithm parameters in a PKCS8 structure. If the encoding is successful, it prints the private and public keys and the parameter set to a BIO object and returns 1. If the encoding fails, it prints an error message and returns 0.

The second function is a part of the OpenSSL library and is used to print out information about a GOST keypair. It takes in a pointer to an EVP_PKEY structure representing the GOST keypair and a pointer to a BIO structure where the output will be written. It checks if the keypair is of the GOST type, creates a BN_CTX structure to hold temporary values for calculations, calculates the public key values, prints out the public key values to the BIO structure in a formatted way, and gets the curve name of the GOST keypair and prints it to the BIO structure. If any of the printing operations fail, it returns 0."
openssl-101f,O2,mips,pub_encode_gost94,./data/decomp/openssl-101f_mips_gcc_O2_extraction/pub_encode_gost94@0061b904.c,"The first function, `pub_encode_gost94`, encodes a GOST 94 public key by retrieving the algorithm parameters for the key and encoding them using the `encode_gost_algor_params` function. It then calculates the length of the encoded key and allocates a buffer to hold it. The key is then encoded using the `encode_gost` function. If the encoding is successful, the function returns the length of the encoded key. If not, it returns zero. The function also has some code to handle private key encoding, but it appears to be incomplete and is not used in the function.

The second function is a part of the OpenSSL library and is responsible for printing out information about a GOST keypair. It takes a pointer to an EVP_PKEY structure as input and returns an integer value indicating success or failure. The function first initializes some variables and checks if the input pointer is not NULL. It then checks if the key is of the correct type (GOST R 34.10-2001) and extracts the private key from the EVP_PKEY structure. If the private key is found, it is printed out using the BN_print function. If not, the function prints out ""<undefined>"". The function then extracts the public key from the EVP_PKEY structure and prints it out using the BN_print function. Next, the function determines the parameter set used by the keypair and prints it out. Finally, the function calculates the affine coordinates of the public key and prints them out along with the parameter set. If any errors occur during the function execution, an error is returned."
openssl-101f,O2,mips,pub_print_gost94,./data/decomp/openssl-101f_mips_gcc_O2_extraction/pub_print_gost94@0061ae00.c,"The first function is performing cryptographic operations and printing messages to the user. It takes in three arguments, retrieves information from one of them, encodes parameters using a function called gost94_param_encode, initializes variables, performs operations, and returns an integer pointer.

The second function is a critical component of the OpenSSL library's support for GOST digital signatures. It takes in an EVP_PKEY object, retrieves necessary information from it, encodes it into an ASN.1 structure, and returns a pointer to the encoded structure. It also handles errors using the ERR_GOST_error function.

The third function is responsible for encoding and decoding GOST keys and parameters. It takes in several parameters, performs various operations based on the key type and control operation, and makes use of various OpenSSL functions to perform these operations.

The fourth function is a C implementation of the OpenSSL GOST algorithm for generating elliptic curve cryptography (ECC) keys. It takes in a pointer to an EVP_PKEY structure and a BIO object, retrieves information from the structure, calculates the affine coordinates of the public key point, and outputs the results using the BIO object."
openssl-101f,O2,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O2_extraction/RSA_padding_add_PKCS1_PSS@00628ef8.c,"These functions both involve padding and encrypting messages using RSA keys. The first function uses the PSS algorithm and takes in a message hash, hash function, and salt length. It generates a random salt, updates an EVP_MD_CTX structure, generates a mask using PKCS1_MGF1, and XORs it with the padded message. The second function uses the RSA-OAEP encryption scheme and takes in a plaintext message and a random seed value. It performs OAEP padding on the plaintext message, encrypts the resulting padded message using the RSA public key, and returns the encrypted message. If the message length exceeds the maximum allowed length, an error is returned."
openssl-101f,O2,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O2_extraction/RSA_verify_PKCS1_PSS@00628440.c,"The function RSA_verify_PKCS1_PSS and the RSA-PSS signature verification algorithm both verify a message using RSA signature with the PKCS#1 PSS padding scheme. They take in parameters such as a pointer to an RSA structure, a message hash, an EVP_MD structure, a signature in the form of an encoded message, and the length of the signature. Both functions initialize variables, calculate the size of the message digest algorithm, and check if the signature length is valid. They also calculate the size of the RSA key and salt used in the PSS algorithm. The functions then calculate the message digest of the input message using the specified hash function and check if it matches the input signature. Finally, the functions clean up and return either an error or success."
openssl-101f,O2,mips,sha_block_data_order,./data/decomp/openssl-101f_mips_gcc_O2_extraction/sha_block_data_order@00620b30.c,"The functions described are all related to the SHA-1 hashing algorithm. They take in input data and perform a series of bitwise operations, additions, and multiplications with constants to generate a unique hash value. The specific operations performed in each function are complex and difficult to understand without more context. The functions use a variety of variables to store intermediate results, which are combined in various ways to produce the final output. Overall, the functions are designed for efficiency rather than readability."
openssl-101f,O2,mips,SHA_Final,./data/decomp/openssl-101f_mips_gcc_O2_extraction/SHA_Final@00621fdc.c,"The SHA_Final function is the final step of the SHA hashing process. It takes in a pointer to an output buffer (md) and a pointer to a SHA_CTX structure (c) that contains the intermediate hash values and the message data. The function adds a padding byte to the message data and fills the remaining space with zeros if necessary. It then appends the length of the original message as two 32-bit integers to the end of the message data. Next, it calls the sha_block_data_order function to perform the final hash computation using the padded message data and the intermediate hash values stored in the SHA_CTX structure. After the hash computation is complete, the function stores the resulting hash value in the output buffer (md) as a sequence of bytes in little-endian order. Finally, the function resets the SHA_CTX structure and returns a value of 1 to indicate success."
openssl-101f,O2,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_mips_gcc_O2_extraction/SSL_SESSION_free.part.2@004b0e94.c,"The function frees memory allocated for an SSL session, including additional data associated with the session using CRYPTO_free_ex_data(), cleansing memory using OPENSSL_cleanse(), and freeing certificate information, X509 certificates, and stacks of certificates using appropriate function pointers. It also frees other areas of memory associated with the session, including pointers and buffers, and cleanses the entire session memory block before freeing it using CRYPTO_free()."
openssl-101f,O2,mips,start_hash,./data/decomp/openssl-101f_mips_gcc_O2_extraction/start_hash@0061feb8.c,"The function takes in a pointer to an array of four 32-bit integers as its parameter. It checks if the third element of the array is not equal to zero. If it is not zero, it sets the fourth element and the twelfth element of the array to zero using the memset function. It also sets the third element, the first element, and the value pointed to by the parameter itself to zero. Finally, it returns 1 to indicate success. If the third element of the array is zero, it returns 0 to indicate failure."
openssl-101f,O2,mips,surewarehk_finish,./data/decomp/openssl-101f_mips_gcc_O2_extraction/surewarehk_finish@005d8534.c,"The function checks if the surewarehk_dso variable is equal to zero. If it is, it logs the error using the SUREWARE_lib_error_code and PTR_ERR_put_error_006a9030 function. If not, it finishes using the SureWare hardware security module using the p_surewarehk_Finish function and frees the SureWare library using the PTR_DSO_free_006a9994 function. If the PTR_DSO_free_006a9994 function returns zero, it logs the error using the SUREWARE_lib_error_code and PTR_ERR_put_error_006a9030 function. If it returns non-zero, it sets the uVar2 variable to 1. If the logstream variable is not equal to zero, it performs some additional action."
openssl-101f,O2,mips,sv_body,./data/decomp/openssl-101f_mips_gcc_O2_extraction/sv_body@00442f98.c,"1. The function `sv_body` handles the server-side of a TLS/SSL connection. It allocates memory, sets up TLS extensions, reads and writes data, handles errors and timeouts, outputs debugging information, and handles renegotiation and certificate status requests.

2. The function initializes variables, checks if SSL_accept() was successful, performs SSL handshake, and returns success or failure.

3. The function sets up the SSL context, loads certificates and private keys, creates the SSL connection, sets up input and output BIOs, handles SRP authentication, listens for incoming connections, reads data, handles statistics requests, performs renegotiation, and exits on client connection close.

4. The function prints SSL connection information to the console, reads input, performs actions based on input, and exits on ""q"" input.

5. The function implements the SSL/TLS protocol for a client, initializes the SSL library, sets up the SSL context, creates a socket, sends and receives SSL hello messages, performs SSL/TLS handshakes, handles errors, and prints debug information.

6. The function handles incoming HTTP requests, sends appropriate responses, checks file validity, sends error messages, and performs SSL-related operations and memory management."
openssl-101f,O2,mips,__do_global_ctors_aux,./data/decomp/openssl-101f_mips_gcc_O2_extraction/__do_global_ctors_aux@00631900.c,"This function initializes a C++ program by calling the constructors for all global objects. It checks if there are any constructors to be called by checking the value of the __CTOR_LIST__ variable. If there are, it iterates through the list of constructors and calls each one in turn until it reaches the sentinel value of -1. Once all constructors have been called, the function returns."
openssl-101f,O2,mips,__libc_csu_init,./data/decomp/openssl-101f_mips_gcc_O2_extraction/__libc_csu_init@00631850.c,"The function initializes the C runtime environment by calling a function pointer at PTR__init_006aaa30, which likely sets up global variables and initializes libraries. It then returns."
openssl-101f,O2,mips,__start,./data/decomp/openssl-101f_mips_gcc_O2_extraction/__start@00421540.c,"The function ""__start"" initializes local variables, including two undefined arrays, and sets the value of ""local_10"" to the address of ""__libc_csu_fini_006a7f00"". It then calls ""__libc_start_main_006aab2c"" with the address of ""main"" as the first argument, ""local_res0"" as the second argument, ""auStackX_4"" as the third argument, and the address of ""__libc_csu_init_006a7efc"" as the fourth argument. This function is likely responsible for initializing the C runtime environment and calling the ""main"" function. Finally, the function enters an infinite loop to keep the program running."
openssl-101f,O2,mips,__udivdi3,./data/decomp/openssl-101f_mips_gcc_O2_extraction/__udivdi3@00630f60.c,"The functions perform mathematical operations on input parameters. 

Function 1: It performs unsigned division of two 64-bit integers using a modified version of the long division algorithm. The function takes four unsigned integers as input and returns the quotient of the division as a 64-bit unsigned integer. It first checks if the divisor is equal to zero, then performs long division algorithm, calculating the quotient digit by digit.

Function 2: It takes in six parameters and performs a series of bitwise operations on the parameters and stores the results in various variables. The function then checks if a value derived from the parameters is equal to zero, and if so, calls the trap function with a parameter of 7. If not, it divides another value derived from the parameters and stores the result. It then calculates another value and checks again if the first value is equal to zero and calls the trap function if it is."
openssl-101f,O3,mips,aep_mod_exp.part.0,./data/decomp/openssl-101f_mips_gcc_O3_extraction/aep_mod_exp.part.0@005cf33c.c,"The functions all involve implementing modular exponentiation using the AEP library. They take in various parameters, initialize variables, and call the AEP_ModExp function to perform the operation. If the operation is successful, they update a flag or return the result. If there is an error, they set an error code and return it. The functions also have error-handling checks and may recursively call themselves or open a connection to the AEP device. Some functions also check if the AEP library has been loaded and attempt to load it if not."
openssl-101f,O3,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101f_mips_gcc_O3_extraction/asn1_bio_callback_ctrl@0062aca0.c,"The function is a callback function for an ASN.1 BIO object. It checks if the BIO object has been initialized by checking a field in the object. If the field is not zero, it jumps to an address stored in a global variable PTR_BIO_callback_ctrl_006a9548, which is likely a function pointer to a callback function. If the field is zero, the function returns 0. The function takes an integer parameter, which is a pointer to a BIO object."
openssl-101f,O3,mips,asn1_bio_ctrl,./data/decomp/openssl-101f_mips_gcc_O3_extraction/asn1_bio_ctrl@0062ad94.c,"The function asn1_bio_ctrl takes four parameters: two integers, an undefined value, and a pointer to an integer. It checks if the pointer to an integer stored in the 0x20 offset of the first parameter is null. If it is, the function returns 0. If the second parameter is equal to 0x97, the function sets the 10th and 11th values in the integer array pointed to by the pointer stored in the 0x20 offset of the first parameter to the first and second values in the integer array pointed to by the fourth parameter, respectively, and returns 1. If the second parameter is less than 0x98, the function checks if it is equal to 0x95. If it is, the function sets the 8th and 9th values in the integer array pointed to by the pointer stored in the 0x20 offset of the first parameter to the first and second values."
openssl-101f,O3,mips,asn1_bio_free,./data/decomp/openssl-101f_mips_gcc_O3_extraction/asn1_bio_free@0062acc4.c,"The function `asn1_bio_free` takes an integer parameter `param_1` and frees memory allocated by the parameter. It retrieves the value of an integer variable `iVar1` stored at an offset of `0x20` from the memory address pointed to by `param_1`. If `iVar1` is not equal to zero, the function checks if the value stored at an offset of `0x4` from the memory address pointed to by `iVar1` is also not equal to zero. If it is not zero, the function calls a function at the address pointed to by the global variable `PTR_CRYPTO_free_006a7f88` to free the memory pointed to by the value stored at the offset `0x4` from `iVar1`. The function then calls the same function at the address pointed to by `PTR_CRYPTO_free_006a7f88` to free the memory pointed to by `iVar1`."
openssl-101f,O3,mips,asn1_bio_write.part.1,./data/decomp/openssl-101f_mips_gcc_O3_extraction/asn1_bio_write.part.1@0062b180.c,"The function takes in three parameters: an integer, a second integer, and a pointer to a uint. 

If the uint pointer is null, the function returns the value of the integer variable `iVar3`. 

If the uint pointer is not null, the function reads the value of the first uint in the array pointed to by the uint pointer. Depending on the value of this uint, the function performs different actions. 

If the uint is less than 5, the function enters a loop. Within the loop, the function performs different actions depending on the value of the uint. If the uint is 0x62b21c, the function calls another function to calculate the size of. 

If the second integer is non-zero and the uint pointer is greater than -1 and the integer value at the address of the first integer plus 0x24 is not zero, the function calls itself recursively."
openssl-101f,O3,mips,asn1_bio_write,./data/decomp/openssl-101f_mips_gcc_O3_extraction/asn1_bio_write@0062b500.c,"The function takes in three integer parameters: param_1, param_2, and param_3. If param_2 is not equal to 0, param_3 is greater than -1, and the value at the memory address (param_1 + 0x24) is not equal to 0, then the function calls another function called asn1_bio_write_part_1() and returns its result. Otherwise, the function returns 0."
openssl-101f,O3,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BIO_asn1_get_suffix@0062b724.c,"The function takes in a BIO object and two pointers to pointers of type undefined1, and returns an integer value. It initializes a local variable to the value of the stack guard variable, calls the BIO_ctrl function with certain parameters, and stores the return value in an integer variable. If the value of the integer variable is greater than 0, it assigns certain values to the pointers pointed to by psuffix and psuffix_free. Finally, the function checks if a certain variable is equal to the stack guard variable and returns the value of the integer variable if they are equal, otherwise it does not return a value."
openssl-101f,O3,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BIO_asn1_set_prefix@0062b5b0.c,"The function BIO_asn1_set_prefix initializes variables and calls the BIO_ctrl function with arguments. It returns the value of the function call if the stack guard variable before and after the function call is the same. If the value of iVar3 is greater than 0, it sets the values of two pointers to variables. The function then repeats the process with different arguments and returns the value of _bignum_nist_p_192."
openssl-101f,O3,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_get0_nist_prime_224@0062b7cc.c,"The `BN_get0_nist_prime_224` function returns a pointer to a `BIGNUM` object containing the NIST prime number for 224-bit elliptic curve cryptography. The value is stored in `_bignum_nist_p_224`, likely a global variable. The warning message indicates an unknown calling convention, which may cause compatibility issues with the function's compilation."
openssl-101f,O3,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_get0_nist_prime_384@0062b7e4.c,"The function returns a pointer to a BIGNUM object containing a pre-defined prime number used in NIST P-384 elliptic curve cryptography. It uses the constant value ""_bignum_nist_p_384"" to return the object. The calling convention is unknown, but the parameter storage is locked."
openssl-101f,O3,mips,BN_GF2m_add,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_add@00624434.c,"The function BN_GF2m_add adds the second and third arrays in the Galois field GF(2^m) and stores the result in the first array. It takes three parameters, which are pointers to arrays of unsigned integers (uint). The function first checks which of the two arrays has the larger size and assigns the smaller array to the variable puVar4 and the larger array to the variable puVar5. The function then checks if the size of the first array is less than the size of the larger array. If so, it expands the size of the first array using the BN_GF2m_expand function. The function then iterates through the arrays, XORing the corresponding elements of puVar2 (which points to the smaller array) and puVar5 (which points to the larger array) and storing the result in."
openssl-101f,O3,mips,BN_GF2m_mod,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod@006246b4.c,"The first function is for performing Galois field arithmetic for binary fields (GF(2^m)). It takes in a BN_CTX pointer, an integer pointer representing the irreducible polynomial, and an array of integers representing the input value to be reduced modulo the polynomial. It expands the input array, performs bitwise operations and table lookups to compute the reduced value, and stores it in the output array.

The second function takes in a BN_CTX pointer, two BIGNUM pointers (param_1 and param_2), and an array of unsigned integers (param_3). It returns an unsigned integer. It initializes variables, checks if either BIGNUM is zero, and checks if param_1 and param_2 are the same pointer. If they are, it adds the contents of param_1 and param_2 modulo param_3. If they are not the same pointer, it checks the size of param_1 and swaps pointers if necessary before performing the addition."
openssl-101f,O3,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_arr@006245c0.c,"The function BN_GF2m_mod_arr takes four parameters: param_1, param_2, param_3, and param_4. If the value pointed to by param_3 is 0, the function sets the value pointed to by param_1 to 0 and returns 1. Otherwise, it proceeds to the next step. If param_1 and param_2 are not pointing to the same location in memory, the function checks if the second element of param_2 is greater than the third element of param_1. If it is, the function expands the memory allocated to param_1 using the function bn_expand2. If the expansion fails (returns 0), the function returns 0. Otherwise, it proceeds to copy the contents of param_2 to param_1. The function then calls the function BN_GF2m_mod_arr_part_0 with param_1 and param_3 as parameters and returns the result."
openssl-101f,O3,mips,BN_GF2m_mod_div,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_div@006262f0.c,"The function BN_GF2m_mod_div performs modular division of param_1 and param_2 with respect to param_3 in the Galois field GF(2^m), where m is the degree of param_3. The result is stored in param_1. It first initializes a BN_CTX object and retrieves a new BIGNUM object. If the object is not equal to zero, the function calls the BN_GF2m_mod_inv function to compute the inverse of param_3 in the Galois field GF(2^m) and stores it in iVar1."
openssl-101f,O3,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_div_arr@00626508.c,"The function BN_GF2m_mod_div_arr takes in five parameters: two arrays of binary polynomials, an integer modulus, an array of binary polynomial used for division, and a context variable for memory allocation. It initializes a variable and sets the bit at the indices specified by the values in the division array. It then calculates the inverse of the modulus and returns false if the calculation fails. Finally, the function allocates memory for the required number of bits."
openssl-101f,O3,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_mul@006256f0.c,"The function takes in five parameters: three integers and two pointers. It calculates the number of bits in the second parameter (an integer array) and allocates memory for an array of size (number of bits + 1) * 4. If the memory allocation fails, it returns 0. It extracts the number of words in the second parameter and checks if it is zero. If it is, it sets the result to 0 and skips the rest of the function. Otherwise, it loops through each word in the second parameter and checks if it contains any non-zero bits. If it does, it adds the position of the non-zero bit to the array allocated earlier. Once all words have been checked, it sets the last element of the array to 0xffffffff if the array is not fully populated. Finally, it calls the BN_GF2m_mod_mul_arr function with the first three parameters and the array of non-zero bit positions as the fourth parameter. It then frees the allocated memory."
openssl-101f,O3,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_mul_arr@00624b58.c,"The first function, BN_GF2m_mod_mul_arr, performs modular multiplication of two polynomials represented as arrays of uints in GF(2^m) field. It checks if the input polynomials are the same and computes the square of the polynomial using a lookup table called SQR_tb. If the output polynomial is not large enough to hold the result, it expands it using the bn_expand2 function. It then performs the modular reduction using the BN_GF2m_mod_arr_part_0 function. If the input polynomials are different, it allocates a temporary buffer using the BN_CTX_get function.

The second function performs various bitwise operations on several input parameters using a lookup table called ""local_4c"" to generate a new value. It checks if certain bits in the input parameters are set and performs additional XOR and right shift operations if they are. Finally, it updates the lookup table with the new value generated and repeats the process with a different input parameter. It appears to be a complex hashing or encryption function.

The third function, BN_mod_mul_montgomery, takes in five parameters and returns either 1 or 0, indicating success or failure. It checks if the source BN is zero or if the modulus BN is zero. If both the source and modulus BNs are non-zero, it checks if the source BN is greater than or equal to the modulus BN. It then enters a loop that iterates over the bits of the source BN and performs some calculations involving the modulus BN.

The fourth function computes the product of two arrays modulo the polynomial in GF(2^m) field. It checks if either of the input arrays are empty or if their degree is greater than or equal to the given degree. It initializes several variables including pointers to the input arrays, a temporary array, and a pointer to the generator polynomial. It then loops through each element in the first input array and for each non-zero element, it loops through each bit in the element and checks if it is set. If the bit is set, it computes the corresponding power of the generator polynomial and stores it in the temporary array."
openssl-101f,O3,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_sqr@006258e4.c,"The function BN_GF2m_mod_sqr calculates the square of a binary polynomial represented as an array of integers in GF(2^m) field. It first calculates the number of bits in the polynomial and allocates memory for a new array to store the result. It then scans the input array to find the set bits, and stores their positions in the new array. If the input array is zero, the result is also zero. The function then calls the BN_GF2m_mod_sqr_arr function to calculate the square of the polynomial using the stored positions of the set bits. Finally, it frees the memory allocated for the new array and returns the result of the square calculation. If there is an error, it sets an error code and returns it."
openssl-101f,O3,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_sqrt@00626d24.c,"The OpenSSL library function BN_GF2m_mod_sqrt computes the square root of a binary polynomial in the finite field GF(2^m). It takes four parameters - a pointer to a BIGNUM structure to hold the computed square root, a pointer to a BIGNUM structure holding the binary polynomial, a pointer to an array of integers representing the binary polynomial modulus, and a pointer to a BN_CTX structure for temporary storage. The function allocates an array of integers of size (num_bits + 1) * 4 and computes the square root."
openssl-101f,O3,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_GF2m_mod_sqr_arr@006248a0.c,"The function BN_GF2m_mod_sqr_arr performs the squaring operation on a polynomial represented as an array of uints in GF(2^m) field. It takes four parameters: param_1 is a pointer to the output array, param_2 is a pointer to the input array, param_3 is a pointer to the modulus polynomial, and param_4 is a pointer to a BN_CTX structure used for temporary storage. The function initializes the BN_CTX structure using the provided pointer to temporary memory and allocates memory for the output array using the BN_CTX structure. If memory allocation fails, the function returns false. The function performs the squaring operation on the input array and stores the result in the output array using a precomputed table SQR_tb to perform the squaring operation efficiently. The squaring operation is performed by iterating over the input array and computing the square of each element using the table. The result is stored in the output."
openssl-101f,O3,mips,BN_kronecker,./data/decomp/openssl-101f_mips_gcc_O3_extraction/BN_kronecker@00623300.c,"The BN_kronecker function calculates the Kronecker symbol (a/b) using the algorithm described in the function. It takes two BIGNUMs as input (a and b). The function first initializes a BN_CTX context to manage temporary variables used in the calculation. It then checks if the second input BIGNUM is even or zero. If it is, the Kronecker symbol is zero and the function returns immediately. If the first input BIGNUM is one, the Kronecker symbol is one and the function returns immediately. If neither of these conditions are true, the function enters a loop where it repeatedly divides the second input BIGNUM by 2 until it is."
openssl-101f,O3,mips,by_dir_entry_free,./data/decomp/openssl-101f_mips_gcc_O3_extraction/by_dir_entry_free@00587a40.c,"The function takes in an integer pointer `param_1` and checks if the value pointed to by `param_1` is not equal to zero. If it is not zero, it calls a function at the address `PTR_CRYPTO_free_006a7f88` to free the memory pointed to by `param_1`. It also checks if the value at index 2 of `param_1` is not equal to zero. If it is not zero, it calls a function at the address `PTR_sk_pop_free_006a8158` to free the memory pointed to by `param_1[2]` with a custom function `by_dir_hash_free`. Finally, it calls the function at the address `PTR_CRYPTO_free_006a7f88` to free the memory pointed to by `param_1`. Note that the function contains a jump table at address `0x00587aa0`, but it could not be recovered during decompilation."
openssl-101f,O3,mips,cswift_rand_bytes,./data/decomp/openssl-101f_mips_gcc_O3_extraction/cswift_rand_bytes@005d2070.c,"The functions are all related to performing cryptographic operations using different libraries such as CSwift and OpenSSL. They involve initializing variables, checking input parameters, acquiring access contexts, and performing cryptographic operations. Error handling and logging are also included in some functions. Some functions are wrappers for library functions, while others are decompiled versions of C functions. Overall, the functions are well-structured and organized, but without the context of the larger program, it can be difficult to fully understand their purpose and how they fit into the program as a whole."
openssl-101f,O3,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101f_mips_gcc_O3_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061cce0.c,"The function calls an external function through a pointer named PTR_ASN1_item_d2i_006a9798, which is not defined in the code and is likely defined in an external library or module. The function does not perform any other operations and simply returns after calling the external function."
openssl-101f,O3,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101f_mips_gcc_O3_extraction/d2i_GOST_KEY_PARAMS@0061cc20.c,The function is a wrapper that indirectly calls an unknown decoding function to convert binary data into a structured format defined by the GOST key parameters ASN.1 specification. It takes no arguments and simply calls the decoding function before returning. The specific decoding function being called is not known as the jumptable could not be recovered.
openssl-101f,O3,mips,decode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O3_extraction/decode_gost_algor_params@00619aac.c,"The function `decode_gost_algor_params` takes in two parameters, `param_1` and `param_2`, both of type `undefined4`. It initializes variables and retrieves algorithm parameters from `param_2`. If the length of the algorithm parameters is 16, it decodes the GOST key parameters and sets the type of `param_1` using `EVP_PKEY_set_type()`. If the decoding is successful, it sets the appropriate parameters for the `EVP_PKEY` object. The function returns a value indicating whether the decoding and setting of parameters was successful.

The function is an implementation of the OpenSSL GOST algorithm. It takes an EVP_PKEY structure as input, which contains a public key, and generates a new EVP_PKEY structure with the same public key but with a new private key. It first checks if the input EVP_PKEY is valid and has a GOST algorithm. If not, it returns 0. Next, it generates a new private key for the EC_KEY using the GOST R 34.10-2001 algorithm and computes the public key from the new private key. It then creates a new EVP_PKEY structure with the same GOST algorithm and the new EC_KEY structure. Finally, the function checks if the new EVP_PKEY was successfully created and returns 1 if it was, or 0 if there was an error."
openssl-101f,O3,mips,DES_xcbc_encrypt,./data/decomp/openssl-101f_mips_gcc_O3_extraction/DES_xcbc_encrypt@00622220.c,"The following are summaries of different encryption and decryption functions:

1. DES-XCBC encryption algorithm: This function encrypts input data using a key schedule and initialization vector. The input data is divided into blocks and processed using the DES algorithm. The result of each block is XORed with the previous block and the initialization vector to generate the output block.

2. AES encryption algorithm: This function encrypts a plaintext message using a key and initialization vector. It generates a round key schedule and processes the input message in blocks, XORing each block with the previous block's encrypted output (or the IV for the first block), and encrypting the result using the key schedule.

3. Blowfish decryption algorithm: This function decrypts input data using a key schedule and initialization vector. It processes the input data in blocks using the Blowfish algorithm and updates the initialization vector with the current block of decrypted data.

4. Blowfish cipher in output feedback (OFB) mode: This function encrypts input data using the Blowfish algorithm and an initialization vector. It loops through the input buffer, XORing each byte with the output of the Blowfish cipher in OFB mode.

5. OFB mode of the Blowfish encryption algorithm: This function encrypts a plaintext message using a key and initialization vector. It initializes the OFB mode by encrypting the IV using the Blowfish algorithm with the given key. It then XORs the resulting ciphertext with the plaintext message to produce the ciphertext.

6. Encryption and modular arithmetic function: This function performs encryption and XOR operations on a block of data and sets certain values in memory based on the results. It also includes checks for buffer overflows and other errors."
openssl-101f,O3,mips,dgram_ctrl,./data/decomp/openssl-101f_mips_gcc_O3_extraction/dgram_ctrl@0052cd98.c,These function summaries describe various functions with different purposes. The first function takes in parameters and performs operations based on the value of an integer parameter. The second function sets or retrieves socket options based on the value of the first parameter. The third function implements SSL BIO control operations based on the input control code. The fourth function handles I/O operations for a BIO object.
openssl-101f,O3,mips,dlfcn_bind_func,./data/decomp/openssl-101f_mips_gcc_O3_extraction/dlfcn_bind_func@00629ea4.c,"The function takes two integer parameters, param_1 and param_2. If either parameter is equal to 0, it sets two variables (uVar2 and uVar3) to specific values (0x43 and 0x110). Otherwise, it calls the function at memory address PTR_sk_num_006a7f2c with the value at memory address (param_1 + 4) as its parameter and assigns the result of this function call to the variable iVar1. If iVar1 is less than 1, it sets uVar2 and uVar3 to different values (0x69 and 0x115). Otherwise, it assigns the value at memory address (param_1 + 4) to uVar3, calls the function at memory address PTR_sk_num_006a7f2c with uVar3 as its parameter, and assigns the result of this function call minus 1 to a variable."
openssl-101f,O3,mips,dlfcn_bind_var,./data/decomp/openssl-101f_mips_gcc_O3_extraction/dlfcn_bind_var@0062a018.c,"The function dlfcn_bind_var takes in two integer parameters: param_1 and param_2. If either parameter is equal to 0, it sets two variables uVar2 and uVar3 to 0x43 and 0xee respectively. If both parameters are non-zero, the function calls the function at memory address PTR_sk_num_006a7f2c with the value stored at memory address param_1 + 4 as its argument. It stores the result in the variable iVar1. If the value of iVar1 is less than 1, the function sets uVar2 and uVar3 to 0x69 and 0xf3 respectively. If the value of iVar1 is greater than or equal to 1, the function retrieves the value stored at memory address param_1 + 4 and calls the function at memory address PTR_sk_num_006a7f2c with this value as its argument."
openssl-101f,O3,mips,dlfcn_globallookup,./data/decomp/openssl-101f_mips_gcc_O3_extraction/dlfcn_globallookup@00629a60.c,"The function uses dynamic linking to look up the address of a symbol named by the parameter `param_1`. It first opens the dynamic library specified by the first argument using `dlopen` and loads it in global scope. If `dlopen` fails, the function returns 0. Otherwise, it looks up the symbol in the library using `dlsym`, stores the return value in `uVar2`, and closes the library using `dlclose` with `iVar1` as an argument. The function then returns `uVar2`."
openssl-101f,O3,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_mont_field_encode@00627d3c.c,"The function ""ec_GFp_mont_field_encode"" takes four parameters: param_1, param_2, param_3, and param_4. Param_1 is a pointer to a data structure and is used to access a specific offset (0xa0) later in the function. Param_2 and param_3 are likely inputs to the function, as they are passed as arguments to another function call along with values obtained from accessing the data structure at offset 0xa0. Param_4 is also likely an input to the function and is passed as an argument to the same function call mentioned above."
openssl-101f,O3,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_mont_field_sqr@00627cc4.c,"The function `ec_GFp_mont_field_sqr` takes four parameters and checks if the value stored at the memory address `param_1 + 0xa0` is not equal to zero. If it is not zero, it calls another function with specific parameters and returns the result. If the value stored at `param_1 + 0xa0` is zero, it calls another function with specific parameters."
openssl-101f,O3,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_mont_group_init@006277b0.c,The function initializes a Montgomery group for elliptic curve cryptography (ECC) using the parameters passed in as argument `param_1`. It calls `ec_GFp_simple_group_init()` to initialize a simple ECC group and sets two variables in the Montgomery group to zero. These variables are used for internal computations in the Montgomery multiplication algorithm. The function then returns.
openssl-101f,O3,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_nist_field_mul@0062815c.c,"The function takes in five integer parameters and performs multiplication and squaring operations. It first checks if any of the first four parameters are equal to zero, and if so, it calls a function to raise an error. If the fifth parameter is equal to zero, it creates a new BN_CTX object and uses it to perform a multiplication operation between the second and third parameters, storing the result in the fourth parameter. It then squares the result using a function pointer stored in the first parameter + 0x48. If the fifth parameter is not equal to zero, it simply performs the multiplication and squaring operations using the fifth parameter as the BN_CTX object. The function returns a boolean value indicating whether the operations were successful."
openssl-101f,O3,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_nist_group_copy@00627ea0.c,"The `ec_GFp_nist_group_copy` function copies one elliptic curve group to another, with the exception of the `order_bits` field which is explicitly copied. It takes two parameters, `param_1` and `param_2`, which are pointers to structures representing elliptic curve groups. The function copies the value of the `order_bits` field from the second group to the first group by dereferencing the pointers and accessing the `order_bits` field. Then, the function calls `ec_GFp_simple_group_copy` to copy the rest of the fields from the second group to the first group. Finally, the function returns."
openssl-101f,O3,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_nist_group_set_curve@00627eb8.c,"The function `ec_GFp_nist_group_set_curve` takes in four parameters: `param_1` (an integer), `param_2`, `param_3`, and `param_4` (all undefined 4-byte values), and `param_5` (an integer). It checks if `param_5` is equal to 0, and if so, it allocates memory for a new BN_CTX object and assigns the result to `param_5`. If `param_5` is not equal to 0, it starts the BN_CTX object and gets a BIGNUM object from it. If the allocation fails or `iVar3` is 0, the function returns 0."
openssl-101f,O3,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062e000.c,"This function takes six parameters: an EC_GROUP pointer, an EC_POINT pointer, and four BIGNUM pointers. If the EC_GROUP is uninitialized, the function copies the x and y coordinates of the EC_POINT into the BIGNUMs pointed to by param_3 and param_4, and the z coordinate into the BIGNUM pointed to by param_5 if it is not null. If the EC_GROUP is initialized, the function creates a new BN_CTX if param_6 is null, and uses the EC_GROUP's point conversion function to convert the x and y coordinates of the EC_POINT into projective coordinates."
openssl-101f,O3,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_group_check_discriminant@0062e1ec.c,"The function checks the discriminant of an elliptic curve group represented by the parameters passed in. If the discriminant is not a square, the group is non-trivial and the function returns true. The function initializes a new BN_CTX object and allocates memory for several big integers using the BN_CTX functions. It then checks if the discriminant parameter passed in is zero and initializes a new big integer for the discriminant using the BN_CTX functions. Next, it sets up several more big integers using the BN_CTX functions and checks if the group has a custom discriminant function. If it does not, it copies the discriminant value from the parameters into one of the big integers. If it does, it calls the custom discriminant function to calculate the discriminant and stores the result in one of the big integers. It then checks if the discriminant is a square by performing some big integer arithmetic using."
openssl-101f,O3,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_group_clear_finish@0062db04.c,The function takes an integer parameter and clears and frees memory used by a simple elliptic curve group structure in OpenSSL's cryptographic library. It calls three different functions with specific parameters and returns without any value.
openssl-101f,O3,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_group_copy@0062f054.c,"The function copies the contents of one elliptic curve group to another in the OpenSSL library. It takes two parameters, both are pointers to elliptic curve group structures. The function copies the ""order"" and ""field"" fields of the second group to the corresponding fields of the first group, and also copies the ""a"" and ""b"" parameters of the second group to the corresponding parameters of the first group. If all operations are successful, the function returns 1, otherwise it returns 0."
openssl-101f,O3,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_group_get_degree@0062dbb4.c,The function retrieves the degree of the elliptic curve group specified by the parameter `param_1` by calling another function with the argument `param_1 + 0x48`. The specific implementation of the called function is not shown.
openssl-101f,O3,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_group_set_curve@0062f194.c,"The function ec_GFp_simple_group_set_curve sets the curve parameters for an elliptic curve group in the OpenSSL library. It takes in parameters such as an integer array and a pointer to a uint array. The function checks if the curve parameters meet certain conditions and returns 0 if they do not. If the conditions are met, the function initializes a BN_CTX object and copies the curve parameters from param_2 to it."
openssl-101f,O3,mips,ec_GFp_simple_invert,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_invert@00630104.c,"The function takes two parameters, param_1 and param_2, and inverts an element in a finite field. It first checks if a point on an elliptic curve is at infinity using a function at address PTR_EC_POINT_is_at_infinity_006a9770. If the point is not at infinity and a value at offset 0x1c of param_2 is not equal to zero, it subtracts the value at offset 0x48 of param_1 from the value at offset 0x18 of param_2 using a function at address PTR_BN_usub_006a96d4. If these conditions are not met, the function returns 1."
openssl-101f,O3,mips,EC_GFp_simple_method,./data/decomp/openssl-101f_mips_gcc_O3_extraction/EC_GFp_simple_method@00630f54.c,"The function returns a pointer to an elliptic curve method structure for operations on simple elliptic curves over the field of integers modulo a prime. The implementation details are not provided, and a warning message suggests potential issues with the function's calling convention."
openssl-101f,O3,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_point_copy@0062f0f4.c,"The function `ec_GFp_simple_point_copy` copies the x, y, and z coordinates of the second point to the first point on an elliptic curve. It uses `BN_copy` to copy the x-coordinate of `param_2` to `param_1`, and then copies the y-coordinate of `param_2` to `param_1`."
openssl-101f,O3,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_point_finish@0062dab0.c,The function frees the memory allocated to three pointers located at specific offsets from an integer parameter. It uses a function pointer to call BN_free for memory deallocation.
openssl-101f,O3,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_point_get_affine_coordinates@0062e4f0.c,"The function takes in five integer parameters and returns a boolean value. It calls another function at address PTR_EC_POINT_is_at_infinity_006a9770, which returns an integer value. If the value is not equal to zero, the function calls another function at address PTR_ERR_put_error_006a9030 with four integer arguments and returns false. If the value is equal to zero, the function checks if the fifth parameter is equal to zero. If it is, the function calls another function at address PTR_BN_CTX_new_006a8a38 to allocate memory for a new BN_CTX object. If this allocation fails, the function returns false. The function then calls another function at address PTR_BN_CTX_start_006a9644 to initialize the BN_CTX object. It retrieves four integer values from the BN_CTX object using another function at address PTR_BN_CTX_get_006a9648."
openssl-101f,O3,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101f_mips_gcc_O3_extraction/ec_GFp_simple_point_set_affine_coordinates@0062f494.c,"The function ""ec_GFp_simple_point_set_affine_coordinates"" takes five parameters: two 4-byte variables, two integer variables, and another undefined 4-byte variable. It checks if the integer variables are non-zero and calls two functions using function pointers if they are. The first function returns a pointer to a constant value of 1, which is stored in a variable. The second function sets the coordinates of a point on an elliptic curve in Jacobian projective form, given the affine coordinates of the point and a constant value of 1, and returns a value that is then returned by the current function. If either integer variable is zero, the function calls another function using a function pointer."
openssl-101f,O3,mips,encode_gost_algor_params,./data/decomp/openssl-101f_mips_gcc_O3_extraction/encode_gost_algor_params@0061b110.c,"The functions are all related to handling and encoding GOST algorithms in the OpenSSL library. 

The function `encode_gost_algor_params` takes an integer pointer `param_1` as input and returns an integer pointer `piStack_64`. It allocates memory for pointers to integers and undefined 4-byte values, checks if the pointers are null, determines the type of `param_1`, gets the group associated with the key, gets the curve name, and encodes the algorithm parameters. 

The function responsible for handling GOST algorithms takes a pointer to an EVP_PKEY structure as input and performs various operations on it. It checks if the pointer is valid, gets the algorithm name and related parameters, performs operations on the input parameters, encodes the algorithm parameters, checks the algorithm name, performs specific operations based on the name, and returns a pointer to an integer value. 

The function responsible for encoding and decoding GOST algorithms takes a public or private key as input and returns the encoded or decoded data. It checks if the input key is valid, calls the appropriate encoding or decoding function depending on the type of the key, encodes the GOST algorithm parameters, encodes the key data, and prints the encoded data to the console. 

The decompiled function is responsible for printing information about a GOST key pair. It takes a pointer to an EVP_PKEY structure as input and returns a pointer to an integer. It declares and initializes several variables, checks whether the input pointer is null, retrieves the key type and private and public keys, prints the private and public keys along with the parameter set, calculates and prints the x and y coordinates of the public key, and returns a pointer to an integer."
openssl-101f,O3,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101f_mips_gcc_O3_extraction/general_allocate_boolean.constprop.5@005b32bc.c,"The function `general_allocate_boolean_constprop_5` takes in eight parameters: `param_1`, `param_2`, `param_3`, `param_4`, `param_5`, `param_6`, `param_7`, and `param_8`. If `param_4` is equal to `NULL`, the function returns `-1`. Otherwise, it checks if `param_5` is not equal to `0`. If `param_5` is not equal to `0`, the function loops through the characters in `param_4` and checks if each character is a valid input character. If any character is not a valid input character, the function returns `-1`. Next, the function checks if `param_2` is equal to `0`. If `param_2` is equal to `0`, the function returns `-1`. If `param_8` is not equal to `0`, the function allocates memory for an object."
openssl-101f,O3,mips,get_gost_engine_param,./data/decomp/openssl-101f_mips_gcc_O3_extraction/get_gost_engine_param@0061ee48.c,"The function ""get_gost_engine_param"" takes an integer parameter ""param_1"" and returns an integer value. If ""param_1"" is equal to 0, the function checks if the global variable ""gost_params"" is equal to 0. If it is, the function gets the value of the environment variable ""CRYPT_PARAMS"" using the function ""getenv"", and if it is not null, it duplicates the string using the function ""BUF_strdup"" and assigns it to ""gost_params"". The function then returns the value of ""gost_params"". If ""param_1"" is not equal to 0, the function returns 0."
openssl-101f,O3,mips,gost2001_param_encode,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost2001_param_encode@0061a1d4.c,"The function encodes parameters using the GOST R 34.10-2001 standard. It retrieves a key object and its associated elliptic curve group using OpenSSL library functions, gets the curve name and converts it to an ASN.1 object identifier using another OpenSSL function, and encodes the object identifier using i2d_ASN1_OBJECT function before returning the encoded data."
openssl-101f,O3,mips,gost_cipher_cleanup,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost_cipher_cleanup@0061cfe0.c,"The function `gost_cipher_cleanup` takes an integer parameter `param_1` and cleans up and deallocates resources associated with a GOST cipher. It calls the `gost_destroy` function with an argument that is a pointer to a memory location stored at an offset of 0xc from the value stored at an offset of 0x60 from `param_1`, likely destroying a previously created GOST cipher object. It then sets the value stored at an offset of 0x54 from `param_1` to 0 and returns the value 1."
openssl-101f,O3,mips,gost_cipher_ctl,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost_cipher_ctl@0061d874.c,"The function takes four parameters: param_1, param_2, param_3, and param_4. If param_2 is equal to 6, the function calls a code pointer stored at PTR_RAND_bytes_006a8d44 with param_4, the value at memory address (param_1 + 0x58), param_3, param_4, and a global pointer. The return value of this call is stored in iVar1. If iVar1 is less than 1, the function calls ERR_GOST_error with error code 0x6f and 0x7b, and sets uVar2 to 0xffffffff. Otherwise, uVar2 is set to 1. If param_2 is equal to 7, the function checks if param_4 is not equal to NULL. If it is not NULL, the value at memory address param_4 is set to 0x32a, and uVar2 is set to 1."
openssl-101f,O3,mips,gost_cipher_do_cnt,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost_cipher_do_cnt@0061d1dc.c,"The first function, `gost_cipher_do_cnt`, is a part of the GOST block cipher algorithm implementation that performs encryption using the counter (CTR) mode of operation. It takes a key schedule, plaintext, and buffer as inputs and updates the buffer pointers and counter accordingly.

The second function takes a pointer to a structure, a buffer, the size of the buffer, and a key as inputs and decrypts data stored in the structure using the key, copying it into the buffer. It checks if the buffer size is sufficient and sets a value in the structure indicating the number of bytes that were not copied if it is not. It then decrypts the data byte-by-byte using the key and copies the decrypted bytes into the buffer, updating the size of the data that has been copied."
openssl-101f,O3,mips,gost_cipher_init,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost_cipher_init@0061ea98.c,"This function checks if the cipher has been initialized and initializes it if it has not. It selects the appropriate cipher from a list of supported ciphers using the GOST engine parameter, initializes the cipher context with the selected cipher and key, copies the initialization vector to the appropriate offset in the cipher context, copies the initialization vector to the offset used for storing the previous block's ciphertext in CBC mode, and returns 1 to indicate success."
openssl-101f,O3,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O3_extraction/GOST_CIPHER_PARAMS_new@0061ccb0.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using ASN.1 encoding rules and returns it.
openssl-101f,O3,mips,gost_imit_final,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost_imit_final@0061e800.c,"The function takes in two parameters, an integer and an undefined value. It initializes some variables and retrieves some values from the integer parameter. It then checks if a certain value in the integer parameter is equal to zero and if so, it calls a function to report an error and then jumps to a label. Otherwise, it retrieves another value from the integer parameter and checks if a different value is equal to zero. If this value is not equal to zero, it sets some variables and jumps to another label. If it is equal to zero, it enters a while loop. Within the while loop, the function calls another function to get a message authentication code (MAC) using some values from the integer parameter and the undefined value passed in as a parameter. It then sets a variable to 1 and jumps to the label mentioned earlier. If the value of this label is equal to the value of a certain variable, the function returns this variable. Otherwise, it calls another function to perform some operations using some values from the integer parameter and the undefined value passed in as a parameter."
openssl-101f,O3,mips,gost_imit_init_cpa,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost_imit_init_cpa@0061d7ec.c,"The function initializes the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A. It takes four parameters, the first one is a pointer to a structure containing the encryption context, the second one is an integer parameter, and the last two are undefined. The function sets some initial values for the encryption context, including setting the encryption mode to 1, and setting all the key bytes to 0. It then calls the gost_init function, passing in the encryption context, the CryptoPro parameter set A, and the last two parameters. Finally, the function returns 1."
openssl-101f,O3,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101f_mips_gcc_O3_extraction/GOST_KEY_PARAMS_new@0061cc50.c,The function creates a new instance of GOST_KEY_PARAMS using ASN1_item_new with a function pointer obtained from PTR_ASN1_item_new_006a9778 and returns the new instance.
openssl-101f,O3,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101f_mips_gcc_O3_extraction/GOST_KEY_TRANSPORT_free@0061cb48.c,"The function takes in a 4-byte parameter, likely a pointer to a GOST_KEY_TRANSPORT structure, and calls PTR_ASN1_item_free_006a977c with the parameter and a reference to GOST_KEY_TRANSPORT_it to free memory associated with the structure before returning."
openssl-101f,O3,mips,gost_param_free,./data/decomp/openssl-101f_mips_gcc_O3_extraction/gost_param_free@0061ed70.c,"The function checks if ""gost_params"" is not equal to 0 and frees the memory allocated for the structure using a specified function. It then sets ""gost_params"" to 0 and returns."
openssl-101f,O3,mips,hash_step,./data/decomp/openssl-101f_mips_gcc_O3_extraction/hash_step@0061ef50.c,"The functions perform various cryptographic operations, likely part of a larger algorithm. One function takes in a 32-bit integer and two pointers to arrays of unsigned integers. It performs bitwise operations on the arrays, calls another function with the input integer and local variables, and returns the result. Another function takes in two pointers to arrays of integers and performs a series of bitwise operations and XOR operations between the arrays. The result is stored in local variables. The third function takes in pointers to plaintext, key, and ciphertext and performs the GOST encryption algorithm on the plaintext using the key. The resulting ciphertext is stored in the provided memory location. The fourth function takes in pointers to input, key, and output buffers and performs the GOST encryption algorithm using the key buffer on the input buffer. The final encrypted output is stored in the output buffer. The fifth function takes in four parameters and checks if the value at the address of one of the parameters is equal to a local variable. If it is not, it terminates the program. Otherwise, it allocates memory and calls the gost_init function with the allocated memory address and local variables."
openssl-101f,O3,mips,hwcrhk_init,./data/decomp/openssl-101f_mips_gcc_O3_extraction/hwcrhk_init@005d6a80.c,"The `hwcrhk_init` function initializes the nFast HWCryptoHook library by loading and binding its functions. It returns 1 if successful and 0 if there is an error, such as the library failing to load or necessary functions failing to bind. If mutex callbacks are not disabled, it also initializes the mutex functions and creates a new RSA key handle index."
openssl-101f,O3,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101f_mips_gcc_O3_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061cbd8.c,"The function i2d_GOST_KEY_AGREEMENT_INFO takes two parameters of type undefined4 and calls an indirect jump to a pointer likely pointing to the implementation of the function ASN1_item_i2d. It passes the two parameters and a third parameter, GOST_KEY_AGREEMENT_INFO_it, to the ASN1_item_i2d function to convert an ASN.1 structure to a DER-encoded format. The function returns without any further processing."
openssl-101f,O3,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101f_mips_gcc_O3_extraction/i2d_GOST_KEY_TRANSPORT@0061cb18.c,"The i2d_GOST_KEY_TRANSPORT function takes in two undefined4 parameters and calls an indirect jump to a function located at the address stored in the global variable PTR_ASN1_item_i2d_006a979c. This function likely encodes the data in a specific format (ASN1) for transmission over a network or storage in a file, taking in the two parameters passed to i2d_GOST_KEY_TRANSPORT as well as a third parameter, GOST_KEY_TRANSPORT_it. After the function call is complete, i2d_GOST_KEY_TRANSPORT returns."
openssl-101f,O3,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101f_mips_gcc_O3_extraction/load_pkcs12.constprop.4@004592d8.c,The function loads a PKCS12 file from a specified path and verifies its MAC using a provided password. It parses the file and returns the result if the verification succeeds. It includes error handling to prevent stack overflow and check for invalid input parameters.
openssl-101f,O3,mips,param_copy_gost94,./data/decomp/openssl-101f_mips_gcc_O3_extraction/param_copy_gost94@0061a670.c,"The function takes two parameters of type undefined4. It retrieves the base id of each parameter using the EVP_PKEY_base_id function and compares them. If they are not equal, an error message is printed and the function returns 0. It then checks if the second parameter has a valid pointer using the EVP_PKEY_get0 function. If it does not, an error message is printed and the function returns 0. If the second parameter has a valid pointer, the function checks if the first parameter has a valid pointer using the DSA_new function. If it does not, a new DSA object is created and assigned to the first parameter using the EVP_PKEY_assign function. The function then duplicates the values of three fields (c, d, and q) from the second parameter's DSA object to the first parameter's DSA object using the BN_dup function. If any of these fields in the first parameter's DSA object have non-null values, they are overwritten."
openssl-101f,O3,mips,param_print_gost01,./data/decomp/openssl-101f_mips_gcc_O3_extraction/param_print_gost01@0061abe4.c,"The function takes in three parameters: param_1, param_2, and param_3. It calls multiple functions with uVar1 as an argument and stores the result back in uVar1. It then calls a function at address PTR_BIO_indent_006a97d0 with param_1, param_3, and 0x80 as arguments and stores the result in iVar2. If the result is not 0, it means the function was successful. Finally, it calls a function at address PTR_OBJ."
openssl-101f,O3,mips,param_print_gost94,./data/decomp/openssl-101f_mips_gcc_O3_extraction/param_print_gost94@0061ac98.c,"The first function takes in three parameters and returns a pointer to an integer. It initializes variables and performs various operations on structures. It prints two strings to standard output before returning the pointer.

The second function generates a GOST R 34.10-2001 key pair. It takes in an `EVP_PKEY` pointer and a `GOST_KEY_PARAMS` pointer as arguments. It initializes variables, generates a random number, and sets the public and private keys. It handles errors and returns a pointer to the generated key pair.

The third function is a complex and important part of OpenSSL's GOST engine. It performs various operations related to GOST algorithms, including encoding the algorithm parameters, performing a GOST encryption, and decoding the encrypted data. It handles errors and returns a pointer to the decrypted data.

The fourth function encodes and decodes GOST keys. It takes in a GOST key and a buffer as input and performs various operations on them depending on the type of key and the operation requested. It handles errors and returns appropriate error codes.

The fifth function takes in a pointer to an EVP_PKEY structure and a BIO structure. It checks the type of the EVP_PKEY and if it is not a GOST R 34.10-2001 key, it returns NULL. It prints out the private and public keys and the parameter set using the BIO structure. It also calculates and prints out the public key coordinates. It returns a pointer to an integer indicating success or failure."
openssl-101f,O3,mips,pkey_ctrl_gost,./data/decomp/openssl-101f_mips_gcc_O3_extraction/pkey_ctrl_gost@0061b6d4.c,"The first function, `pkey_ctrl_gost`, takes in four parameters and handles each case separately based on `param_2`. It returns -2 if `param_2` is not one of the defined cases.

The second function is a decompiled version of a C function that performs various operations on pointers and integer values. It calls functions using double pointers and checks the value of `iStack_b0`.

The third function takes in a pointer to an EVP_PKEY structure and a BIO structure, and prints out the public key and parameter set information for a GOST key. It checks that the EVP_PKEY structure is not null and that it is a GOST key before getting the EC_KEY structure and EC_POINT structure representing the public key and parameter set. It then converts the EC_POINT structure to affine coordinates and prints out the information using the BIO structure."
openssl-101f,O3,mips,pkey_free_gost94,./data/decomp/openssl-101f_mips_gcc_O3_extraction/pkey_free_gost94@0061abc0.c,"The function takes an integer parameter `param_1` and checks if the value stored at the memory location `param_1 + 0x14` is not equal to zero. If it is not zero, it calls a function at the address stored in `PTR_DSA_free_006a862c` using an indirect jump. The function being called is not shown in the decompiled code. If the value at `param_1 + 0x14` is zero, the function returns without doing anything."
openssl-101f,O3,mips,priv_encode_gost,./data/decomp/openssl-101f_mips_gcc_O3_extraction/priv_encode_gost@0061bb14.c,"The first function encodes a private key using the GOST algorithm by retrieving algorithm parameters, encoding them using the encode_gost_algor_params function, retrieving the private key, and encoding it as an ASN1_INTEGER. If the key is an EC key, it also retrieves the private key value and encodes it as a BN. The function then prints the private and public keys to a BIO object along with the parameter set, and computes and prints the affine coordinates of the public key. It returns an error if any issues occur.

The second function is a part of OpenSSL's implementation of the GOST algorithm and prints out the details of a GOST key pair in a human-readable format. It takes in a pointer to an EVP_PKEY structure and checks if the key is of type GOST. If it is, the function extracts the public key and parameters from the EVP_PKEY structure and prints them out using the BIO_printf function. It also prints out the name of the parameter set used by the key and returns 1 if everything was successful, or 0 if there was an error."
openssl-101f,O3,mips,pub_encode_gost94,./data/decomp/openssl-101f_mips_gcc_O3_extraction/pub_encode_gost94@0061b904.c,"The first function, `pub_encode_gost94`, encodes a GOST 94 public key into a buffer by retrieving the public key and algorithm parameters, encoding the algorithm parameters into a buffer, calculating the size of the encoded public key, allocating a buffer to hold it, and encoding the public key into the buffer. It returns the size of the encoded public key or -1 if an error occurred.

The second function is a part of the OpenSSL library and is used to print information about a GOST key in a human-readable format. It takes a pointer to a BIO object and a pointer to an EVP_PKEY object as inputs. The function checks if the key is a private key or a public key, prints the private key value using the BN_print() function if it is a private key, and prints the public key value using the EC_POINT_get_affine_coordinates_GFp() function if it is a public key. Next, the function prints the parameter set used for the key using the OBJ_nid2ln() function. Finally, the function returns a value indicating whether the operation was successful or not."
openssl-101f,O3,mips,pub_print_gost94,./data/decomp/openssl-101f_mips_gcc_O3_extraction/pub_print_gost94@0061ae00.c,"The first function takes three parameters and returns a pointer to an integer. It extracts information from the public key and parameter set, calls a function with the parameters, and returns a pointer to an integer.

The second function is an implementation of the OpenSSL GOST algorithm method. It retrieves algorithm parameters, encodes them, creates a GOST_KEY_PARAMS structure, encodes it, and returns a pointer to the encoded structure.

The third function is implementing the EVP_PKEY_METHOD for the GOST R 34.10-2001 algorithm. It extracts the public key and algorithm parameters, encodes them, calculates the size of the signature buffer, signs the data using the private key, copies the signature to the output buffer, and returns the size of the signature.

The fourth function is responsible for encoding and printing a private key in a specific format. It performs arithmetic operations, retrieves a value, performs memory manipulation, encodes some parameters, and checks the value before returning.

The fifth function is an implementation of the OpenSSL GOST engine's asymmetric key generation method. It generates a new key pair using the GOST algorithm by initializing variables, creating a BN_CTX object, checking the key type, generating a new EC_KEY object, setting curve parameters, and generating a new EC_KEY key pair."
openssl-101f,O3,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O3_extraction/RSA_padding_add_PKCS1_PSS@00628ef8.c,"These functions both involve adding padding to a message for RSA encryption. The first function uses the PKCS1 PSS scheme and takes in a RSA key, a message hash, and the length of the salt. It checks the size of the hash and determines the salt length based on the RSA key size if not specified. It then generates random bytes for the salt, adds the message hash and salt to a hash context, uses PKCS1 MGF1 to generate a mask for the message, and XORs the mask with the message.

The second function implements the PKCS #1 v1.5 padding scheme and takes in a message to be encrypted, the length of the message, the length of the RSA modulus, and a hash function. It checks if the message is too long for the modulus length, generates a padding string based on the hash of the message, and appends it to the message. The padding string includes a header, hash of the message, and additional padding bytes to make the total length equal to the RSA modulus. The function then returns the padded message."
openssl-101f,O3,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101f_mips_gcc_O3_extraction/RSA_verify_PKCS1_PSS@00628440.c,"The two functions are related to the RSA-PSS algorithm for signature verification and generation. 

The function RSA_verify_PKCS1_PSS is used to verify a signature using the RSA-PSS algorithm with PKCS#1 v2.1 padding. It takes as input an RSA key, a message hash, an EVP_MD object, a signature buffer, and the length of the signature buffer. It returns an integer value indicating whether the signature is valid or not. The function initializes an EVP_MD_CTX object and checks the length of the signature buffer, returning an error if necessary.

The function for generating an RSA-PSS signature takes in the message to be signed, the length of the message, the RSA private key, and the hash function to be used. It initializes an EVP_MD_CTX context and sets the hash function to be used. It then generates a random salt of length equal to the hash function output size and pads the message with zeros. It performs the RSA private key operation on the padded message to obtain the signature, and performs various error checks throughout the process. The function is responsible for generating an RSA-PSS signature for a given message using a specified hash function and RSA private key."
openssl-101f,O3,mips,sha_block_data_order,./data/decomp/openssl-101f_mips_gcc_O3_extraction/sha_block_data_order@00620b30.c,"All of the functions are implementing the SHA-1 hashing algorithm, which takes in a message as input and produces a fixed-size output hash. The input message is processed in 512-bit blocks, and each block is processed using a series of logical and arithmetic operations. The specific operations being performed include bit shifts, bitwise AND and OR operations, and addition and subtraction of integer values. The functions use a combination of constants and intermediate values that are updated after each block. The final output hash is a combination of all the intermediate values produced during the processing of the input message."
openssl-101f,O3,mips,SHA_Final,./data/decomp/openssl-101f_mips_gcc_O3_extraction/SHA_Final@00621fdc.c,"The SHA_Final function is the final step in the SHA-1 hashing process. It takes the final hash value and writes it to the memory location specified by the md parameter. The function takes two parameters: a pointer to the memory location where the final hash value will be stored (md), and a pointer to the SHA_CTX structure (c) that holds the intermediate hash values. The function first sets the 0x80 bit in the data buffer of the SHA_CTX structure to indicate the end of the message. If the length of the message is less than 56 bytes, the function pads the data buffer with zeros until it reaches a length of 56 bytes (448 bits). If the length of the message is greater than or equal to 56 bytes, the function pads the data buffer with zeros until it reaches a length of 64 bytes (512 bits) and then processes this block of data. The function then sets the last 8 bytes of the data buffer to the length of the message."
openssl-101f,O3,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101f_mips_gcc_O3_extraction/SSL_SESSION_free.part.2@004b0e94.c,"This function is responsible for freeing memory associated with an SSL session, including the session certificate, X509 certificate, stack of X509 certificates, and various other pointers. It also clears memory at specific offsets from the start of the SSL session structure and clears the entire SSL session structure before freeing the SSL session structure itself."
openssl-101f,O3,mips,start_hash,./data/decomp/openssl-101f_mips_gcc_O3_extraction/start_hash@0061feb8.c,"The function takes a pointer to an array of four 32-bit integers as input. If the third integer in the array is not equal to zero, it initializes the fourth integer and the next three integers after that to zero using the memset function. It also sets the third and second integers to zero and returns 1. Otherwise, it simply returns 0."
openssl-101f,O3,mips,surewarehk_finish,./data/decomp/openssl-101f_mips_gcc_O3_extraction/surewarehk_finish@005d8534.c,"The function checks if the surewarehk_dso variable is equal to 0. If it is, it calls the ERR_put_error function with an error code and file location information. If surewarehk_dso is not equal to 0, it calls the p_surewarehk_Finish function to perform any cleanup actions. It then frees the surewarehk_dso variable and sets all function pointers to 0. If a logstream variable is present, it frees it using the BIO_free function. The function returns a value of 1 if everything completes successfully, or 0 if an error occurs."
openssl-101f,O3,mips,sv_body,./data/decomp/openssl-101f_mips_gcc_O3_extraction/sv_body@00442f98.c,"These are descriptions of various functions related to SSL/TLS connections and web servers. 

1. `sv_body` is a function in the OpenSSL library that handles SSL/TLS server connections. It initializes context variables, sets up callback functions, and performs non-blocking I/O. 
2. Another function in the OpenSSL library, used in the s_server program, sets up an SSL/TLS server by creating a socket, performing a handshake with clients, and handling errors. 
3. The main function for the s_server program sets up the SSL/TLS context and socket, handles incoming connections, and performs SSL/TLS-related tasks such as message callbacks and secure renegotiation. 
4. A decompiled function reads data from standard input and writes it to the SSL/TLS connection, and vice versa. 
5. Another function is a handler for incoming HTTP requests, reading data from a socket and sending file contents back to the client using SSL. 
6. Finally, a function in a web server program handles HTTP GET requests, parsing the request message, checking for security vulnerabilities, and sending a response with appropriate headers."
openssl-101f,O3,mips,__do_global_ctors_aux,./data/decomp/openssl-101f_mips_gcc_O3_extraction/__do_global_ctors_aux@00631900.c,"The function calls all global constructors for a program. It checks if the constructor list (__CTOR_LIST__) address is not equal to -1. If it is not, it sets up two pointers: ppcVar1 points to the constructor list address, and pcVar2 points to the first constructor in the list. It then enters a loop that iterates through the constructor list, calling the constructor function pointed to by pcVar2 and moving to the next constructor in the list by updating pcVar2. The loop continues until it reaches the end of the constructor list marked by a sentinel value of -1. After calling all constructors, the function returns."
openssl-101f,O3,mips,__libc_csu_init,./data/decomp/openssl-101f_mips_gcc_O3_extraction/__libc_csu_init@00631850.c,"The function initializes the C runtime environment for the program by calling a function stored in the global variable PTR__init_006aaa30, which likely sets up global variables, initializes memory, and performs other necessary setup tasks."
openssl-101f,O3,mips,__start,./data/decomp/openssl-101f_mips_gcc_O3_extraction/__start@00421540.c,The function is the entry point for a C program that calls `__libc_start_main` to execute the `main` function and then enters an infinite loop. The program has declared variables on the stack and is written in C.
openssl-101f,O3,mips,__udivdi3,./data/decomp/openssl-101f_mips_gcc_O3_extraction/__udivdi3@00630f60.c,"The two functions involve performing unsigned integer division of a 64-bit integer by a 32-bit integer. The first function takes four parameters and checks if the divisor is zero, performs a bit shift-based division algorithm if the divisor is a power of two, and performs a long division algorithm using repeated subtraction and multiplication otherwise. The second function takes five parameters and performs a series of bitwise operations and integer divisions to calculate the quotient. It creates two 32-bit integers, `uVar2` and `uVar7`, and calculates an intermediate value `uVar8` by shifting `param_4` to the right and `param_3` to the left by a certain amount. It then checks if the 16 most significant bits of `uVar`. The result in both functions is returned as a 64-bit unsigned integer with the upper 32 bits containing the remainder and the lower 32 bits containing the quotient."
openssl-101u,O0,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_arm_gcc_O0_extraction/asn1_bio_callback_ctrl@00120dd0.c,"The function asn1_bio_callback_ctrl takes three parameters and checks if a memory location is null before calling another function with those parameters. If the memory location is null, the function returns."
openssl-101u,O0,arm,asn1_bio_ctrl,./data/decomp/openssl-101u_arm_gcc_O0_extraction/asn1_bio_ctrl@00120e04.c,"The function `asn1_bio_ctrl` takes four parameters: a BIO object (`param_1`), an integer (`param_2`), a long integer (`param_3`), and a pointer to an integer (`param_4`). The function first checks if the `ptr` field of the BIO object is NULL. If it is, the function returns 0. If `param_2` is equal to 0x97, the function sets the 10th and 11th elements of the `ptr` field of the BIO object to the first and second elements of `param_4`, respectively, and returns 1. If `param_2` is greater than 0x97, the function checks if `param_2` is equal to 0x99. If it is, the function sets the 15th element of the `ptr` field of the BIO object to the value of `param_4`, and returns 1."
openssl-101u,O0,arm,asn1_bio_free,./data/decomp/openssl-101u_arm_gcc_O0_extraction/asn1_bio_free@00120ddc.c,"The function frees memory allocated to a BIO structure, taking an integer parameter. It checks if the pointer to the BIO structure is not null, and if not, checks if the pointer to the buffer inside the BIO structure is not null. If the buffer pointer is not null, it frees the memory allocated to the buffer. It then frees the memory allocated to the BIO structure itself. Finally, it sets some fields in the BIO structure to null and returns 1 if the memory was successfully freed, or 0 if the pointer to the BIO structure was null."
openssl-101u,O0,arm,asn1_bio_write,./data/decomp/openssl-101u_arm_gcc_O0_extraction/asn1_bio_write@00120fac.c,"The function takes in a BIO object, a buffer, and the length of the buffer, and returns a BIO object. It checks for null buffer and sets a flag accordingly. It then checks for null next BIO object in the chain or current BIO object's pointer and returns the current BIO object. If the current BIO object has a method, it enters a switch statement based on the method. If the method is null, it calls a function pointed to by the current BIO object's pointer to read data into the buffer. If the read is successful, it sets the method to 1 or 2 depending on the number of bytes read. If the method is 1, it writes data to the next BIO object in the chain until all the data is written. If the method is 2, it calculates the size of the ASN.1 object and puts it in."
openssl-101u,O0,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BIO_asn1_get_suffix@00121228.c,"The function BIO_asn1_get_suffix takes in a BIO object (b) and two pointers to undefined types (psuffix and psuffix_free). It returns a long integer value. Within the function, it calls the BIO_ctrl function with three arguments: the BIO object (b), the control command 0x98, and a null pointer. The function stores the result of this call in the variable lVar1. If lVar1 is greater than 0, the function sets the value of the psuffix pointer to the address of the local variable local_18 and sets the value of the psuffix_free pointer to the address of the local variable puStack_14. Finally, the function returns the value of lVar1."
openssl-101u,O0,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BIO_asn1_set_prefix@001211d4.c,"The function sets the prefix string for a BIO object using the BIO_ctrl function with control command 0x95 and a pointer to the prefix string. It takes in a BIO object, a prefix string, and a prefix_free string, but the latter is not used. The function returns the result of the BIO_ctrl call."
openssl-101u,O0,arm,BN_GF2m_add,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_add@0011e2e0.c,"The function BN_GF2m_add takes three BIGNUM pointers as input and performs addition of two binary polynomials represented as BIGNUMs, param_2 and param_3, and stores the result in param_1. It determines the size of the larger input polynomial, expands the output polynomial if necessary, performs a bitwise XOR operation on the smaller polynomial and the common bits of the larger polynomial, stores the result in param_1, removes any leading zero bits in the resulting polynomial, and returns 1 to indicate success. If the input polynomials are invalid or memory allocation fails, the function returns 0."
openssl-101u,O0,arm,BN_GF2m_mod,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod@0011e5b8.c,"The function takes three parameters: param_1, param_2, and param_3. Param_1 and param_2 are undefined input data, while param_3 is a pointer to an array of integers. The function checks if the second element of the param_3 array is zero. If it is, it sets an error and returns 0. If not, the function sets some variables and iterates through the elements of the param_3 array in reverse order. For each non-zero element, the function finds the position of the most significant bit that is set and adds it to an array called aiStack_30. The function checks the length of aiStack_30 and sets an error and returns 0 if it is greater than 6. Otherwise, the function calls the BN_GF2m_mod_arr function with the parameters."
openssl-101u,O0,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_arr@0011e394.c,"BN_GF2m_mod_arr is a function that performs modular reduction of a BIGNUM value param_2 in GF(2^m) field, using an irreducible polynomial represented by an array of uints, param_3. The result is stored in param_1. It first checks if the input value is zero, in which case it sets the output value to zero and returns. If the input and output values are the same, it stores the result in the input value itself. Otherwise, it expands the output value if necessary and copies the input value into it. The function then performs the reduction using a modified schoolbook algorithm, iterating over the uints of the input value and the irreducible polynomial and XORing them."
openssl-101u,O0,arm,BN_GF2m_mod_div,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_div@0011ee90.c,"The function BN_GF2m_mod_div performs modular division of two BIGNUMs over the binary field GF(2^m). It takes in four parameters: an integer, two BIGNUMs (param_4 and param_3), and a BN_CTX object. First, it starts a BN_CTX object, which is used to store temporary BIGNUMs during the computation. It then gets a temporary BIGNUM object from the BN_CTX using BN_CTX_get. Next, it computes the modular inverse of param_4 with respect to param_3 using BN_GF2m_mod_inv and stores the result in the temporary BIGNUM object. If this computation fails (either because the temporary BIGNUM object could not be allocated or the inverse could not be computed), the function returns 0. The function then computes the number of bits in param_4, adds 1 to this value, and allocates a block of memory to store an array of integers of this."
openssl-101u,O0,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_div_arr@0011efbc.c,"The function BN_GF2m_mod_div_arr takes in four parameters: param_1, param_2, param_3, and param_4, as well as a BN_CTX pointer param_5. It starts a BN_CTX context, creates a new BIGNUM object, sets its value to 0, and enters a while loop that iterates through the elements of the array pointed to by param_4. Within the loop, the function sets the bit at the position specified by the current element of the array. If the bit cannot be set, the loop is exited. Once the loop has finished, the function calls the BN_GF2m_mod_div function."
openssl-101u,O0,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_mul@0011e8dc.c,"This function takes an input BIGNUM and performs the following steps: 
1. Calculates the number of bits in the input BIGNUM and adds 1 to it.
2. Allocates memory for an array of integers of size equal to the above calculated value.
3. Converts the input BIGNUM into an array of integers where each bit of the BIGNUM is represented by an integer in the array.
4. Finds the number of leading zeroes in the array and calculates the number of 32-bit integers required to represent the array.
5. Calls a function BN_GF2m_mod_mul_arr with the above calculated parameters and the input arguments.
6. Frees the allocated memory and returns the result of the function call."
openssl-101u,O0,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_mul_arr@0011e778.c,"The function BN_GF2m_mod_mul_arr() takes in five parameters: an integer, two integer arrays, an integer, and a BN_CTX pointer. It returns an integer. The function first checks if the two input arrays are the same. If they are, it calls BN_GF2m_mod_sqr_arr() and returns its result. Otherwise, the function allocates a new BIGNUM using BN_CTX_get() and expands it if necessary using bn_expand2(). It sets the top field of the BIGNUM to the sum of the lengths of the two input arrays plus four, and initializes all its elements to zero. The function then performs polynomial multiplication on the two input arrays using bn_GF2m_mul_2x2() and stores the result in the new BIGNUM. It then reduces the new BIGNUM modulo the input integer using BN_GF2m_mod_arr(). Finally, the function checks if the reduction was successful and returns either 0 or 1 accordingly."
openssl-101u,O0,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_sqr@0011e9bc.c,"The function BN_GF2m_mod_sqr computes the square of a binary polynomial represented as a BIGNUM object in GF(2^m) field. It first allocates memory for an array of integers to represent the binary polynomial. It then extracts the set bits of the input polynomial and stores their positions in the array. The function then computes the number of leading zeroes in the array to determine the degree of the polynomial. If the degree is zero, the function returns the input polynomial. Otherwise, it calls the function BN_GF2m_mod_sqr_arr to compute the square of the polynomial using a precomputed table of irreducible polynomials. Finally, the function frees the memory allocated for the array and returns the result."
openssl-101u,O0,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_sqrt@0011f21c.c,"The function BN_GF2m_mod_sqrt computes the square root of a given BIGNUM in a finite field GF(2^m) using a specific irreducible polynomial. It determines the degree of the polynomial, calculates the number of leading zeroes in the array, and uses modular exponentiation to compute the square root. It returns the result, or zero if memory allocation fails. If an error occurs, it logs an error message and returns the appropriate error code."
openssl-101u,O0,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_GF2m_mod_sqr_arr@0011e65c.c,"This function initializes a BIGNUM variable ""a"" using BN_CTX_get(), determines the size of the input array ""param_2"" and expands the size of ""a"" if necessary, loops through the input array ""param_2"" and squares each element using a precomputed table of values, sets the ""top"" value of ""a"" to the new size after squaring, calls BN_GF2m_mod_arr() function to reduce ""a"" modulo ""param_3"", and returns 1 if reduction was successful, 0 otherwise."
openssl-101u,O0,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101u_arm_gcc_O0_extraction/bn_GF2m_mul_2x2@001213e0.c,"The function bn_GF2m_mul_2x2 performs multiplication of two 2x2 matrices over the Galois field GF(2^m), where m is the degree of the irreducible polynomial used to define the field. The input parameters are four uint values representing the elements of the two matrices. The function checks if a certain bit in memory is set, which indicates that the function should use a faster multiplication algorithm using NEON instructions. If this bit is set, the function calls the NEON instruction mul_1x1_neon to perform the multiplication. Otherwise, it uses the function mul_1x1_ialu to perform the multiplication using integer arithmetic. After the multiplication is performed, the function stores the result in an array of four uint values representing the elements of the resulting matrix. It then performs some XOR and bit shifting operations on the elements of the resulting matrix to obtain the final output. The function returns the last element of the resulting matrix, which is the output."
openssl-101u,O0,arm,BN_kronecker,./data/decomp/openssl-101u_arm_gcc_O0_extraction/BN_kronecker@0011dba4.c,"The function BN_kronecker(a,b,ctx) computes the Kronecker symbol of two BIGNUMs a and b using the binary algorithm. The Kronecker symbol is a generalization of the Legendre symbol to non-prime moduli. It returns an integer value that indicates the properties of a with respect to b. The function first allocates two BIGNUMs a_00 and a_01 using the BN_CTX_get() function. It then copies the values of a and b to a_00 and a_01 respectively using the BN_copy() function. If a_01 is null, the function returns -2. Otherwise, it checks if the top value of a_01 is zero. If it is, it computes the Kronecker symbol of a_00 and returns the result. If not, it checks if a_00 is negative or has a top value less than 1. If either of these conditions is true, it checks if the least."
openssl-101u,O0,arm,by_dir_entry_free,./data/decomp/openssl-101u_arm_gcc_O0_extraction/by_dir_entry_free@000cd754.c,"The ""by_dir_entry_free"" function takes a void pointer ""param_1"" as input. It checks if the value pointed to by ""param_1"" is not equal to NULL. If it is not NULL, it frees the memory pointed to by ""param_1"" using the ""CRYPTO_free"" function. It also checks if the third element of ""param_1"" (cast as a pointer to a STACK object) is not equal to NULL. If it is not NULL, it frees the memory pointed to by this element using the ""sk_pop_free"" function, with the second argument being the address of the ""by_dir_hash_free"" function plus one. Finally, it frees the memory pointed to by ""param_1"" itself using the ""CRYPTO_free"" function, and returns from the function."
openssl-101u,O0,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_arm_gcc_O0_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@00119ecc.c,"The function decodes uchar data into an ASN1_VALUE structure using the ASN1_ITEM definition for GOST_CLIENT_KEY_EXCHANGE_PARAMS. It takes in three parameters: a pointer to a pointer to an ASN1_VALUE, a pointer to a uchar, and a long integer. It does not return any value."
openssl-101u,O0,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_arm_gcc_O0_extraction/d2i_GOST_KEY_PARAMS@00119e6c.c,"The function d2i_GOST_KEY_PARAMS converts a binary representation of a GOST key parameter into an ASN.1 structure. It takes in three parameters: param_1 (a pointer to an ASN1_VALUE pointer), param_2 (a pointer to an unsigned char pointer), and param_3 (a long integer). Inside the function, the ASN1_item_d2i function is called with the four parameters: param_1, param_2, param_3, and a pointer to an ASN1_ITEM structure named PTR_GOST_KEY_PARAMS_it_00119e74. The function returns with no value."
openssl-101u,O0,arm,decode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O0_extraction/decode_gost_algor_params@001188d0.c,"The function decodes the GOST algorithm parameters from an X509_ALGOR structure and sets them in an EVP_PKEY structure. It first extracts the algorithm identifier and parameters from the X509_ALGOR structure. If the algorithm is not GOST, it returns an error. If the algorithm is GOST, it decodes the parameters using the d2i_GOST_KEY_PARAMS function and sets them in the EVP_PKEY structure. If the algorithm is GOST2001, it creates an EC_KEY structure and sets the GOST2001 parameters in it. If the algorithm is GOST94, it creates a DSA structure and sets the GOST94 parameters in it. The function returns 1 on success and 0 on failure."
openssl-101u,O0,arm,DES_xcbc_encrypt,./data/decomp/openssl-101u_arm_gcc_O0_extraction/DES_xcbc_encrypt@0011d0fc.c,"The first function implements the DES-XCBC encryption algorithm for message authentication. It takes pointers to byte arrays for plaintext and ciphertext, a length parameter, a key schedule, an initialization vector, intermediate value pointers, and an encryption/decryption flag. It processes plaintext in 8-byte blocks and produces ciphertext.

The second function implements the Cipher Block Chaining (CBC) mode of the Data Encryption Standard (DES) algorithm. It takes a key schedule, an initialization vector, an input buffer, and a length parameter, and outputs encrypted data in an output buffer while updating the IV for the next block. It pads the input data with zeros if the length is less than 8 bytes and processes the input in 8-byte blocks if the length is greater than or equal to 8 bytes. It XORs the input data with the IV, encrypts the result using the key schedule, updates the IV, and stores the encrypted data in the output buffer."
openssl-101u,O0,arm,dgram_ctrl,./data/decomp/openssl-101u_arm_gcc_O0_extraction/dgram_ctrl@000a2408.c,"The two functions take in several parameters and use switch statements to handle different cases. The first function, `dgram_ctrl`, initializes local variables and sets the value of `__src` before entering the switch statement. Cases handled include setting a size parameter, setting a value at a specific address, and falling through to another case. The second function checks for a specific header value before entering the switch statement. Cases handled include setting output size parameters and copying bytes from the source buffer to the output buffer based on specific conditions."
openssl-101u,O0,arm,dlfcn_bind_func,./data/decomp/openssl-101u_arm_gcc_O0_extraction/dlfcn_bind_func@0012070c.c,"The function `dlfcn_bind_func` takes two integer parameters `param_1` and `param_2`. It first checks if both parameters are non-zero. If either parameter is zero, it adds an error message to the error queue and returns a null pointer. If both parameters are non-zero, the function initializes a void pointer `pvVar4` to null. It then gets the number of elements in a stack pointed to by the value at the memory address `param_1 + 4`. If the number of elements is less than 1, an error message is added to the error queue. If the number of elements in the stack is greater than or equal to 1, the function retrieves the value of the last element in the stack and assigns it to `pvVar4`. If `pvVar4` is null, an error message is added to the error queue. If `pvVar4` is not null, the function calls `dlsym` with `param_1` and the value pointed to by `pvVar4`."
openssl-101u,O0,arm,dlfcn_bind_var,./data/decomp/openssl-101u_arm_gcc_O0_extraction/dlfcn_bind_var@001207e0.c,"The function dlfcn_bind_var takes two integer parameters, param_1 and param_2. It checks if both parameters are not zero. If either of them is zero, it adds an error message to the error stack and returns NULL. If both parameters are not zero, it initializes a void pointer pvVar4 to NULL. It then gets the number of items in the stack pointed to by the value at memory location param_1+4. If the number of items is less than 1, it adds an error message to the error stack. If the number of items in the stack is greater than or equal to 1, it retrieves the last item in the stack and assigns it to pvVar4. If pvVar4 is NULL, it adds an error message to the error stack. If pvVar4 is not NULL, it attempts to find the symbol specified by the value at memory location param_2 using dlsym. If dlsym returns NULL, it adds an error message to the error stack."
openssl-101u,O0,arm,dlfcn_globallookup,./data/decomp/openssl-101u_arm_gcc_O0_extraction/dlfcn_globallookup@00120520.c,"The function uses the dlfcn library to dynamically load a shared object file and look up a symbol within it. It takes four parameters, but only the first and third parameters are used. First, it calls dlopen with a null pointer as the filename and a flag indicating that the shared object should be loaded into the global symbol table. The third and fourth parameters are passed to dlopen but are not used. If dlopen successfully loads the shared object, the function calls dlsym to look up the symbol specified by the first parameter within the loaded shared object. If dlsym successfully finds the symbol, the function returns its address. Finally, the function calls dlclose to close the loaded shared object before returning. If dlopen fails to load the shared object or dlsym fails to find the symbol, the function returns 0."
openssl-101u,O0,arm,doapr_outch.constprop.0,./data/decomp/openssl-101u_arm_gcc_O0_extraction/doapr_outch.constprop.0@0009f7cc.c,"The function `doapr_outch_constprop_0` takes in four parameters: `void **param_1`, `void **param_2`, `uint *param_3`, and `uint *param_4`. The function first checks if `param_2` is equal to `NULL`. If it is, it sets `uVar3` to the value of `*param_4` and `uVar2` to the value of `*param_3`. If `param_2` is not equal to `NULL`, the function checks if `uVar2` (the value of `*param_3`) is equal to `uVar3` (the value of `*param_4`). If they are equal, the function checks if `uVar2` is greater than `0x7ffffbff`. If it is, the function returns `0`. Otherwise, the function allocates memory of size `uVar2 +`."
openssl-101u,O0,arm,dtls1_link_min_mtu,./data/decomp/openssl-101u_arm_gcc_O0_extraction/dtls1_link_min_mtu@0005d398.c,"The function dtls1_link_min_mtu returns the hexadecimal value 0x100, which is equivalent to 256 in decimal. Its purpose is unclear without additional context."
openssl-101u,O0,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_mont_field_encode@0011f920.c,"This function takes four parameters - an integer, two BIGNUM pointers, and a BN_CTX pointer. It checks if a BN_MONT_CTX structure is not NULL, and if it is not NULL, it calls the BN_mod_mul_montgomery function with the second and third parameters as inputs and the BN_MONT_CTX structure and the fourth parameter as context. The result of the multiplication is stored in the second parameter. If the BN_MONT_CTX structure is NULL, the function adds an error to the error queue using the ERR_put_error function and returns 0. In summary, this function encodes a BIGNUM in Montgomery form using a BN_MONT_CTX structure."
openssl-101u,O0,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_mont_field_sqr@0011f8e8.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It first checks if the BN_MONT_CTX pointer stored at offset 0xa0 of the integer parameter is not null. If it is not null, it calls the BN_mod_mul_montgomery function to compute the square of the second BIGNUM parameter using the Montgomery multiplication method and stores the result in the first BIGNUM parameter. If the BN_MONT_CTX pointer is null, the function generates an error using the ERR_put_error function and returns 0."
openssl-101u,O0,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_mont_group_init@0011f6c4.c,The `ec_GFp_mont_group_init()` function initializes a Montgomery curve group over a finite field by first calling `ec_GFp_simple_group_init()` to initialize a simple elliptic curve group. It then sets two variables to zero for storing Montgomery curve parameters before returning.
openssl-101u,O0,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0012183c.c,"This function takes in six parameters: an integer pointer, an integer, and four BIGNUM pointers. It returns a BIGNUM pointer. The function first checks if the integer at the address pointed to by the integer pointer is 0. If it is, it copies the second and third BIGNUM pointers to the fourth and fifth BIGNUM pointers, respectively. If the fourth and fifth pointers are not NULL, it sets the return value to 1. If any of the memory allocations or copy operations fail, it sets the return value to 0. If the integer at the address pointed to by the integer pointer is not 0, the function checks if the sixth BIGNUM pointer is NULL. If it is, it allocates a new BN_CTX object and sets the sixth pointer to it. If the allocation fails, it sets the return value to NULL. The function then calls a function pointer stored in the structure pointed to by the integer pointer at offset 0x94."
openssl-101u,O0,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_group_check_discriminant@0012194c.c,"The function `ec_GFp_simple_group_check_discriminant` checks the discriminant of an elliptic curve in the form `y^2 = x^3 + ax + b` over a finite field. It takes two parameters: `param_1`, which is a pointer to a structure containing the elliptic curve parameters, and `param_2`, which is a pointer to a BN_CTX structure used for temporary storage of big integers. The function first checks if `param_2` is null and creates a new BN_CTX if it is. It then initializes several BIGNUM variables using `BN_CTX_get` and copies the `a` and `b` parameters from `param_1` to `a` and `a_00`, respectively. Next, it computes the discriminant `4a^3 + 27b^2` using the formula `r = a^3`, `r_00 = ar`, `r = 4r + 27`."
openssl-101u,O0,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_group_clear_finish@001215f4.c,The function takes an integer parameter representing an elliptic curve group in OpenSSL. It clears and frees three BIGNUM variables used for storing the curve parameters using OpenSSL's BN_clear_free() function. The function has no return value.
openssl-101u,O0,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_group_copy@00121fc8.c,"This function is used to copy the parameters of a simple group structure in an elliptic curve cryptography library. It takes two parameters, both integers, which are pointers to the simple group structures to be copied. The function uses the BN_copy function from the OpenSSL library to copy the BIGNUM values from the second simple group structure to the first one. It copies three BIGNUM values from the second structure to the first one, located at offsets 0x48, 0x74, and 0x88 respectively. If all three BN_copy calls are successful, the function sets the fourth parameter of the first simple group structure to the value of the fourth parameter of the second simple group structure and returns a pointer to the first simple group structure. If any of the BN_copy calls fail, the function returns a null pointer."
openssl-101u,O0,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_group_get_degree@00121634.c,"This function takes an integer parameter, likely a pointer to a structure representing an elliptic curve group. It calls the BN_num_bits function from the OpenSSL library, passing in a pointer to a BIGNUM structure located at an offset of 0x48 bytes from the beginning of the elliptic curve group structure. The BN_num_bits function calculates the number of bits in the BIGNUM structure and returns the result. The function then returns without doing anything with the result. The purpose of this function is likely to retrieve the degree of the elliptic curve group, which is the number of bits in the prime modulus used to define the group."
openssl-101u,O0,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_group_set_curve@0012203c.c,"The function takes in four BIGNUM pointers and a BN_CTX pointer as parameters. It first checks if the number of bits in the second parameter is less than 3 or if its top value is less than 1 or if its most significant bit is set. If any of these conditions are true, it returns 0. If the input parameters are valid, it initializes a BN_CTX object if one was not provided and starts a new BN_CTX session. It then gets a BIGNUM object from the BN_CTX object and sets it to zero. It copies the second parameter into a BIGNUM object and sets its sign to non-negative. It takes the modulo of the third parameter with the second parameter and stores the result in the BIGNUM object that was previously set to zero. If the modulo operation was successful, it checks if the function pointer at offset 0x90 of the first parameter is NULL. If it is, it copies the result of the modulo operation into the."
openssl-101u,O0,arm,ec_GFp_simple_invert,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_invert@00122730.c,"The function takes an EC_GROUP object and an EC_POINT object as parameters. It checks if the point is at infinity or if the y-coordinate is zero. If the point is not at infinity and the y-coordinate is not zero, it calculates the inverse of the y-coordinate modulo the curve's order. If the point is at infinity or the y-coordinate is zero, it returns an error code of 1."
openssl-101u,O0,arm,EC_GFp_simple_method,./data/decomp/openssl-101u_arm_gcc_O0_extraction/EC_GFp_simple_method@00122d2c.c,"The function returns a pointer to an EC_METHOD structure named ""ret_9448"" used in elliptic curve cryptography. The warning message indicates the possibility of unrecognized calling convention, but the parameter storage is locked."
openssl-101u,O0,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_point_copy@00122004.c,"The function `ec_GFp_simple_point_copy` copies the x, y, and z coordinates of an elliptic curve point represented by `param_2` to the point represented by `param_1`. It uses the OpenSSL library's `BN_copy` function for each coordinate and returns a pointer to `param_1` if all copy operations are successful. If any copy operation fails, it returns a null pointer."
openssl-101u,O0,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_point_finish@001215d4.c,"The function frees three BIGNUMs from the memory allocated for an elliptic curve point structure's x, y, and z coordinates using the BN_free function, and returns without any other operation. It takes an integer parameter representing the memory address of the structure."
openssl-101u,O0,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_point_get_affine_coordinates@00121ab4.c,"The function takes an EC_POINT object, an EC_GROUP object, and two BIGNUM objects as input and returns the affine coordinates of the EC_POINT object. It checks if the EC_POINT object is at infinity and returns an error if it is. The function initializes a BN_CTX object and several BIGNUM objects using the BN_CTX_get() function. If the EC_POINT object is not at infinity, the function calculates the inverse of the x-coordinate of the EC_POINT object modulo the order of the curve and then calculates the y-coordinate of the EC_POINT object using the inverse and the curve equation. The function returns 1 if it successfully calculates the affine coordinates and 0 otherwise. Finally, the function frees the BN_CTX context and returns the result."
openssl-101u,O0,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O0_extraction/ec_GFp_simple_point_set_affine_coordinates@0012215c.c,"The function takes in an elliptic curve group (EC_GROUP), an elliptic curve point (EC_POINT), two BIGNUMs representing the x and y coordinates of the point in affine form (param_3 and param_4), and a BN_CTX context object (param_5). If both param_3 and param_4 are not null pointers, the function creates a new BIGNUM with value 1 (z), and calls the EC_POINT_set_Jprojective_coordinates_GFp function to set the point's coordinates in Jacobian projective form using the input affine coordinates and the newly created z value. The function returns the result of EC_POINT_set_Jprojective_coordinates_GFp. If either param_3 or param_4 is a null pointer, the function generates an error using the ERR_put_error function and returns 0."
openssl-101u,O0,arm,encode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O0_extraction/encode_gost_algor_params@00119098.c,"The function takes an EVP_PKEY object as input and encodes its parameters in the GOST algorithm format. It creates a new ASN1_STRING object and a GOST_KEY_PARAMS object. It checks the type of the EVP_PKEY object and extracts the curve name or parameter set. Once the curve name is set in the GOST_KEY_PARAMS object, the function encodes it using the i2d_GOST_KEY_PARAMS function and sets the resulting data as the data of the ASN1_STRING object. It then sets the length and type of the ASN1_STRING object. If either of the objects cannot be created, it returns NULL."
openssl-101u,O0,arm,get_gost_engine_param,./data/decomp/openssl-101u_arm_gcc_O0_extraction/get_gost_engine_param@0011ae64.c,"The function takes an integer parameter called ""param_1"" and returns a character pointer. If the value of ""param_1"" is not equal to zero, the function returns a null pointer. Otherwise, it checks whether the global variable ""gost_params"" is null. If it is null, the function retrieves the value of the environment variable ""CRYPT_PARAMS"" and assigns it to ""gost_params"" after making a copy of it using the ""BUF_strdup"" function. Finally, the function returns the value of ""gost_params""."
openssl-101u,O0,arm,gost2001_param_encode,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost2001_param_encode@00118c28.c,"The function encodes the parameters of an elliptic curve used by a GOST R 34.10-2001 key pair into a binary ASN.1 format. It extracts the EC_KEY object from the EVP_PKEY object, gets the EC_GROUP object associated with it, and obtains the curve name as an integer value using EC_GROUP_get_curve_name(). It converts the curve name integer to an ASN1_OBJECT using OBJ_nid2obj(), encodes the ASN1_OBJECT into a binary format using i2d_ASN1_OBJECT(), and stores the result in the memory location pointed to by the param_2 pointer."
openssl-101u,O0,arm,gost_cipher_cleanup,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost_cipher_cleanup@0011a024.c,The function takes an integer parameter and calls the gost_destroy function with an argument that is calculated by adding the value at (param_1 + 0x60) and 0xc. It also sets the value at (param_1 + 0x54) to 0 and returns the value 1.
openssl-101u,O0,arm,gost_cipher_ctl,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost_cipher_ctl@0011a46c.c,"The function gost_cipher_ctl takes four parameters: param_1, param_2, param_3, and param_4. 

If param_2 is equal to 6, it generates random bytes using the RAND_bytes function and stores them in the memory location pointed to by param_4. If the RAND_bytes function returns a positive value, the function returns 1. If there is an error, the function calls ERR_GOST_error and returns -1.

If param_2 is equal to 7, the function sets the value at the memory location pointed to by param_4 to 0x32a and returns 1. If param_4 is NULL, the function returns 0.

If param_2 is not equal to 6 or 7, the function calls ERR_GOST_error and returns -1."
openssl-101u,O0,arm,gost_cipher_do_cnt,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost_cipher_do_cnt@0011a13c.c,"The function is an implementation of the GOST cipher algorithm, specifically the counter mode (CTR) of operation. It takes in four parameters: an integer, two pointers to unsigned integers, and a pointer to a byte array. The first part of the function checks if a pointer to a byte array is null or not. If it is null, it sets a pointer to a predefined byte array. If it is not null, it performs a bitwise XOR operation between the byte array and the values in the two unsigned integer pointers, storing the result in the first unsigned integer pointer. It then continues this operation until either the end of the byte array or a predefined length is reached. The second part of the function performs the counter mode of operation. It takes the remaining bytes from the byte array and XORs them with the output of the GOST cipher algorithm using a counter value. It then stores the result in the first unsigned integer pointer. This process continues until all bytes have been processed.

The function takes in four parameters: param_1, param_2, param_3, and param_4. It returns a value of 1. The function starts by declaring several variables, including iVar1, iVar7, pbVar4, and uVar10. The function then checks if param_1 is null, and if it is, it returns 0. If param_2 is null, it sets param_4 to 0. Next, the function checks if param_4 is less than or equal to 2, and if it is, it sets uVar10 to 0 and jumps to the end of the function. If param_4 is greater than 2, the function enters a loop that iterates from 0 to param_4 - 2. Inside the loop, the function computes the XOR of two bytes, one from param_1 and one from param_3, and stores the result in param_2. If pbVar4 is null, the function returns 0. Otherwise, it returns 1."
openssl-101u,O0,arm,gost_cipher_init,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost_cipher_init@0011acb0.c,"The `gost_cipher_init` function initializes the GOST cipher context with a specified key and initialization vector. It first checks if the `app_data` field is `NULL`, retrieves the GOST engine parameter, and sets default parameter and cipher OID if necessary. It then converts the parameter name to an OID and searches for the corresponding cipher OID in the `gost_cipher_list`. If found, it sets the parameter set and initializes the context."
openssl-101u,O0,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O0_extraction/GOST_CIPHER_PARAMS_new@00119eb4.c,"The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function, defined by the PTR_GOST_CIPHER_PARAMS_it_00119ebc item template. It does not return anything."
openssl-101u,O0,arm,gost_imit_final,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost_imit_final@0011aacc.c,"The function `gost_imit_final` takes two parameters, `param_1` and `param_2`. It retrieves the value of a variable `iVar1` from a memory location pointed to by an offset of `0x103c` from `param_1 + 0xc`. If `iVar1` is equal to 0, it prints an error message and jumps to the end of the function. If `iVar1` is not equal to 0, the function retrieves the value of another variable `iVar1` from a memory location pointed to by an offset of `0x1030` from the same memory location as before. If `iVar1` is equal to 0 and another variable pointed to by an offset of `0x1038` from the same memory location is not equal to 0, the function sets two local variables `local_24` and `local_20` to the value of."
openssl-101u,O0,arm,gost_imit_init_cpa,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost_imit_init_cpa@0011a418.c,"The function initializes the GOST 28147-89 cipher with the CryptoPro parameter set A. It sets all bytes in the context structure from 0x1020 to 0x103f to zero, and then sets the value at offset 0x1034 to 1. Finally, it calls the gost_init function and returns 1 upon completion, indicating success."
openssl-101u,O0,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O0_extraction/GOST_KEY_PARAMS_new@00119e84.c,The function creates a new instance of the GOST_KEY_PARAMS data structure using the ASN1_item_new() function and returns without any further action.
openssl-101u,O0,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_arm_gcc_O0_extraction/GOST_KEY_TRANSPORT_free@00119e00.c,"The function takes an ASN1 value as input, frees it using the ASN1_item_free function with the GOST_KEY_TRANSPORT_it item type, and returns without any further action. It is likely part of a larger program or library that deals with cryptography and key exchange."
openssl-101u,O0,arm,gost_param_free,./data/decomp/openssl-101u_arm_gcc_O0_extraction/gost_param_free@0011ae0c.c,"The ""gost_param_free"" function frees the memory allocated for the ""gost_params"" variable. It checks if the variable is not a null pointer, indicating that memory has been allocated. If memory has been allocated, it uses the ""CRYPTO_free"" function to free the memory and sets the ""gost_params"" variable to a null pointer. The function returns after freeing the memory."
openssl-101u,O0,arm,hash_step,./data/decomp/openssl-101u_arm_gcc_O0_extraction/hash_step@0011aed8.c,"The functions perform encryption using the GOST cipher algorithm with a given key and input data. The first function takes in three arguments: an integer, and two pointers to unsigned integers. It checks if the two pointers are aligned to 4 bytes and performs a series of XOR operations on the values pointed to by the two pointers. It then calls `gost_enc_with_key` with several arguments including the integer passed in as the first argument, some local variables, and the two pointers passed in as the third and seventh arguments. The result of this function call is stored in a local variable called `local_b0`. The function then performs a series of bitwise operations and XOR operations on the local variables and the values pointed to by the two pointers. The results of these operations are stored in a series of local variables. Finally, the function copies some local variables to the output parameters and checks if a certain condition is true. The second function initializes some local variables and performs the encryption using the GOST cipher algorithm. It then stores the encrypted data in local variables and XORs them with some other local variables to create a new set of encrypted data. Finally, the function performs encryption again with the new set of encrypted data and stores the result in the provided output buffer. The function also swaps the first two bytes of the output buffer with each other."
openssl-101u,O0,arm,hwcrhk_init,./data/decomp/openssl-101u_arm_gcc_O0_extraction/hwcrhk_init@000f20a4.c,"The `hwcrhk_init` function initializes the hardware cryptographic module by loading its shared library and binding its functions. It checks if the module is already loaded and attempts to load the shared library if it is not loaded. It binds the necessary functions and reports any errors using the `ERR_put_error` function. The function also sets global variables and initializes a context handle. It creates a new index for the RSA key handle and frees the loaded shared library if it was loaded successfully. Finally, it sets all the bound function pointers to null."
openssl-101u,O0,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_arm_gcc_O0_extraction/i2d_GOST_KEY_AGREEMENT_INFO@00119e48.c,"The function takes in two parameters - a pointer to an ASN1_VALUE structure and a double pointer to a uchar (unsigned char) buffer. The purpose of the function is to convert the ASN1_VALUE structure into a binary format and store it in the uchar buffer. To achieve this, the function calls the ASN1_item_i2d() function passing in the ASN1_VALUE structure, uchar buffer and a pointer to an ASN1_ITEM structure (PTR_GOST_KEY_AGREEMENT_INFO_it_00119e50). Once the encoding is complete, the uchar buffer will contain the binary representation of the ASN1_VALUE structure. The function then returns."
openssl-101u,O0,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_arm_gcc_O0_extraction/i2d_GOST_KEY_TRANSPORT@00119de8.c,"The void function takes in two parameters: a pointer to an ASN1_VALUE structure and a pointer to a pointer to an unsigned char. It calls the ""ASN1_item_i2d"" function, passing in the two parameters and a pointer to an ASN1_ITEM structure of type ""GOST_KEY_TRANSPORT_it"" to encode the ASN1_VALUE structure into binary format. The function then simply returns without any value."
openssl-101u,O0,arm,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_arm_gcc_O0_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@0008653c.c,"The function takes a BIGNUM structure pointer, an integer value, an unsigned integer array pointer, and two unsigned integer values as input. It returns an integer value. 

The function checks if the number of digits in the BIGNUM structure is less than the input integer value. If it is, it expands the BIGNUM structure to the input size using bn_expand2 function. If the expansion fails, the function returns 0. 

The function then checks the value of param_5. If it is less than 4, it iterates through the digits of the BIGNUM structure and copies bits from the input array param_3 to each digit, based on the value of param_4 and param_5. If param_5 is greater than or equal to 4, the function performs a similar operation, but with a more complex bit manipulation based on the values of param."
openssl-101u,O0,arm,mul_1x1_ialu,./data/decomp/openssl-101u_arm_gcc_O0_extraction/mul_1x1_ialu@001212c0.c,"The function ""mul_1x1_ialu"" is a placeholder or stub with only a ""return"" statement and no actual code."
openssl-101u,O0,arm,param_copy_gost94,./data/decomp/openssl-101u_arm_gcc_O0_extraction/param_copy_gost94@00118de8.c,"The function takes two EVP_PKEY pointers as input and checks if their base IDs match. If they do, it gets the DSA key from the first parameter and the GOST R 34.10-94 parameters from the second parameter. If the GOST R 34.10-94 parameters are not null, it assigns them to the DSA key's parameters and recomputes the public key if necessary. If the GOST R 34.10-94 parameters are null, it returns an error."
openssl-101u,O0,arm,param_print_gost01,./data/decomp/openssl-101u_arm_gcc_O0_extraction/param_print_gost01@001199e4.c,"This function takes a BIO object, an EVP_PKEY object, and an integer as parameters, and returns an integer. It extracts an EC_KEY object from the EVP_PKEY object, and then extracts the EC_GROUP object from the EC_KEY object. It then gets the curve name of the EC_GROUP object. The function indents the output of the BIO object by the amount specified in the third parameter. If the indentation is successful, it prints the parameter set (curve name) to the BIO object and returns 1. The function is used to print the parameter set (curve name) of a given EVP_PKEY object to a BIO object with indentation."
openssl-101u,O0,arm,param_print_gost94,./data/decomp/openssl-101u_arm_gcc_O0_extraction/param_print_gost94@00119970.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It initializes an array of BIGNUM pointers called local_1c. It then gets the BIGNUM value from the EVP_PKEY object using EVP_PKEY_get0 and stores it in a void pointer called pvVar2. Next, the function loops through an array called R3410_paramset, which contains various BIGNUM values. For each value in the array, it converts the value from a string to a BIGNUM using BN_dec2bn and compares it to the BIGNUM value stored in pvVar2 using BN_cmp. If the values match, it sets the integer variable iVar4 to the corresponding NID value and breaks out of the loop. Finally, the function prints out the NID value using BIO_printf and returns 1. If no match is found in the loop, the function still prints out a parameter set value and returns 1."
openssl-101u,O0,arm,pkey_ctrl_gost,./data/decomp/openssl-101u_arm_gcc_O0_extraction/pkey_ctrl_gost@00119398.c,"The `pkey_ctrl_gost` function takes in four parameters: `param_1` of type `EVP_PKEY*`, `param_2` of type `undefined4`, `param_3` of type `X509_ALGOR*`, and `param_4` of type `PKCS7_SIGNER_INFO*`. The function checks the value of `param_2` and performs different actions depending on its value. If `param_2` is 1 or 5, it sets the `local_1c` array to the value of `param_3` and gets the algorithm information from `param_4`. If `param_2` is 2 or 7, it sets `param_3` to NULL, encodes the GOST algorithm parameters, and gets the algorithm information from `param_4`. If `param_2` is 3, it sets the version of `param_4` to 0."
openssl-101u,O0,arm,priv_encode_gost,./data/decomp/openssl-101u_arm_gcc_O0_extraction/priv_encode_gost@00119560.c,"The function takes in two parameters, a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure. It gets the NID of the EVP_PKEY and the corresponding ASN1_OBJECT. It encodes the GOST algorithm parameters and stores the result. If pval is not NULL, it retrieves the private key value from the EVP_PKEY structure based on the key type (GOST or ECDSA). It converts the private key value to an ASN1_INTEGER."
openssl-101u,O0,arm,pub_encode_gost94,./data/decomp/openssl-101u_arm_gcc_O0_extraction/pub_encode_gost94@0011948c.c,"The function takes in a pointer to an X509_PUBKEY structure and a pointer to an EVP_PKEY structure, retrieves the public key and algorithm OID, encodes any parameters, converts the public key to binary format, creates an ASN1_OCTET_STRING object with the binary data in reverse byte order, encodes the string, sets the parameters and public key in the X509_PUBKEY structure, and returns an integer indicating success or failure."
openssl-101u,O0,arm,pub_print_gost94,./data/decomp/openssl-101u_arm_gcc_O0_extraction/pub_print_gost94@00119a20.c,"The function takes a BIO object, an EVP_PKEY object, and an integer as parameters. It extracts the public key from the EVP_PKEY object and prints it to the BIO object. It compares the parameter sets for the GOST R 34.10-94 algorithm to the one used in the EVP_PKEY object. If it finds a match, it prints the name of the parameter set to the BIO object and returns 1. If no match is found, it returns undefined behavior without printing anything."
openssl-101u,O0,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O0_extraction/RSA_padding_add_PKCS1_PSS@00120050.c,"The function implements the RSA-PSS padding scheme for signing a message digest using a given RSA key. It takes as input the RSA key, the message digest, the hash function used to generate the digest, and the length of the salt (if any) to be used in the padding. It computes the size of the hash digest and checks if it is valid. It then computes the size of the RSA key and the number of padding bytes needed to make the message digest fit within the key size. If a salt length is specified, it uses that length, otherwise it computes a default length based on the key size and hash digest size. Next, it generates a random salt of the specified length (if any) and computes the PSS padding for the message digest using the salt and the specified hash function. It then XORs the padding with the message digest and the salt to create the final message to be signed. Finally, it adds any necessary zero padding to make the message fit."
openssl-101u,O0,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O0_extraction/RSA_verify_PKCS1_PSS@0011f9dc.c,"The function RSA_verify_PKCS1_PSS verifies a PSS signature using RSA encryption. It initializes an EVP_MD_CTX object and checks the validity of the message hash. It removes the first byte of the encoded signature if it is zero and proceeds to verify the signature if the length of the encoded signature plus the size of the message hash plus one is less than the size of the RSA key. To verify the signature, it calculates a mask using PKCS1_MGF1, XORs the mask with the encoded signature to obtain the maskedDB value, and sets the leftmost bits of the first byte."
openssl-101u,O0,arm,sha_block_data_order,./data/decomp/openssl-101u_arm_gcc_O0_extraction/sha_block_data_order@0011bcf0.c,"These functions all implement the SHA-1 hashing algorithm to produce a 160-bit hash value as output. They process the input message in 512-bit blocks and use a series of logical and arithmetic operations, including bitwise rotations, XOR, AND, and addition, to perform the hash computation. The resulting hash state is updated in an input array or set of variables, which can then be used as the starting state for processing the next block of data. Additionally, one of the functions appears to be a loop that prints out a string of characters stored in a character array by iterating through the array and printing out each character using putchar()."
openssl-101u,O0,arm,SHA_Final,./data/decomp/openssl-101u_arm_gcc_O0_extraction/SHA_Final@0011cfd8.c,"The SHA_Final function is the final step in the SHA-1 hashing process. It takes in a pointer to an array of unsigned characters (md) and a pointer to a SHA_CTX structure (c) which contains the data to be hashed. The function first calculates the number of bytes that need to be added to the data to make it a multiple of 64 bytes (the block size for SHA-1). It then adds a single 1 bit to the end of the data and fills the remaining space with 0s. The function then updates the SHA_CTX structure with the length of the data (in bits) and calls the sha_block_data_order function to perform the final hash computation. After the hash computation is complete, the function extracts the five 32-bit hash values from the SHA_CTX structure and stores them in the md array in big-endian byte order. Finally, the function cleans up the SHA_CTX structure and returns 1 to indicate success."
openssl-101u,O0,arm,srp_verify_server_param,./data/decomp/openssl-101u_arm_gcc_O0_extraction/srp_verify_server_param@00068fc8.c,"The `srp_verify_server_param` function takes four parameters: `param_1`, `param_2`, `param_3`, `param_4`. It accesses various data structures including BIGNUMs and function pointers. The function first compares two BIGNUMs and if the first is greater than or equal to the second, or if another BIGNUM is equal to zero, it sets `*param_2` to 0x2f and returns 0. Otherwise, it proceeds to check if the number of bits in one of the BIGNUMs is less than or equal to a certain value stored in `param_1 + 0x1cc`. If it is, it either calls a function `SRP_check_known_gN_param` or a function pointer stored in `param_1 + 0x19c` with `param_1` and another value."
openssl-101u,O0,arm,SSLv23_method,./data/decomp/openssl-101u_arm_gcc_O0_extraction/SSLv23_method@000512ac.c,"The SSLv23_method function returns a pointer to an SSL_METHOD data structure, with its address stored in the variable SSLv23_method_data_18415. It has no parameters and its calling convention is unknown."
openssl-101u,O0,arm,start_hash,./data/decomp/openssl-101u_arm_gcc_O0_extraction/start_hash@0011b880.c,"The function takes a pointer to an array of 4 undefined 4-byte integers as input. If the third element of the array is not equal to 0, it initializes the first four elements of the array to 0, sets the first element to 0 and the second element to 0, and sets the return value to 1. If the third element of the array is equal to 0, the function simply returns the value of the third element of the array."
openssl-101u,O0,arm,surewarehk_finish,./data/decomp/openssl-101u_arm_gcc_O0_extraction/surewarehk_finish@000f2ff4.c,"The function surewarehk_finish() cleans up resources used by the SureWare cryptographic hardware library. It checks if the library has been initialized and calls p_surewarehk_Finish() to perform cleanup operations. It frees the dynamic library object and checks if the operation was successful. If logstream is not NULL, it frees it using the BIO_free() function. Finally, it sets all function pointers used by the library to NULL and returns 1 to indicate success. If the library has not been initialized, it sets the SUREWARE_lib_error_code to the next error in the library and returns 0."
openssl-101u,O0,arm,sv_body,./data/decomp/openssl-101u_arm_gcc_O0_extraction/sv_body@0002686c.c,"The function `sv_body` is responsible for handling the SSL/TLS connection with the client. It initializes the SSL connection, sets various SSL options, and checks for commands from the client. It reads data from the client using `raw_read_stdin`, processes it if necessary, and writes it back to the client using `SSL_write`. If a renegotiation is required during the write operation, the function performs the renegotiation and retries the write. If data is received from the client, it is printed to stdout using `raw_write_stdout`. The function continues to read and write data until the connection is closed or an error occurs."
openssl-101u,O0,arm,TLSv1_method,./data/decomp/openssl-101u_arm_gcc_O0_extraction/TLSv1_method@000525b8.c,"The function returns a pointer to an SSL_METHOD object representing TLSv1 protocol. The SSL_METHOD object may be stored in a global variable named PTR_TLSv1_method_data_18421_000525bc. The function's calling convention is unknown, and its parameter storage is locked, meaning it expects parameters to be passed in a specific way and cannot handle other parameter passing methods."
openssl-101u,O0,arm,__aeabi_idivmod,./data/decomp/openssl-101u_arm_gcc_O0_extraction/__aeabi_idivmod@00123244.c,"The function implements integer division and modulus using ARM Embedded ABI standard. It calls _divsi3_skip_div0_test() and returns if divisor is not zero. If divisor is zero, it checks if dividend is negative and sets it to maximum positive value if positive or minimum negative value if negative. Finally, it performs integer division operation by calling __aeabi_idiv0()."
openssl-101u,O0,arm,__libc_csu_init,./data/decomp/openssl-101u_arm_gcc_O0_extraction/__libc_csu_init@00123954.c,"The function initializes the C runtime startup code by setting a pointer to a specific memory address, calculating an offset, and calling the _init() function. It then calculates the number of function pointers to execute and executes each function pointer if the number is not zero."
openssl-101u,O0,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101u_arm_gcc_O0_extraction/__sha256_block_data_order_from_thumb@001239b8.c,"The functions all implement the SHA-256 algorithm to generate a hash value for a given input. They use a combination of bitwise operations, additions, and constants to update a set of initialized variables based on the input data. The input data is processed in 512-bit blocks, with each block being processed in multiple rounds. The final output of the functions is a 256-bit hash value, represented as an array of 8 32-bit integers. Some of the functions also use a set of pre-defined constants in their calculations."
openssl-101u,O0,arm,__udivdi3,./data/decomp/openssl-101u_arm_gcc_O0_extraction/__udivdi3@00123658.c,"The functions perform unsigned integer division using different algorithms and mathematical operations. They both check if the divisor is zero and return zero if it is. The first function performs division using bit shifts, multiplication, and subtraction operations based on restoring division. It uses a combination of 32-bit and 16-bit arithmetic to perform the operations efficiently and returns the quotient as a 64-bit integer. The second function takes four unsigned integers as parameters and calculates the quotient and remainder using built-in functions. It uses these values to calculate the product of two parameters and subtracts it from the product of the other two parameters. If the result is less than zero, it returns zero."
openssl-101u,O0,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101u_arm_gcc_O0_extraction/___armv7_tick_from_thumb@001239c0.c,"The function processes data using ARMv7 instructions, reads a coprocessor register and performs a vector rounding operation on two input values. It enters a loop to check for exclusive access to a memory location and updates a pointer. If the pointer is greater than 6, it jumps to a label. Otherwise, it enters another loop to write zeroes to memory locations pointed to by the pointer and decrements the pointer until it reaches zero or the input parameter is null. It performs additional operations on the input parameter and jumps to various labels based on variable values. The function is complex and its purpose is unclear without more context."
openssl-101u,O1,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_arm_gcc_O1_extraction/asn1_bio_callback_ctrl@00120dd0.c,"The function takes three parameters: an integer value, an integer value, and a pointer to a function. It checks if the value stored at the memory address (param_1 + 0x24) is not equal to NULL. If it is not NULL, the function calls BIO_callback_ctrl with the parameters *(BIO **)(param_1 + 0x24), param_2, and param_3. If it is NULL, the function simply returns. In summary, the function is a wrapper function that calls BIO_callback_ctrl if a certain condition is met."
openssl-101u,O1,arm,asn1_bio_ctrl,./data/decomp/openssl-101u_arm_gcc_O1_extraction/asn1_bio_ctrl@00120e04.c,"The function `asn1_bio_ctrl` takes in a `BIO` object, an integer, a long integer, and a pointer to an integer. It returns a long integer. The function first retrieves the `int` pointer from the `BIO` object. If the pointer is `NULL`, the function returns `0`. If the integer parameter is `0x97`, the function sets the values of two elements in the pointer array and returns `1`. If the integer parameter is greater than `0x97`, the function checks if it is equal to `0x99`. If it is, the function sets the value of an element in the pointer array."
openssl-101u,O1,arm,asn1_bio_free,./data/decomp/openssl-101u_arm_gcc_O1_extraction/asn1_bio_free@00120ddc.c,"The function takes an integer parameter and attempts to free memory allocated by a previous call to a related function. It checks if the memory block has a sub-block allocated at an offset of 4 bytes and frees that sub-block first using the CRYPTO_free function. It then frees the main memory block using the same function and sets the integer parameter's values to zero. Finally, it returns 1 if memory was freed successfully, and 0 otherwise."
openssl-101u,O1,arm,asn1_bio_write,./data/decomp/openssl-101u_arm_gcc_O1_extraction/asn1_bio_write@00120fac.c,"The function takes in a BIO object, a buffer of data to write, and the length of the data. It returns a BIO object or NULL. The function first checks if the buffer is NULL and sets a flag accordingly. It then checks if the BIO object has a next BIO or a pointer, and returns NULL if either is missing. Next, the function enters a loop that switches on the BIO method. If the method is NULL, it calls a function pointer in the BIO object's ptr field. If the function returns 0, the function clears flags and returns NULL. If the number of bytes written is less than 1, the method is set to 2. If the method is 1, the function loops through a stack of data and writes it to the next BIO. If there is no more data to write, the function calls the next BIO's function pointer and sets the method to 2. If the method is 2, the function calculates the size of the ASN."
openssl-101u,O1,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BIO_asn1_get_suffix@00121228.c,"The function takes a BIO object (b) and two pointers to pointers of type undefined1 (psuffix and psuffix_free) as input parameters, and returns a long value. It calls the BIO_ctrl function with the control command 0x98 and passing 0 and a pointer to a local variable local_18 as arguments. The result of this call is stored in the long variable lVar1. If lVar1 is greater than 0, the function sets the value of the pointer to pointer psuffix to the value of local_18 and the value of the pointer to pointer psuffix_free to the value of the pointer puStack_14. Finally, the function returns the value of lVar1."
openssl-101u,O1,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BIO_asn1_set_prefix@001211d4.c,The function sets the prefix of a BIO pointer to the value pointed to by a prefix pointer and sets the prefix_free function to the value pointed to by a prefix_free pointer. It then uses the BIO_ctrl function with control code 0x95 to set the prefix of the BIO and returns the value returned by the BIO_ctrl function.
openssl-101u,O1,arm,BN_GF2m_add,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_add@0011e2e0.c,"The function BN_GF2m_add performs addition operations in Galois field arithmetic over binary extension fields. It takes in three BIGNUM pointers as parameters (param_1, param_2, and param_3) and returns an integer. It performs a bitwise XOR operation between the values of param_2 and param_3 and stores the result in param_1. If the size of param_1 is not large enough to hold the result, it expands the size of param_1 using the bn_expand2 function. Finally, it removes any leading zero bytes from the result and returns 1 to indicate success."
openssl-101u,O1,arm,BN_GF2m_mod,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod@0011e5b8.c,"The function takes three parameters: param_1, param_2, and param_3. param_1 and param_2 are both undefined 4-byte values, while param_3 is a pointer to an integer array. The function first checks if the second element of the integer array is equal to 0. If it is, the function returns 0. If the second element of the integer array is not equal to 0, the function proceeds to calculate the remainder of param_2 divided by the integer array using the BN_GF2m_mod_arr function. The calculated remainder is then returned as an undefined 4-byte value."
openssl-101u,O1,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_arr@0011e394.c,"The function BN_GF2m_mod_arr performs modular reduction of a BIGNUM value (represented as an array of ulong integers) with respect to a polynomial represented as an array of uint integers. The function takes three parameters: param_1 is a pointer to the result BIGNUM, param_2 is a pointer to the input BIGNUM, and param_3 is a pointer to the polynomial. 

The function first checks if the input BIGNUM is zero, in which case it sets the result BIGNUM to zero and returns 1. If the input and result BIGNUMs are different, it expands the result BIGNUM to the same size as the input BIGNUM, and copies the input BIGNUM into the result BIGNUM. The function then performs the modular reduction by repeatedly dividing the result BIGNUM by the polynomial using long division. It starts from the highest order term of the result BIGNUM and works its way down to the lowest order."
openssl-101u,O1,arm,BN_GF2m_mod_div,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_div@0011ee90.c,"The function BN_GF2m_mod_div performs division in the finite field GF(2^m) using a modified version of the polynomial basis representation. It first calculates the inverse of the divisor using BN_GF2m_mod_inv function. It then calculates the degree of the dividend polynomial and allocates memory accordingly. It then converts the dividend and divisor polynomials to arrays of bit positions of their non-zero coefficients. It then multiplies the inverse of the divisor with the dividend using BN_GF2m_mod_mul_arr function. Finally, it frees the memory and returns the result of the division. If any error occurs during the process, it returns 0."
openssl-101u,O1,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_div_arr@0011efbc.c,"The function takes four parameters and a BN_CTX object pointer. It initializes the BN_CTX object and creates a new BIGNUM object ""a"" with a value of 0. The function sets the bits in ""a"" based on the elements of an array pointed to by param_4. It then calls BN_GF2m_mod_div() with the parameters and ""a"". Finally, the function frees the memory used by the BN_CTX object and returns the result of BN_GF2m_mod_div()."
openssl-101u,O1,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_mul@0011e8dc.c,"The function BN_GF2m_mod_mul performs a multiplication operation on binary polynomials represented as BIGNUMs. It takes two BIGNUMs as input and multiplies them modulo a third BIGNUM. The result is stored in param_1. 

To perform the multiplication, the function first calculates the number of bits in one of the input BIGNUMs and allocates memory for an array of integers to represent the polynomial. It then converts the BIGNUM into an array of integers representing the polynomial, with each integer representing a set bit in the polynomial. The function then calculates the leading zeroes in the array and uses this to determine the degree of the polynomial. 

If the degree of the polynomial is zero, the function calls BN_GF2m_mod_mul_arr to perform the multiplication. Otherwise, it returns an error. 

Finally, the function frees the memory allocated for the polynomial array and returns the result of the multiplication."
openssl-101u,O1,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_mul_arr@0011e778.c,"The function BN_GF2m_mod_mul_arr multiplies two arrays of binary polynomials in GF(2^m) and reduces the result modulo a third binary polynomial. If the two input arrays are the same, the function calls BN_GF2m_mod_sqr_arr to square the input array. The function creates a BIGNUM structure to store the result of the multiplication and reduction. If the BIGNUM structure cannot be created, the function returns 0. The function then multiplies the two input arrays using the bn_GF2m_mul_2x2 function, which multiplies two 2x2 matrices of binary polynomials in GF(2^m). The result is stored in the BIGNUM structure. After the multiplication is complete, the BIGNUM structure is reduced modulo the third binary polynomial using BN_GF2m_mod_arr. If the reduction is successful, the function returns 0. Otherwise, it returns 1. The function uses a BN."
openssl-101u,O1,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_sqr@0011e9bc.c,"The function computes the square of a binary Galois field element represented by a BIGNUM structure. It allocates memory for an array of integers to represent the binary polynomial and extracts the bits of the input element to populate this array. It computes the degree of the polynomial and checks if it is zero, returning an error if so. Otherwise, it calls BN_GF2m_mod_sqr_arr() to compute the square of the polynomial and returns the result. It frees the memory allocated for the polynomial array."
openssl-101u,O1,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_sqrt@0011f21c.c,"The function BN_GF2m_mod_sqrt calculates the square root of a binary polynomial over a finite field GF(2^m) using four parameters: a BIGNUM pointer for the result, an integer parameter, a BIGNUM pointer for the input polynomial, and a BN_CTX pointer for temporary variables. It first calculates the number of bits in the input polynomial, adds one, and allocates an array of integers with that size using CRYPTO_malloc. If the allocation fails, the function returns 0. The function then iterates over the words in the input polynomial, counts the number of set bits in each word, and stores the positions of the set bits in the allocated array. The function also adds -1 to the end of the array to mark its end. Finally, the function calculates the number of leading zeroes in the array size and shifts the result by 5 bits to get the number of words needed to represent the array. If the input polynomial has more bits than the array can hold, the function returns 0."
openssl-101u,O1,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_GF2m_mod_sqr_arr@0011e65c.c,"Function Summary: 

This function starts a BN_CTX context, allocates a BIGNUM structure to store the result of the squaring operation, determines the size of the input array and expands the BIGNUM if necessary, iterates through the input array, squaring each element and storing the result in the BIGNUM, sets the top field of the BIGNUM to the correct value, calls BN_GF2m_mod_arr to reduce the result modulo the specified polynomial, ends the BN_CTX context, and returns 1 if the operation was successful, 0 otherwise."
openssl-101u,O1,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101u_arm_gcc_O1_extraction/bn_GF2m_mul_2x2@001213e0.c,The function `bn_GF2m_mul_2x2` takes in four 32-bit integers and an undefined value and returns an unsigned 64-bit integer. It checks a certain bit in memory and calls either `mul_1x1_neon` or `mul_1x1_ialu` to perform multiplication operations on the input parameters. It then performs bit shifting and XOR operations on the results and stores them in memory.
openssl-101u,O1,arm,BN_kronecker,./data/decomp/openssl-101u_arm_gcc_O1_extraction/BN_kronecker@0011dba4.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs using the binary algorithm to determine if a given integer is a quadratic residue modulo a prime number. It initializes two BIGNUM variables, checks if a_01 is null, and returns an error code if so. It copies the values of a and b into a_00 and a_01, respectively, and checks if a_01 is zero. If a_01 is not zero, the function checks if a_00 is less than one or greater than or equal to -1 shifted left by 31 bits."
openssl-101u,O1,arm,by_dir_entry_free,./data/decomp/openssl-101u_arm_gcc_O1_extraction/by_dir_entry_free@000cd754.c,"The function frees memory pointed to by a double pointer, as well as memory pointed to by a second element in the parameter array (cast to a _STACK pointer) using sk_pop_free with a callback function. It also frees the memory pointed to by the parameter itself using CRYPTO_free."
openssl-101u,O1,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_arm_gcc_O1_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@00119ecc.c,"The function decodes GOST client key exchange parameters from an ASN.1-encoded byte sequence. It takes three parameters: a pointer to an ASN1_VALUE, a double pointer to an unsigned char, and a long integer. Inside the function, it calls the ASN1_item_d2i function to decode an ASN.1 structure from the unsigned char buffer pointed to by param_2. The decoded structure is stored in the memory location pointed to by param_1. The length of the buffer is given by the long integer param_3. The specific ASN.1 structure being decoded is defined by the ASN1_ITEM pointer PTR_GOST_CLIENT_KEY_EXCHANGE_PARAMS_it_00119ed4. The function returns nothing."
openssl-101u,O1,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_arm_gcc_O1_extraction/d2i_GOST_KEY_PARAMS@00119e6c.c,"The function takes in a pointer to an ASN1_VALUE object, a pointer to a uchar array, and a long integer. It calls the ASN1_item_d2i function to convert the uchar array into an ASN1_VALUE object using the GOST_KEY_PARAMS_it_00119e74 ASN1_ITEM structure. The function then returns without any explicit value."
openssl-101u,O1,arm,decode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O1_extraction/decode_gost_algor_params@001188d0.c,"The function decodes parameters for a GOST algorithm from an X509_ALGOR object and sets them in an EVP_PKEY object. It first checks if the algorithm is a GOST algorithm and extracts the parameters, converting them to the appropriate format. It then sets the type of the EVP_PKEY object to the GOST algorithm type and creates an EC_KEY object with the appropriate parameters if the algorithm is GOST R 34.10-2001."
openssl-101u,O1,arm,DES_xcbc_encrypt,./data/decomp/openssl-101u_arm_gcc_O1_extraction/DES_xcbc_encrypt@0011d0fc.c,"The function is an implementation of the Cipher Block Chaining (CBC) mode of the Data Encryption Standard (DES) algorithm. It takes as input a key, an initialization vector (IV), an input message, and the length of the message. It outputs the encrypted message using the DES algorithm in CBC mode. The function first initializes several variables, including the key schedule for the DES algorithm, the IV, and some temporary variables. It then processes the input message in blocks of 8 bytes using the DES algorithm in CBC mode. For each block, it XORs the block with the previous ciphertext (or the IV for the first block), encrypts the result using the DES algorithm, and outputs the resulting ciphertext. It also updates the IV for the next block. If the length of the input message is not a multiple of 8 bytes, the function pads the message with zeros to the nearest multiple of 8 bytes. It then processes the last block using a special padding scheme that depends on the boolean value indicating whether to encrypt or decrypt."
openssl-101u,O1,arm,dgram_ctrl,./data/decomp/openssl-101u_arm_gcc_O1_extraction/dgram_ctrl@000a2408.c,"The two functions take in different parameters and perform different operations based on those parameters. The first function, `dgram_ctrl`, initializes variables and performs a switch statement on `param_2`, modifying variables or performing operations based on the value of `param_2`. If `param_2` is not one of the defined cases, the function sets `param_3` to 0 and returns. If `param_2` is 8, the function sets `param_3` to the value stored at the memory location `(param_1 + 0x10)`. If `param_2` is 9, the function sets the value stored at the memory location `(param_1 + 0x10)` to a value determined by other parameters.

The second function checks if the first byte of a buffer is equal to 0x5a. If it is not, the function sets a parameter to 0 and returns. If it is, the function performs a switch statement on the second byte of the buffer and handles different cases based on its value. In case 0x2d, the function sets a parameter to 1 and copies the first two bytes of another buffer into specific locations in the original buffer. In case 0x2e, the function counts leading zeroes in a parameter, shifts the result by 5 bits, and checks if the first two bytes of the original buffer are equal to 10."
openssl-101u,O1,arm,dlfcn_bind_func,./data/decomp/openssl-101u_arm_gcc_O1_extraction/dlfcn_bind_func@0012070c.c,"The function takes two integer parameters: param_1 and param_2. It first checks if both parameters are non-zero. If they are not, it returns a null pointer and adds an error to the error stack. If both parameters are non-zero, it initializes a void pointer called pvVar4 to zero. It then checks the number of elements in the stack pointed to by the pointer at offset 4 from param_1. If the number of elements is less than 1, it adds an error to the error stack. If the number of elements is greater than or equal to 1, it retrieves the last element in the stack and assigns it to pvVar4. If pvVar4 is null, it adds an error to the error stack. If pvVar4 is not null, it attempts to retrieve the symbol specified by param_2 using dlsym() function. If the retrieval is successful, the function returns the symbol address. If the retrieval fails, it adds an error to the error stack."
openssl-101u,O1,arm,dlfcn_bind_var,./data/decomp/openssl-101u_arm_gcc_O1_extraction/dlfcn_bind_var@001207e0.c,"The function takes in two parameters, param_1 and param_2. If both parameters are not equal to zero, the function proceeds to execute the following steps: Initializes a void pointer pvVar4 to zero. Gets the number of items in the stack pointed to by the pointer stored in param_1+4. If the number of items in the stack is less than 1, an error is put into the error queue. Otherwise, the function retrieves the last item in the stack and stores it in pvVar4. If pvVar4 is equal to zero, an error is put into the error queue. Otherwise, the function attempts to retrieve the symbol named param_2 from the library pointed to by pvVar4 using dlsym(). If the symbol is not found, an error is put into the error queue and the name of the symbol is added to the error data. The function returns the pointer."
openssl-101u,O1,arm,dlfcn_globallookup,./data/decomp/openssl-101u_arm_gcc_O1_extraction/dlfcn_globallookup@00120520.c,"The function uses the dlfcn library to dynamically load a shared object file, find a symbol within it, and close the file. It takes four parameters, but only the first is used. The first parameter is the name of the symbol the function is looking for. The function calls dlopen with a null pointer as the filename, which loads the symbol from the main executable or shared object file that the program was loaded from. The second parameter is set to 1 for global scope, and the third and fourth parameters are passed directly to dlopen as flags. If dlopen is successful, the function calls dlsym with the handle and symbol name. If dlsym is successful, it returns the symbol's address, which is stored in iVar2."
openssl-101u,O1,arm,doapr_outch.constprop.0,./data/decomp/openssl-101u_arm_gcc_O1_extraction/doapr_outch.constprop.0@0009f7cc.c,"The function `doapr_outch_constprop_0` takes four parameters, two of which are pointers to pointers (`param_1` and `param_2`) and two are pointers to unsigned integers (`param_3` and `param_4`). If `param_2` is `NULL`, the function sets `uVar2` to the value pointed to by `param_3` and `uVar3` to the value pointed to by `param_4`. Otherwise, `uVar2` and `uVar3` are set to the values pointed to by `param_3` and `param_4`, respectively. If `uVar2` is equal to `uVar3`, the function checks if `uVar2` is greater than `0x7ffffbff`. If it is, the function returns `0`. Otherwise, the function allocates memory of size `uVar2 + 0x400` using `CRYPTO_malloc`."
openssl-101u,O1,arm,dtls1_link_min_mtu,./data/decomp/openssl-101u_arm_gcc_O1_extraction/dtls1_link_min_mtu@0005d398.c,"The function ""dtls1_link_min_mtu"" returns the minimum transmission unit (MTU) value of 256 for the DTLS protocol in hexadecimal (0x100)."
openssl-101u,O1,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_mont_field_encode@0011f920.c,"The function `ec_GFp_mont_field_encode` encodes field elements in a Montgomery representation to speed up arithmetic operations. It takes four parameters, with the first parameter being a pointer to a data structure. The function accesses a field at offset `0xa0` of that structure to obtain a `BN_MONT_CTX` pointer named `mont`. If `mont` is not equal to `NULL`, the function calls `BN_mod_mul_montgomery` to compute the Montgomery encoding of `param_3` and store the result in `param_2`, using the modulus and other parameters stored in `mont`. If `mont` is equal to `NULL`, the function logs an error using the `ERR_put_error` function and returns 0."
openssl-101u,O1,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_mont_field_sqr@0011f8e8.c,"The function takes in four parameters - an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The integer parameter is used as an offset to access a BN_MONT_CTX pointer stored in memory. If the BN_MONT_CTX pointer is not NULL, the function uses BN_mod_mul_montgomery() function to compute the square of the second BIGNUM parameter (param_3) in the Montgomery domain using the BN_MONT_CTX pointer. The result is stored in the first BIGNUM parameter (param_2). The function then returns the result of the computation. If the BN_MONT_CTX pointer is NULL, the function generates an error using the ERR_put_error() function and returns zero."
openssl-101u,O1,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_mont_group_init@0011f6c4.c,"The function initializes a Montgomery group for ECC using the GF(p) field. It initializes a simple ECC group and sets two variables to zero in the Montgomery group structure, likely for faster ECC operations. The function then returns."
openssl-101u,O1,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0012183c.c,"The function takes in six parameters: 
- param_1: a pointer to an integer representing an EC_GROUP object
- param_2: an integer representing the index of a point on the elliptic curve
- param_3: a pointer to a BIGNUM object representing the x-coordinate of the point
- param_4: a pointer to a BIGNUM object representing the y-coordinate of the point
- param_5: a pointer to a BIGNUM object representing the z-coordinate of the point (optional)
- param_6: a pointer to a BN_CTX object (optional)

The function first checks if the EC_GROUP object has been initialized by checking the value of a specific member variable. If it has not been initialized, the function copies the x-coordinate and y-coordinate parameters into new BIGNUM objects and returns them. If the EC_GROUP object has been initialized, the function checks if the BN_CTX parameter is null. If it is not null, the function."
openssl-101u,O1,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_group_check_discriminant@0012194c.c,"The function takes in an elliptic curve parameters structure and a BN_CTX structure. It checks if the BN_CTX is null and creates a new one if it is. It initializes several BIGNUM variables using the BN_CTX_get() function. If the elliptic curve parameters structure has a null pointer for its ""field_mod_func"" field, the function copies the ""a"" and ""a_00"" values from the structure to the corresponding BIGNUM variables. Otherwise, it calls the ""field_mod_func"" function pointer in the structure to compute the ""a"" and ""a_00"" values. The function then computes the discriminant of the elliptic curve using the formula 4a^3 + 27a_00^2. It does this by first computing r = a^2, r_00 = a*a_00, and then a = r + 4r_00, r_00 = 27."
openssl-101u,O1,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_group_clear_finish@001215f4.c,"The function takes an integer parameter (param_1) which is likely a pointer to a data structure representing an elliptic curve group. The function then clears and frees three BIGNUM variables stored within the data structure at offsets 0x48, 0x74, and 0x88, which likely represent important parameters of the elliptic curve group. Finally, the function returns without any other action."
openssl-101u,O1,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_group_copy@00121fc8.c,"This function is a copy function for an elliptic curve group in GFp. It takes two pointers to a struct representing the group as parameters. The function uses BN_copy from OpenSSL's BIGNUM library to copy the three BIGNUM fields of the source group to the corresponding fields of the destination group. If all three copies are successful, the function sets a flag in the destination group and returns a pointer to it. If any of the copies fail, the function returns a null pointer."
openssl-101u,O1,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_group_get_degree@00121634.c,"The function takes an integer parameter `param_1` which is likely a pointer to a struct representing an elliptic curve group. The function calls the OpenSSL library function `BN_num_bits` on a BIGNUM object located at an offset of 0x48 from the beginning of the struct to calculate the number of bits in the BIGNUM object, which represents the order of the group. The function does not return any useful value."
openssl-101u,O1,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_group_set_curve@0012203c.c,"The function `ec_GFp_simple_group_set_curve` sets the parameters for an elliptic curve group over a finite field of prime order. It takes as input four BIGNUMs representing the prime order of the field, the coefficients of the curve equation, and a BN_CTX structure for temporary variables. The function first checks that the prime order is at least 3 bits long and is a positive integer. If not, it returns an error. If a BN_CTX structure is not provided, it creates one using `BN_CTX_new`. It then allocates a BIGNUM for temporary use using `BN_CTX_start` and retrieves it using `BN_CTX_get`. It then copies the prime order into a BIGNUM `a` and sets its sign to positive. It computes the remainder of the curve coefficient `param_3` modulo the prime order `param_2` using `BN_nnmod` and stores it in `r`. If a custom function pointer is provided at offset."
openssl-101u,O1,arm,ec_GFp_simple_invert,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_invert@00122730.c,"The function checks if an elliptic curve point is at infinity or not, and if its y-coordinate is zero. If it is not at infinity and its y-coordinate is not zero, the function calculates the inverse of the point using BN_usub function. If the inverse does not exist, the function returns 1. The function returns the result of the inverse calculation or 1."
openssl-101u,O1,arm,EC_GFp_simple_method,./data/decomp/openssl-101u_arm_gcc_O1_extraction/EC_GFp_simple_method@00122d2c.c,"EC_GFp_simple_method returns a pointer to an EC_METHOD structure, with unspecified contents, cast to the type of ret_9448. The function's calling convention is unknown, but the storage for its parameters is fixed."
openssl-101u,O1,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_point_copy@00122004.c,"The function takes two memory addresses as parameters. The first parameter is the destination address where a copy of a point on an elliptic curve will be stored, and the second parameter is the source address of the point to be copied. The function uses the BN_copy function from the OpenSSL library to copy three BIGNUM values from the source point to the destination point, representing the x-coordinate, y-coordinate, and z-coordinate of the point on the elliptic curve. If all three BN_copy operations are successful, the function sets the value of the last 4 bytes at the destination address to the value of the last 4 bytes at the source address, which is typically used to indicate whether the point is in affine or projective coordinates. The function returns a pointer to the destination point if all copy operations are successful, or a null pointer if any of the copy operations fail."
openssl-101u,O1,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_point_finish@001215d4.c,"The function deallocates the memory used by three BIGNUM objects within a structure representing an elliptic curve point, using the BN_free function from OpenSSL's cryptographic library. It takes an integer parameter (param_1) which is the memory address of the structure. The x-coordinate, y-coordinate, and z-coordinate of the point are stored in the BIGNUM objects. The function returns without any other actions."
openssl-101u,O1,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_point_get_affine_coordinates@00121ab4.c,"The function takes an EC_POINT object, an EC_GROUP object, two BIGNUM objects (param_3, param_4), and a BN_CTX object (param_5) as input and returns a BIGNUM object. It first checks if the EC_POINT object is at infinity and returns an error if it is. If the BN_CTX object is not provided, the function creates a new one and initializes several BIGNUM objects (pBVar1, ret, r, r_00, and n) using the BN_CTX object. The function then checks if the EC_POINT object is the point at infinity and returns an error if it is. It calculates the x and y coordinates of the point in the EC_POINT object using the EC_GROUP object. If either of the BIGNUM objects (param_3 or param_4) is not null, the function copies the x or y coordinate to the corresponding BIGNUM object."
openssl-101u,O1,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O1_extraction/ec_GFp_simple_point_set_affine_coordinates@0012215c.c,"The function takes in five parameters: an EC_GROUP object, an EC_POINT object, two BIGNUM objects, and a BN_CTX object. It returns an integer value. If the two BIGNUM objects are not null pointers, the function creates a new BIGNUM object with the value of one and calls the EC_POINT_set_Jprojective_coordinates_GFp function with the EC_GROUP object, EC_POINT object, the two BIGNUM objects, the newly created BIGNUM object, and the BN_CTX object as arguments. The function returns the integer value returned by the EC_POINT_set_Jprojective_coordinates_GFp function. If either of the two BIGNUM objects is a null pointer, the function generates an error message using the ERR_put_error function and returns 0."
openssl-101u,O1,arm,encode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O1_extraction/encode_gost_algor_params@00119098.c,"The function encodes an EVP_PKEY parameter as an ASN1_STRING in GOST algorithm parameters format. It creates a new ASN1_STRING object and a GOST_KEY_PARAMS object, retrieves the curve name or parameter set depending on the type of the EVP_PKEY, sets the curve or parameter set in the GOST_KEY_PARAMS object, encodes it as an ASN1_STRING, sets the type of the ASN1_STRING to 0x10 (GOST algorithm parameters), and returns the encoded ASN1_STRING. If there is an error, the function returns NULL."
openssl-101u,O1,arm,get_gost_engine_param,./data/decomp/openssl-101u_arm_gcc_O1_extraction/get_gost_engine_param@0011ae64.c,"The function takes an integer parameter called ""param_1"". If the parameter is not equal to 0, it returns a null pointer. Otherwise, it checks if the global variable ""gost_params"" is null. If it is, it tries to get the value of the environment variable ""CRYPT_PARAMS"" using the getenv() function. If this variable is not set, it also returns a null pointer. Otherwise, it uses the BUF_strdup() function to allocate memory for a copy of the string and assigns it to the ""gost_params"" variable. Finally, it returns the value of ""gost_params""."
openssl-101u,O1,arm,gost2001_param_encode,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost2001_param_encode@00118c28.c,"The function extracts an EC_GROUP object from an EVP_PKEY object representing a GOST R 34.10-2001 parameter set. It then gets the curve name from the group and converts it to an ASN1_OBJECT structure using the OBJ_nid2obj function. Finally, it encodes the ASN1_OBJECT structure using the i2d_ASN1_OBJECT function and stores the resulting encoded data in the memory pointed to by the second argument. The function does not return a value."
openssl-101u,O1,arm,gost_cipher_cleanup,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost_cipher_cleanup@0011a024.c,"The function takes an integer parameter to access a memory location, calls `gost_destroy` with an argument that is the value of the memory location plus 0xc to free memory used by the GOST cipher algorithm, sets the memory location to 0, and returns 1."
openssl-101u,O1,arm,gost_cipher_ctl,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost_cipher_ctl@0011a46c.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. 

If `param_2` is equal to 6, the function calls `RAND_bytes` with `param_4` as the destination buffer and the value pointed to by `param_1 + 0x58` as the length of the random bytes to be generated. If `RAND_bytes` returns a value greater than 0, the function returns 1. Otherwise, it calls `ERR_GOST_error` with error code 0x6f and subcode 0x7b, passing ""gost_crypt.c"", 0x195, and `param_4` as additional parameters, and returns 0xffffffff.

If `param_2` is equal to 7, the function checks if `param_4` is not equal to null. If it is not null, the function..."
openssl-101u,O1,arm,gost_cipher_do_cnt,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost_cipher_do_cnt@0011a13c.c,"The first function implements the GOST cipher algorithm in counter mode. It takes in four parameters: an integer representing the state of the cipher, pointers to arrays of unsigned integers representing the plaintext and ciphertext, and a pointer to an array of bytes representing the length of the plaintext. The function generates a keystream using the gost_cnt_next function, updates the state of the cipher, XORs the plaintext with the keystream to produce the ciphertext, and returns 1 if successful.

The second function takes in four parameters and performs a byte-level encryption or decryption operation. It initializes some variables, checks the length of param_4, XORs two bytes from param_1 and param_3, stores the result in param_2, and sets a value in param_1 before returning 1. If param_4 is less than or equal to 2, the function returns 0."
openssl-101u,O1,arm,gost_cipher_init,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost_cipher_init@0011acb0.c,"The function initializes the GOST cipher context with specified parameters, retrieves the GOST engine parameters if the app_data field is NULL, sets the cipher_data field to an integer array that stores the GOST cipher parameters and internal state, sets the cipher key if specified using the gost_key function, copies the initialization vector (IV) to the context's oiv field and initializes the IV by copying it to the iv field, and returns 1 to indicate success."
openssl-101u,O1,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O1_extraction/GOST_CIPHER_PARAMS_new@00119eb4.c,"The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new() function, which allocates memory for the new structure and initializes its values to default values. It takes a pointer to an ASN1_ITEM structure as an argument, which in this case is PTR_GOST_CIPHER_PARAMS_it_00119ebc. The function then returns without any further action."
openssl-101u,O1,arm,gost_imit_final,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost_imit_final@0011aacc.c,"The function `gost_imit_final` takes an integer `param_1` and an undefined 4-byte value `param_2` as parameters. It retrieves two integer values `iVar1` and `iVar2` from memory locations based on `param_1`. If `iVar1` is zero, it calls the `ERR_GOST_error` function with error code `0x8c` and message ""gost_crypt.c"" at line number `0x239` and jumps to the end of the function. If `iVar1` is not zero, the function checks if another integer value `iVar1` is zero. If it is, the function checks if another integer value at memory location `iVar2 + 0x1038` is not zero. If it is not zero, the function initializes two integer values `local_24` and `local_20`."
openssl-101u,O1,arm,gost_imit_init_cpa,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost_imit_init_cpa@0011a418.c,"The function takes an integer parameter and retrieves a value from memory at offset 0xc from it, assigning it to `iVar1`. It initializes memory at various offsets with zeros and one, and then calls the `gost_init` function with `iVar1`, a constant, and a memory pointer. The function returns 1."
openssl-101u,O1,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O1_extraction/GOST_KEY_PARAMS_new@00119e84.c,The function creates a new instance of the GOST_KEY_PARAMS structure using ASN1_item_new function and does not return any value. The GOST_KEY_PARAMS structure is defined in ASN.1 format.
openssl-101u,O1,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_arm_gcc_O1_extraction/GOST_KEY_TRANSPORT_free@00119e00.c,"The function frees memory allocated to an ASN1_VALUE structure using the ASN1_item_free function and a pointer to the ASN1_ITEM type, GOST_KEY_TRANSPORT_it. It takes the structure to be freed as a parameter and returns nothing."
openssl-101u,O1,arm,gost_param_free,./data/decomp/openssl-101u_arm_gcc_O1_extraction/gost_param_free@0011ae0c.c,The function frees the memory allocated for the GOST parameters by checking if the gost_params pointer is not null and using the CRYPTO_free function. It then sets the gost_params pointer to null and returns from the function.
openssl-101u,O1,arm,hash_step,./data/decomp/openssl-101u_arm_gcc_O1_extraction/hash_step@0011aed8.c,"The first function takes in three parameters, performs a step in the GOST hash algorithm, and updates the input pointers with the updated hash state values. It checks if the input pointers are aligned to 4 bytes and performs a bitwise or byte-wise XOR operation accordingly. It initializes local variables, calls the gost_enc_with_key function, and performs bitwise and XOR operations on the local variables and input parameters to update the GOST hash state.

The second function performs encryption using the GOST algorithm with a given key and input data. It initializes local variables, performs operations on them, calls the GOST encryption function, performs additional operations on the encrypted data, and returns the result.

The third function takes in four arguments, performs some XOR operations on local variables, calls the gost_enc_with_key function with some of these variables as arguments, performs more XOR operations on the local variables and the output data block, copies the result to the output data block, and checks if a value stored in memory matches a local variable before throwing an error."
openssl-101u,O1,arm,hwcrhk_init,./data/decomp/openssl-101u_arm_gcc_O1_extraction/hwcrhk_init@000f20a4.c,"The function initializes the hardware crypto hook (hwcrhk) library by loading the library, binding necessary functions, and setting global variables. It checks if the library has already been loaded and generates an error if it cannot be loaded. The function binds necessary functions and generates an error if any required functions cannot be found. Global variables are set to point to the functions and mutex callbacks are set up if necessary. The function also initializes the RSA key handle using RSA_get_ex_new_index. Any errors that occur during the initialization process are generated and stored in the HWCRHK_lib_error_code variable."
openssl-101u,O1,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_arm_gcc_O1_extraction/i2d_GOST_KEY_AGREEMENT_INFO@00119e48.c,The function converts an ASN1_VALUE pointer to a DER-encoded byte string using the ASN1_item_i2d function and an ASN1_ITEM structure for GOST_KEY_AGREEMENT_INFO. The resulting byte string is stored in the memory pointed to by a pointer to a pointer of unsigned characters. The function returns nothing.
openssl-101u,O1,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_arm_gcc_O1_extraction/i2d_GOST_KEY_TRANSPORT@00119de8.c,"The function takes in two parameters: 
1. param_1: a pointer to an ASN1_VALUE structure 
2. param_2: a pointer to a pointer to an unsigned character (uchar) 

The function uses the ASN1_item_i2d() function to encode the ASN1_VALUE structure pointed to by param_1 into a binary format and store it in the memory location pointed to by param_2. The encoding is performed using the ASN1_ITEM structure for the GOST_KEY_TRANSPORT data type. 

Finally, the function returns without any value."
openssl-101u,O1,arm,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_arm_gcc_O1_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@0008653c.c,"The function takes in a BIGNUM structure, an integer parameter, an array of unsigned integers, and two unsigned integers. It checks if the BIGNUM structure has enough space to hold the integer parameter and expands it if necessary. It performs a bit-wise operation on the input array of unsigned integers based on the values of the two unsigned integers. If the second unsigned integer is less than 4, the function performs a loop over the input array and stores the result in the BIGNUM structure. If the second unsigned integer is greater than or equal to 4, the function performs a more complex bit-wise operation on the input array and stores the result in the BIGNUM structure. The function removes any leading zero elements from the BIGNUM structure and updates its ""top"" field accordingly. The function returns 1 if successful."
openssl-101u,O1,arm,mul_1x1_ialu,./data/decomp/openssl-101u_arm_gcc_O1_extraction/mul_1x1_ialu@001212c0.c,"The decompiled function is likely a placeholder or stub function, as it only contains a return statement without any code logic. It may be intended to perform a multiplication operation using a 1x1 integer arithmetic logic unit (IALU)."
openssl-101u,O1,arm,param_copy_gost94,./data/decomp/openssl-101u_arm_gcc_O1_extraction/param_copy_gost94@00118de8.c,"This function takes in two EVP_PKEY pointers as input parameters, param_1 and param_2. It retrieves the DSA key from param_1 and the parameters from param_2. It checks if the base ids of the two parameters match, and if they don't, it returns an error. If the parameters are valid, it checks if the DSA key is null. If it is, it creates a new DSA key and assigns it to param_1. It then copies the parameters from param_2 to the DSA key's fields. If the DSA key already has values in its fields, it frees them before copying the new values. Finally, it checks if the DSA key has a private key. If it does, it recomputes the public key. The function returns 1 on success and 0 on failure. If the parameters or DSA key are invalid, it returns an error."
openssl-101u,O1,arm,param_print_gost01,./data/decomp/openssl-101u_arm_gcc_O1_extraction/param_print_gost01@001199e4.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer, and returns an integer value. It extracts the EC_KEY object from the EVP_PKEY object and gets the associated EC_GROUP object. It then gets the curve name and indents the output of the BIO object using the 'BIO_indent' function. If successful, it gets the long name of the curve using the 'OBJ_nid2ln' function and prints it to the BIO object using 'BIO_printf'. It returns 1 to indicate success, or 0 if the indentation was unsuccessful."
openssl-101u,O1,arm,param_print_gost94,./data/decomp/openssl-101u_arm_gcc_O1_extraction/param_print_gost94@00119970.c,"The function param_print_gost94 takes in a BIO object, an EVP_PKEY object, and an integer for indentation. It retrieves the key parameters from the EVP_PKEY object and iterates through a list of predefined parameter sets for the GOST R 34.10-94 algorithm. For each parameter set, it compares the parameter string to the key parameters retrieved earlier. If the two values are equal, the function returns the NID of the parameter set using OBJ_nid2ln. If no match is found, it frees the BIGNUM object."
openssl-101u,O1,arm,pkey_ctrl_gost,./data/decomp/openssl-101u_arm_gcc_O1_extraction/pkey_ctrl_gost@00119398.c,"The function `pkey_ctrl_gost` takes in four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. It first checks the value of `param_2` and performs different actions based on its value. If `param_2` is 1, 2, 5, or 7, the function sets the value of `local_1c[0]` to the value of `param_3`, performs some additional operations, and then returns 1. If `param_2` is 3, the function sets the `version` field of `param_4` to 0x329 and returns 2. If `param_2` is any other value, the function returns -2. Additionally, if `param_2` is 1 or 5, the function calls `EVP_PKEY_base_id` to get the base ID of the `param_1` key."
openssl-101u,O1,arm,priv_encode_gost,./data/decomp/openssl-101u_arm_gcc_O1_extraction/priv_encode_gost@00119560.c,"The function takes in a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure. It encodes the GOST algorithm parameters using the encode_gost_algor_params function and stores the result in the pval variable. It then checks the type of the EVP_PKEY structure and extracts the private key (if applicable) into a BIGNUM structure. Next, it converts the BIGNUM into an ASN1_INTEGER using the BN_to_ASN1_INTEGER function and stores the result in the a variable. It then encodes the ASN1_INTEGER into a byte array using the i2d_ASN1_INTEGER function and stores the result in the local_1c variable. Finally, it sets the PKCS8_PRIV_KEY_INFO structure using the PKCS8_pkey_set0 function, providing it with the ASN1_OBJECT for the GOST algorithm, the pval and local_1c byte arrays, and the length of the local_1c array."
openssl-101u,O1,arm,pub_encode_gost94,./data/decomp/openssl-101u_arm_gcc_O1_extraction/pub_encode_gost94@0011948c.c,"The function encodes a GOST 94 public key into an X509_PUBKEY structure. It retrieves the algorithm's OID from the EVP_PKEY structure and encodes any associated parameters using the encode_gost_algor_params function. The public key is converted from a BIGNUM to a binary string, reversed, and stored in an ASN1_OCTET_STRING structure. The function sets the parameters and public key in the X509_PUBKEY structure and returns 0 if there is an error and 1 otherwise. It takes two parameters, a pointer to the X509_PUBKEY structure and a pointer to the EVP_PKEY structure containing the public key."
openssl-101u,O1,arm,pub_print_gost94,./data/decomp/openssl-101u_arm_gcc_O1_extraction/pub_print_gost94@00119a20.c,"The function takes in a BIO object and an EVP_PKEY object. It extracts the BIGNUM value from the EVP_PKEY object and prints it to the BIO object. It then searches through an array of parameter sets until it finds a match for the BIGNUM value, prints the name of the parameter set to the BIO object, and returns 1."
openssl-101u,O1,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O1_extraction/RSA_padding_add_PKCS1_PSS@00120050.c,"The function implements the PKCS#1 PSS padding scheme for RSA encryption. It takes as input a RSA key, a message hash, a hash function, and an optional salt length. The function calculates the size of the hash and checks if it is valid. It then calculates the size of the salt based on the RSA key size and the specified salt length. It generates a random salt if a salt length is specified, and initializes a hash context with the specified hash function. It then computes the hash of the message with the specified hash function and updates the hash context with the message hash and the salt (if present). It generates a mask using the PKCS#1 MGF1 function and XORs it with the hash value to obtain the encoded message. Finally, it adds the PKCS#1 PSS padding to the encoded message and returns the resulting byte array."
openssl-101u,O1,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O1_extraction/RSA_verify_PKCS1_PSS@0011f9dc.c,"The function verifies a message signature using the RSA-PSS algorithm. It requires a RSA key, a message hash, a hash function, an encoded message, and the length of the encoded message. The function initializes an EVP message digest context, checks the length of the encoded message, calculates the number of bits in the RSA key and the size of the RSA key. It also checks the validity of the first byte of the encoded message for the RSA-PSS algorithm, removes it if it is zero, and proceeds to decode the encoded message if the concatenated message (hash + salt) plus one is less than the RSA key size. The function generates a mask using PKCS1_MGF1 and XORs it with the encoded message to get the original message. It checks the validity of the first byte of the mask if it is zero and proceeds to check the rest of the mask."
openssl-101u,O1,arm,sha_block_data_order,./data/decomp/openssl-101u_arm_gcc_O1_extraction/sha_block_data_order@0011bcf0.c,"These functions all involve the implementation of the SHA-1 hash algorithm. They take in an input message and produce a fixed-size output hash. The algorithm processes the input message in blocks of 512 bits and produces a 160-bit hash value. The functions perform a series of bitwise operations and additions on the variables, using constants and the values of the input message. They also use several constants in their operations. The output of each block is then combined with the output of the previous block to produce the final message digest. One of the functions takes in a pointer to a character array and an integer value and prints out the string pointed to by the character array a number of times equal to the integer value passed as an argument."
openssl-101u,O1,arm,SHA_Final,./data/decomp/openssl-101u_arm_gcc_O1_extraction/SHA_Final@0011cfd8.c,"The SHA_Final function is the final step in the SHA-1 hashing algorithm. It takes in a pointer to a buffer (md) and a SHA_CTX structure (c) that contains the intermediate hash values and the data to be hashed. The function first calculates the length of the data (in bytes) that has been hashed so far and adds a padding byte (0x80) to the end of the data. If the length of the data plus the padding byte is less than 56 bytes, then the function adds enough zero bytes to bring the total length to 56 bytes. If the length is greater than or equal to 56 bytes, then the function adds enough zero bytes to fill the current block (64 bytes) and processes it using the sha_block_data_order function. The function then appends the length of the data (in bits) to the end of the block and processes it using the sha_block_data_order function again. Finally, the function copies the five intermediate."
openssl-101u,O1,arm,srp_verify_server_param,./data/decomp/openssl-101u_arm_gcc_O1_extraction/srp_verify_server_param@00068fc8.c,"The function `srp_verify_server_param` takes four parameters: an integer `param_1`, a pointer to an undefined 4-byte value `param_2`, an undefined 4-byte value `param_3`, and another undefined 4-byte value `param_4`. It compares two BIGNUM values stored at offsets `0x1ac` and `0x1a8` of the memory location pointed to by `param_1`. If the first value is greater than or equal to the second value, or if another BIGNUM value stored at offset `0x1b4` is less than the second value or has a length of 0, then the function sets the value pointed to by `param_2` to `0x2f` and returns 0. Otherwise, the function calculates the number of bits in the second BIGNUM value and compares it to the value stored at offset `0x1cc` of `param`."
openssl-101u,O1,arm,SSLv23_method,./data/decomp/openssl-101u_arm_gcc_O1_extraction/SSLv23_method@000512ac.c,"The SSLv23_method function returns a pointer to an SSL_METHOD object, which represents the SSLv23 protocol method. It does not require any arguments and its calling convention is unknown. The SSLv23_method_data_18415 object is a predefined object that is returned by this function."
openssl-101u,O1,arm,start_hash,./data/decomp/openssl-101u_arm_gcc_O1_extraction/start_hash@0011b880.c,"The function takes in a pointer to an array of 4 undefined 4-byte integers as its parameter. It retrieves the value of the third element in the array (index 2) and stores it in the variable iVar1. If the value of iVar1 is not equal to 0, it clears the memory of the next 32 bytes starting from the fourth element in the array (index 3) and the next 32 bytes starting from the twelfth element in the array (index 11), effectively setting these bytes to 0. It also sets the first element in the array (index 0) to 0, the second element in the array (index 1) to 0, and the fourth element in the array (index 3) to 0. Finally, it returns the value of iVar1, which would be 1 if the initial value of the third element in the array was not equal to 0, and 0 otherwise."
openssl-101u,O1,arm,surewarehk_finish,./data/decomp/openssl-101u_arm_gcc_O1_extraction/surewarehk_finish@000f2ff4.c,"The function is used to finish the SureWare KeySecure library and free any resources that were allocated during initialization. It checks if the library has been initialized and calls p_surewarehk_Finish to finish the library. It then frees the surewarehk_dso variable using DSO_free() and frees the logstream variable. The function sets all function pointers to null and returns 1 if the library was successfully finished, and 0 otherwise."
openssl-101u,O1,arm,sv_body,./data/decomp/openssl-101u_arm_gcc_O1_extraction/sv_body@0002686c.c,"The function implements the server-side of a SSL/TLS connection by allocating memory for a buffer, setting the socket to non-blocking mode if specified, creating a new SSL object, setting various options and callbacks, associating the SSL object with the socket, and entering a loop where it waits for data to be available on the socket or stdin. If there is pending SSL data, it is processed. Otherwise, the function waits for data on the socket or stdin using the select() system call. If data is available on stdin, it is read into the buffer and processed. If data is available on the socket, it is read into the SSL object and processed. The loop continues until an error occurs or the SSL connection is closed. If an error occurs, the function cleans up and returns the error code.

The function is also the main body of the SSL server. It initializes the SSL connection by calling the init_ssl_connection() function, enters a loop where it reads data from the client using SSL_read() and writes data to the client using SSL_write(), and handles various commands that can be sent by the client. The loop continues until there is an error or the client sends a command to quit the connection. If the connection is closed, the function shuts down the socket and closes it."
openssl-101u,O1,arm,TLSv1_method,./data/decomp/openssl-101u_arm_gcc_O1_extraction/TLSv1_method@000525b8.c,The function TLSv1_method returns a pointer to an SSL_METHOD data structure. The data structure is not defined in the given code snippet and the calling convention for this function is unknown. The function simply returns the value stored in the memory location pointed to by the variable PTR_TLSv1_method_data_18421_000525bc.
openssl-101u,O1,arm,__aeabi_idivmod,./data/decomp/openssl-101u_arm_gcc_O1_extraction/__aeabi_idivmod@00123244.c,"The function performs integer division and modulus operation, checking for a zero divisor and modifying the dividend if necessary. It calls `_divsi3_skip_div0_test()` to perform the operation and `__aeabi_idiv0()` to complete it."
openssl-101u,O1,arm,__libc_csu_init,./data/decomp/openssl-101u_arm_gcc_O1_extraction/__libc_csu_init@00123954.c,"The function __libc_csu_init initializes the C runtime environment and SSL certificate, calculates the number of function pointers to be called, loops through each pointer to call the corresponding function with given parameters, and returns."
openssl-101u,O1,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101u_arm_gcc_O1_extraction/__sha256_block_data_order_from_thumb@001239b8.c,"The functions are implementing the SHA-256 hashing algorithm on input data. They initialize variables and constants, and then perform a series of complex mathematical operations using bitwise shifts, XORs, ANDs, additions, and rotations. They process the input data in 512-bit chunks, using a loop that iterates through each block. Within each block, they perform several rounds of operations using the initialized constants and variables. At the end of each block, the result is added to the running hash value. The final output is the hash of the entire message. Overall, the functions are generating a cryptographic hash of the input data to produce a unique output that can be used for secure communication."
openssl-101u,O1,arm,__udivdi3,./data/decomp/openssl-101u_arm_gcc_O1_extraction/__udivdi3@00123658.c,"The functions both take four parameters and involve arithmetic operations. 

The first function implements unsigned integer division for 64-bit integers. It handles cases where the denominator is zero or nonzero and uses helper functions to perform the division. 

The second function also performs arithmetic operations using the parameters and returns a 64-bit unsigned integer. It checks if param_3 is zero and if param_4 is greater than or equal to param_2, and performs different operations based on these conditions. It also uses helper functions."
openssl-101u,O1,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101u_arm_gcc_O1_extraction/___armv7_tick_from_thumb@001239c0.c,"The function is a timer interrupt handler for an ARMv7 processor that takes an integer and a pointer to an array of 32-bit integers as parameters. It reads the current value of a co-processor register and performs vector arithmetic on two double-precision floating-point values. It updates a pointer stored in a memory location pointed to by the first parameter using the result. The function then checks if the length of the array pointed to by the second parameter is greater than 6. If it is, it sets a local pointer variable to point to the second-to-last element of the array and enters a loop that writes zeros to the memory locations pointed to by the array elements, starting from the end of the array and moving towards the beginning. If the array length is less than or equal to 6, it sets a boolean flag to false and checks if the second parameter is NULL. If it is, the function jumps to a return statement."
openssl-101u,O2,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_arm_gcc_O2_extraction/asn1_bio_callback_ctrl@00120dd0.c,"The `asn1_bio_callback_ctrl` function takes three parameters: `param_1`, `param_2`, and `param_3`. It checks if the value stored at the address `param_1 + 0x24` (which is a pointer to a `BIO` structure) is not equal to NULL. If it is not NULL, the function calls the `BIO_callback_ctrl` function with the `BIO` pointer, `param_2`, and `param_3` as arguments. If the `BIO` pointer is NULL, the function simply returns."
openssl-101u,O2,arm,asn1_bio_ctrl,./data/decomp/openssl-101u_arm_gcc_O2_extraction/asn1_bio_ctrl@00120e04.c,"The `asn1_bio_ctrl` function takes a BIO object, a control command, a control argument, and a pointer to an integer. It checks if the `ptr` member of the BIO object is NULL, and returns 0 if it is. Otherwise, it performs the corresponding action based on the control command. If the control command is 0x97, it sets the `ptr[10]` and `ptr[11]` members of the BIO object to the first and second elements of `param_4`, respectively, and returns 1. If the control command is 0x99, it sets the `ptr[15]` member of the BIO object to the value of `param_4` and returns 1. If the control command is 0x9a, it sets the value of `param_4`."
openssl-101u,O2,arm,asn1_bio_free,./data/decomp/openssl-101u_arm_gcc_O2_extraction/asn1_bio_free@00120ddc.c,"The function `asn1_bio_free` frees memory blocks pointed to by a BIO structure's `ptr`, `param_1 + 0xc`, and `param_1 + 0x14` member variables. If `ptr` is not `NULL`, the function checks if the memory block pointed to by `*(void **)((int)ptr + 4)` is not `NULL`. If it is not `NULL`, the function frees it using the `CRYPTO_free` function."
openssl-101u,O2,arm,asn1_bio_write,./data/decomp/openssl-101u_arm_gcc_O2_extraction/asn1_bio_write@00120fac.c,"The function takes in a BIO object, a data buffer, and a length parameter. It checks if the data buffer is null and sets a flag accordingly. It checks if the BIO object has a next_bio and a pointer to a structure, and returns null if either of these are missing. The function checks the BIO method and performs different actions based on the method. If the method is null, it calls a function pointed to by the BIO object's ptr field. If the function returns 0, it clears flags and returns null. If the num_write field of the BIO object is less than 1, it sets the method to 2, otherwise it sets it to 1. If the method is 1, the function writes the data to the next_bio in a loop until all the data has been written. It then calls the next_bio function if there is one, sets the method to 2, and clears the stack."
openssl-101u,O2,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BIO_asn1_get_suffix@00121228.c,"The function ""BIO_asn1_get_suffix"" retrieves the suffix of an ASN.1 object from a BIO and stores it in the location pointed to by ""psuffix"". It takes in a BIO pointer, a pointer to a pointer of undefined type, and a pointer to a pointer of undefined type. The function returns the length of the suffix. The function first calls the BIO_ctrl function to retrieve the suffix, and if the length of the suffix is greater than 0, it sets the value of ""psuffix"" and ""psuffix_free""."
openssl-101u,O2,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BIO_asn1_set_prefix@001211d4.c,"The function sets the prefix for a BIO object using the BIO_ctrl function with a control command and a prefix string argument. It takes in the BIO object, a pointer to the prefix string, and a pointer to a function that frees the prefix string. The function returns the result of the BIO_ctrl function."
openssl-101u,O2,arm,BN_GF2m_add,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_add@0011e2e0.c,"The function BN_GF2m_add performs addition of two binary polynomials represented by BIGNUM structures. It determines the length of the longer binary polynomial between the input parameters and assigns it to a variable. If the output parameter is not large enough to store the result, the function calls bn_expand2 to allocate more memory. Then, the function performs bitwise XOR operation between the binary polynomials represented by the input parameters and stores the result in the output parameter. Finally, the function removes any leading zero bits from the resulting binary polynomial stored in the output parameter and returns 1 to indicate success."
openssl-101u,O2,arm,BN_GF2m_mod,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod@0011e5b8.c,"The function takes in three parameters: param_1, param_2, and param_3. param_1 and param_2 are both undefined 4-byte variables. param_3 is a pointer to an integer array. The function first checks if the second element of the integer array is equal to zero. If it is, the function returns 0. If the second element of the integer array is not equal to zero, the function creates a new integer array called aiStack_30. The function then iterates through the integer array pointed to by param_3, starting from the end. For each non-zero element in the array, the function determines the position of the highest set bit and stores it in aiStack_30. Once all non-zero elements have been processed, the function checks if there are more than 6 set bits in aiStack_30. If there are, the function returns 0. If there are 6 or fewer, the function continues."
openssl-101u,O2,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_arr@0011e394.c,"The function BN_GF2m_mod_arr takes in three parameters: a BIGNUM pointer named param_1, another BIGNUM pointer named param_2, and a uint pointer named param_3. It checks if the value of the uint pointed to by param_3 is 0. If it is, it sets the value of param_1 to 0 and returns 1. If the value of param_3 is not 0, the function checks if param_2 and param_1 are the same. If they are, it assigns the value of param_1's d field to a pointer named puVar11 and assigns param_1's top field to a variable named iVar5. If they are not the same, it checks if param_1's dmax field is less than param_2's top field. If it is, it expands param_1's memory allocation using the bn_expand2 function. If this fails, the function."
openssl-101u,O2,arm,BN_GF2m_mod_div,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_div@0011ee90.c,"The function BN_GF2m_mod_div performs division in the Galois field GF(2^m) using a modified version of the Barrett reduction algorithm. It takes in four BIGNUM pointers and a BN_CTX pointer. The function starts a BN_CTX context and gets a BIGNUM pointer from the context. It then calculates the modular inverse of param_4 modulo param_3 using BN_GF2m_mod_inv and stores the result in pBVar1. If the modular inverse calculation fails, the function returns 0. The function also calculates the number of bits in param_4 and allocates memory for an array."
openssl-101u,O2,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_div_arr@0011efbc.c,"The function takes four inputs - three integers and a pointer to an integer array, and a BN_CTX pointer. It starts a BN_CTX session, creates a BIGNUM pointer named 'a', sets its value to zero, sets corresponding bits in 'a' for non-negative integers in the array, performs a division operation on two GF(2^m) using BN_GF2m_mod_div(), ends the BN_CTX session, and returns the output of BN_GF2m_mod_div()."
openssl-101u,O2,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_mul@0011e8dc.c,"The function BN_GF2m_mod_mul in the OpenSSL library performs binary polynomial multiplication in GF(2^m) field. It takes five parameters, including two pointers to BIGNUM structures. The function calculates the number of bits in the first BIGNUM parameter using BN_num_bits function and allocates memory for an array of integers. It checks if the top value of the first BIGNUM parameter is non-zero and iterates over each word and bit in the BIGNUM parameter if it is non-zero. If memory allocation fails, the function returns 0."
openssl-101u,O2,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_mul_arr@0011e778.c,"The function BN_GF2m_mod_mul_arr() takes in five parameters: an integer, two integer pointers, an additional integer, and a BN_CTX pointer. It checks if the two input arrays are equal and calls the BN_GF2m_mod_sqr_arr() function with the same parameters and returns its result if they are. If not, it initializes a new BIGNUM variable called ""a"" using BN_CTX_get() and checks if ""a"" was successfully initialized and if its size is sufficient to hold the result of the multiplication. If either of these checks fail, the function returns 0. It then initializes several variables and loops through the two input arrays, performing a multiplication operation on each pair of elements and storing the result in ""a"". The multiplication operation is done using the bn_GF2m_mul_2x2() function, which multiplies two."
openssl-101u,O2,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_sqr@0011e9bc.c,"The function takes four parameters: two integers, a BIGNUM pointer, and another integer. It first calculates the number of bits in the BIGNUM and adds 1 to it. It then allocates memory for an array of integers of size equal to this calculated value. If memory allocation fails, it returns 0. If the BIGNUM has a non-zero top value, it iterates over its words and finds the indices of all the set bits. It stores these indices in the allocated array. It then calculates the number of leading zeroes in the array size and shifts it right by 5 bits. If the calculated value is 0, it calls the BN_GF2m_mod_sqr_arr function with the allocated array and the other parameters and returns its result. If the calculated value is non-zero, it sets a specific bit in the value and checks if the result is less than the size of the allocated array. If it is, it calls the BN_GF2m."
openssl-101u,O2,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_sqrt@0011f21c.c,"BN_GF2m_mod_sqrt is a function in the OpenSSL library used to compute the square root of a binary polynomial in GF(2^m) field. It takes four arguments: a BIGNUM pointer for the result, an integer for the polynomial degree, a BIGNUM pointer for the input polynomial, and a BN_CTX pointer for temporary storage. 

The function first calculates the number of bits required to represent the input polynomial and allocates memory accordingly. It then scans the input polynomial to find the positions of its set bits and stores them in the allocated memory. It calculates the number of leading zeroes in the memory block and sets a flag based on the result. If the flag is set, the function computes the square root of the input polynomial using a helper function BN_GF2m_mod_exp_arr. If not, it sets the result to zero and returns. 

Finally, the function frees the allocated memory and returns the result."
openssl-101u,O2,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_GF2m_mod_sqr_arr@0011e65c.c,"The function takes four parameters: an integer, an integer array, an integer, and a BN_CTX object. It initializes a BIGNUM object 'a' and expands its size if necessary. It squares the elements of the array using a precomputed table and stores the result in 'a', sets the 'top' field of 'a' to the number of elements in it, and removes any leading zeros. It then computes the modulo of 'a' with respect to the integer 'param_3' using BN_GF2m_mod_arr() function and stores the result in 'a'. It returns 1 if the modulo operation was successful, otherwise it returns 0."
openssl-101u,O2,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101u_arm_gcc_O2_extraction/bn_GF2m_mul_2x2@001213e0.c,"The function `bn_GF2m_mul_2x2` performs multiplication of two 2x2 matrices over the field GF(2^m). It takes in five unsigned integers as parameters and returns an unsigned long long value. Depending on whether certain hardware features are available or not, the function checks if a certain bit in memory is set to 1 and calls different functions accordingly. It then performs bitwise operations on the results to calculate the final return value."
openssl-101u,O2,arm,BN_kronecker,./data/decomp/openssl-101u_arm_gcc_O2_extraction/BN_kronecker@0011dba4.c,"BN_kronecker is a function that calculates the Kronecker symbol of two BIGNUMs a and b. It initializes two BIGNUM variables, a_00 and a_01, and checks if a_01 is null. If a_01 is not null, it copies the values of a and b into a_00 and a_01, respectively. It then checks if the top value of a_01 is zero, in which case it calculates the Kronecker symbol using a_00 and sets the return value. The Kronecker symbol is a generalization of the Legendre symbol and is used in number theory to determine whether a given integer is a quadratic residue modulo a prime. The algorithm used is described in section 2.4.2 of the Handbook of Applied Cryptography."
openssl-101u,O2,arm,by_dir_entry_free,./data/decomp/openssl-101u_arm_gcc_O2_extraction/by_dir_entry_free@000cd754.c,"The function ""by_dir_entry_free"" frees memory pointed to by a pointer using the ""CRYPTO_free"" function. It also frees memory pointed to by the third element of the array using the ""sk_pop_free"" function, and frees the memory pointed to by the original pointer using ""CRYPTO_free"". The second argument to ""sk_pop_free"" is a pointer to a function ""by_dir_hash_free + 1"", which is presumably a function for freeing a hash table."
openssl-101u,O2,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_arm_gcc_O2_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@00119ecc.c,"The function converts encoded GOST client key exchange parameters from ASN.1 format to an internal binary format using a pointer to an ASN1_VALUE, a double pointer to a uchar, and a long integer. It calls the ASN1_item_d2i() function to decode the ASN.1 data into a C structure, using parameters including a pointer to the output C structure and a pointer to an ASN1_ITEM structure that describes the structure of the ASN.1 data."
openssl-101u,O2,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_arm_gcc_O2_extraction/d2i_GOST_KEY_PARAMS@00119e6c.c,"The function takes in three parameters: a pointer to an ASN1_VALUE object, a pointer to a uchar (unsigned char) object, and a long integer. It then calls the ASN1_item_d2i function with these parameters, as well as a pointer to an ASN1_ITEM object called PTR_GOST_KEY_PARAMS_it_00119e74. This function likely performs the actual decoding of the ASN.1 data in the uchar buffer and populates the ASN1_VALUE object with the decoded values. Finally, the function returns without any explicit return value."
openssl-101u,O2,arm,decode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O2_extraction/decode_gost_algor_params@001188d0.c,"The function decodes GOST algorithm parameters from an X509_ALGOR structure and sets them in an EVP_PKEY structure. It extracts the algorithm parameters from the X509_ALGOR structure, converts them to a GOST_KEY_PARAMS structure, and sets the algorithm type in the EVP_PKEY structure. If the algorithm type is GOST R 34.10-2001, it creates an EC_KEY structure and sets the GOST 2001 parameters."
openssl-101u,O2,arm,DES_xcbc_encrypt,./data/decomp/openssl-101u_arm_gcc_O2_extraction/DES_xcbc_encrypt@0011d0fc.c,"The functions `DES_xcbc_encrypt` and `CBC_mode_DES_encrypt` both use the DES encryption algorithm to encrypt data. 

`DES_xcbc_encrypt` uses the XCBC mode of operation and takes plaintext input, a key schedule, an initialization vector, and two constant blocks as input. It processes the input in blocks of 8 bytes, XORing each block with the previous output block and the constant block `inw`, and then encrypting the result using DES. The resulting ciphertext block is then XORed with the constant block `outw` and stored in the output buffer.

`CBC_mode_DES_encrypt` uses the Cipher Block Chaining (CBC) mode of operation and takes a key, an initialization vector, an input data buffer, an output data buffer, and the length of the input data buffer as input. It performs the DES encryption algorithm on the input data in blocks of 8 bytes, XORing each block with the previous block's encrypted output and then encrypting the result using DES. If the input data buffer is less than or equal to 8 bytes, it performs a single DES encryption operation on the input data using the initialization vector and stores the result in the output data buffer. It also updates the initialization vector with the result of the encryption operation."
openssl-101u,O2,arm,dgram_ctrl,./data/decomp/openssl-101u_arm_gcc_O2_extraction/dgram_ctrl@000a2408.c,"The two functions take in various parameters and perform different operations depending on the values of certain variables. The first function, `dgram_ctrl`, initializes local variables and performs operations such as setting or getting socket options and manipulating variables. The second function checks if the first byte of the source buffer is equal to 0x5a and performs operations such as copying bytes and shutting down socket connections. Both functions have conditional statements that determine their behavior."
openssl-101u,O2,arm,dlfcn_bind_func,./data/decomp/openssl-101u_arm_gcc_O2_extraction/dlfcn_bind_func@0012070c.c,"The function `dlfcn_bind_func` takes two integer parameters `param_1` and `param_2`. It first checks if both parameters are non-zero. If either of them is zero, it logs an error and returns `NULL`. If both parameters are non-zero, it initializes a `void` pointer `pvVar4` to `NULL`. It then checks the number of elements in a stack pointed to by the second integer parameter `param_1`. If the stack is empty, it logs an error and returns `NULL`. If the stack is not empty, it retrieves the last element from the stack and assigns it to `pvVar4`. If `pvVar4` is `NULL`, it logs an error and returns `NULL`. If `pvVar4` is not `NULL`, it attempts to find a symbol with the name specified in the second integer parameter `param_2` using the `dlsym` function. If the symbol is not found, it returns `NULL`."
openssl-101u,O2,arm,dlfcn_bind_var,./data/decomp/openssl-101u_arm_gcc_O2_extraction/dlfcn_bind_var@001207e0.c,"The function takes in two parameters, param_1 and param_2. If both parameters are non-zero, it attempts to bind a variable using the dlsym function. First, it checks if the stack pointed to by param_1 has at least one element. If not, it sets an error code. Otherwise, it retrieves the last element of the stack (sk_value) and attempts to bind the variable using dlsym, with the name specified in param_2. If dlsym fails to find the variable, it sets an error code and adds the symbol name to the error data. If either param_1 or param_2 is zero, it sets an error code and returns null. The function returns the pointer to the bound variable, or null if it was unable to bind the variable."
openssl-101u,O2,arm,dlfcn_globallookup,./data/decomp/openssl-101u_arm_gcc_O2_extraction/dlfcn_globallookup@00120520.c,"The function uses the dlfcn library to dynamically load a shared object file and look up a symbol within it. It takes four parameters but only uses the first and third parameters. It calls the dlopen function to open a shared object file with the first parameter set to 0, meaning the current executable file is searched for the shared object file, and the second parameter set to 1, meaning the shared object file is loaded into the address space of the calling process. If dlopen is successful, it calls dlsym to look up the symbol specified by the first parameter. If dlsym succeeds, it returns a pointer to the symbol. Finally, the function calls dlclose to close the shared object file and returns the pointer to the symbol if it was found, or 0 if it was not found."
openssl-101u,O2,arm,doapr_outch.constprop.0,./data/decomp/openssl-101u_arm_gcc_O2_extraction/doapr_outch.constprop.0@0009f7cc.c,"The function takes in four parameters: two void pointers, and two uint pointers. It returns an undefined value. If param_2 is NULL, the function sets uVar2 to the value pointed to by param_3 and uVar3 to the value pointed to by param_4. Otherwise, it sets uVar2 to the value pointed to by param_3, uVar3 to the value pointed to by param_4, and checks if uVar2 is equal to uVar3. If uVar2 is equal to uVar3 and uVar2 is greater than 0x7ffffbff, the function returns 0. If param_2 is not NULL and uVar2 is equal to uVar3, the function checks if the value pointed to by param_2 is NULL. If it is, it allocates memory of size uVar2 + 0x400 using CRYPTO_malloc and assigns it to pvVar1. It then assigns pvVar1."
openssl-101u,O2,arm,dtls1_link_min_mtu,./data/decomp/openssl-101u_arm_gcc_O2_extraction/dtls1_link_min_mtu@0005d398.c,"The function dtls1_link_min_mtu returns a hexadecimal value of 0x100, which is equivalent to 256 in decimal, and is likely used as the minimum MTU size for DTLS links."
openssl-101u,O2,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_mont_field_encode@0011f920.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It returns an integer. The function first retrieves a BN_MONT_CTX pointer from the integer parameter. If the BN_MONT_CTX pointer is not NULL, the function performs a Montgomery encoding on the second BIGNUM parameter using the third BIGNUM parameter and the BN_MONT_CTX pointer. The result is stored in the second BIGNUM parameter. If the BN_MONT_CTX pointer is NULL, the function generates an error message and returns 0."
openssl-101u,O2,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_mont_field_sqr@0011f8e8.c,"The function takes four parameters - an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. If the value stored at the memory address pointed to by the integer plus 0xa0 is not equal to NULL, it performs a modular multiplication of the second and third parameters using the Montgomery multiplication algorithm and the BN_MONT_CTX structure pointed to by the aforementioned memory address. The result is stored in the second parameter. If the value stored at the memory address pointed to by the integer plus 0xa0 is equal to NULL, it logs an error using the ERR_put_error function and returns 0."
openssl-101u,O2,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_mont_group_init@0011f6c4.c,"The function initializes a Montgomery elliptic curve group over a prime field by calling ec_GFp_simple_group_init() to initialize the underlying simple elliptic curve group, setting two variables in the Montgomery group structure to zero for storing precomputed values for Montgomery point multiplication, and returning the initialized group."
openssl-101u,O2,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0012183c.c,"The function takes in six parameters: an integer pointer, an integer, and four BIGNUM pointers. It returns a BIGNUM pointer. 

If a certain field in the structure pointed to by the integer pointer is equal to zero, the function copies the second and third BIGNUM pointers to the first and fourth BIGNUM pointers, respectively. If the fifth BIGNUM pointer is not null, it also copies it to the fifth BIGNUM pointer. If any of the copy operations fail, the function returns null. Otherwise, it returns a pointer to a BIGNUM with value 1.

If the field in the structure pointed to by the integer pointer is not zero, the function creates a new BN_CTX (a context for big number operations) and assigns it to the sixth BIGNUM pointer. If the sixth BIGNUM pointer is null, the function returns null. The function then calls a function pointer stored in the structure pointed to by."
openssl-101u,O2,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_group_check_discriminant@0012194c.c,"The function checks the discriminant of a given elliptic curve group by initializing a BN_CTX object for temporary storage of large numbers. It retrieves the parameters of the elliptic curve group, namely the coefficients a and a_00, and computes the discriminant using these parameters. The discriminant is computed by first computing r = a^2 mod p, where p is the prime modulus of the field over which the elliptic curve is defined. Then, r_00 is computed as 4a_00 mod p. The function then computes a = r + r_00, and the discriminant as D = -16(4a^3 + 27a_00^2) mod p. If the discriminant is non-zero, the function returns 1, indicating that the given elliptic curve group is valid. Otherwise, it returns 0. The function also checks for errors and frees the BN_CTX object before returning."
openssl-101u,O2,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_group_clear_finish@001215f4.c,"The function takes an integer parameter that represents a pointer to a structure for a simple elliptic curve group over a finite field. It clears and frees the memory allocated for three BIGNUMs that are part of this structure: the order of the group, the cofactor of the group, and the generator point of the group. The function then returns."
openssl-101u,O2,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_group_copy@00121fc8.c,"The function takes two integer parameters and returns a pointer to a BIGNUM structure. It is a copy function for a simple elliptic curve group in GFp. The function copies the values of three BIGNUM structures at specific offsets from the first parameter to the same offsets in the returned BIGNUM structure. If all three BN_copy operations are successful, the function sets a value at a specific offset in the returned BIGNUM structure to the same value at the same offset in the second parameter and returns a pointer to the returned BIGNUM structure. If any of the BN_copy operations fail, the function returns a null pointer."
openssl-101u,O2,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_group_get_degree@00121634.c,The function takes an integer parameter `param_1` as input and retrieves a BIGNUM object from memory at an offset of 0x48 from the starting address of `param_1`. It calculates the number of bits in the BIGNUM object using the `BN_num_bits` function and returns the result. This function is likely used to determine the degree of the elliptic curve group represented by the BIGNUM object.
openssl-101u,O2,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_group_set_curve@0012203c.c,"The function `ec_GFp_simple_group_set_curve` sets the parameters of an elliptic curve group in GF(p) representation. It takes four input parameters: `param_1`, `param_2`, `param_3`, and `param_4`, which are pointers to integers and BIGNUMs. It also takes a BN_CTX pointer `param_5`, which is used for temporary storage during computations. The function first checks if the input parameters are valid. It checks if the bit length of `param_2` is greater than or equal to 3, if `param_2` has at least one word, and if `param_2` is not negative. If any of these conditions are not met, the function returns 0. If the input parameters are valid, the function initializes a BN_CTX if one is not provided. It then starts a new BN_CTX and gets a new BIGNUM `r` from the context. The function then copies."
openssl-101u,O2,arm,ec_GFp_simple_invert,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_invert@00122730.c,"This function takes in an EC_GROUP and an EC_POINT as parameters to calculate the inverse of a point in the given elliptic curve group. It checks if the EC_POINT is at infinity or not and if the y-coordinate of the point is not zero, it performs a subtraction operation using the BN_usub function on the y-coordinate of the point and the order of the group. If the point is at infinity or the y-coordinate is zero, it returns 1."
openssl-101u,O2,arm,EC_GFp_simple_method,./data/decomp/openssl-101u_arm_gcc_O2_extraction/EC_GFp_simple_method@00122d2c.c,The EC_GFp_simple_method function returns a pointer to an undefined EC_METHOD structure without taking any parameters. Its behavior is unclear from the decompiled code.
openssl-101u,O2,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_point_copy@00122004.c,"The function is a copy function for a point on an elliptic curve over a finite field. It takes two parameters, both integers, which are pointers to the memory locations of the two points to be copied. The function returns a pointer to a BIGNUM structure, which contains the copied point. The function first uses the BN_copy function from OpenSSL to copy the x-coordinate, y-coordinate, and z-coordinate of the source point to the destination point. If any of these copy operations fail, the function returns a null pointer. If all three copy operations succeed, the function sets the flag for the destination point to be the same as the flag for the source point and returns a pointer to the destination point."
openssl-101u,O2,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_point_finish@001215d4.c,"The function takes an integer parameter, likely a pointer to a structure representing a point on an elliptic curve. It frees three BIGNUM objects within the structure, likely used to store the x, y, and z coordinates of the point. The function is a cleanup function to free memory allocated for a point on an elliptic curve after it is no longer needed."
openssl-101u,O2,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_point_get_affine_coordinates@00121ab4.c,"The function takes an integer pointer, an EC_POINT pointer, and three BIGNUM pointers, as well as a BN_CTX pointer, and returns a BIGNUM pointer. It checks if the given EC_POINT is at infinity, and if it is, it returns NULL. If a BN_CTX pointer is not provided, the function creates a new one. It initializes several BIGNUM pointers using BN_CTX_get(). If the point is not at infinity, the function computes the affine coordinates of the point and stores them in the provided BIGNUM pointers. If any of the pointers are NULL, the function does not compute the corresponding coordinate. The computation involves computing the inverse of a value, which is then used to compute two other values. The details of the computation depend on the specific elliptic curve being used, which is determined by the integer pointer passed to the function. If the computation succeeds, the function returns a pointer to a BIGNUM set to 1."
openssl-101u,O2,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O2_extraction/ec_GFp_simple_point_set_affine_coordinates@0012215c.c,"The function takes an EC_GROUP object, an EC_POINT object, two BIGNUM objects for x and y coordinates, and a BN_CTX object. It sets the point's coordinates in J-projective coordinates using EC_POINT_set_Jprojective_coordinates_GFp and returns the result if both x and y coordinates are not NULL. If either x or y coordinate is NULL, the function generates an error using ERR_put_error and returns 0."
openssl-101u,O2,arm,encode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O2_extraction/encode_gost_algor_params@00119098.c,"The function encodes the parameters of the GOST algorithm used in the key by taking an EVP_PKEY structure as input. It creates a new ASN1_STRING structure and a GOST_KEY_PARAMS structure, determines the type of key being used, and extracts the curve name or parameter set. It then creates ASN1_OBJECT structures for the curve name and the GOST algorithm identifier, and assigns them to the GOST_KEY_PARAMS structure. The GOST_KEY_PARAMS structure is encoded into the ASN1_STRING structure using the i2d_GOST_KEY_PARAMS function, and if successful, the type of the ASN1_STRING is set to 0x10. If any errors occur during the encoding process, the function returns NULL. Finally, the GOST_KEY_PARAMS structure is freed."
openssl-101u,O2,arm,get_gost_engine_param,./data/decomp/openssl-101u_arm_gcc_O2_extraction/get_gost_engine_param@0011ae64.c,"The function takes an integer parameter called param_1 and returns a pointer to a character string. If param_1 is not equal to 0, the function returns a null pointer. If the global variable gost_params is equal to a null pointer, the function attempts to get the value of the environment variable CRYPT_PARAMS using the getenv() function. If the value of CRYPT_PARAMS is a null pointer, the function returns a null pointer. If the value of CRYPT_PARAMS is not null, the function uses the BUF_strdup() function to allocate memory for a copy of the string and assigns it to gost_params. Finally, the function returns the value of gost_params."
openssl-101u,O2,arm,gost2001_param_encode,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost2001_param_encode@00118c28.c,"The function takes an EVP_PKEY object as input and extracts the EC_KEY object from it, which represents an elliptic curve key pair. It then retrieves the EC_GROUP object associated with the EC_KEY object and gets the curve name as an integer. The curve name is converted to an ASN1_OBJECT structure using the OBJ_nid2obj() function. Finally, the function encodes the ASN1_OBJECT structure into a binary format using the i2d_ASN1_OBJECT() function and stores it in the param_2 pointer. The encoded binary data represents the elliptic curve parameters used by the key pair."
openssl-101u,O2,arm,gost_cipher_cleanup,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost_cipher_cleanup@0011a024.c,The function takes an integer parameter and accesses a memory location at an offset of 0x60. It adds 0xc to the value at that memory location and passes it as an argument to the gost_destroy function. This function likely cleans up resources associated with a GOST cipher. The function then sets the value at an offset of 0x54 in the same memory location to 0 and returns 1. The purpose of this value and why it is being set to 0 is unclear.
openssl-101u,O2,arm,gost_cipher_ctl,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost_cipher_ctl@0011a46c.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function calls the `RAND_bytes` function to generate random bytes and stores them in the memory pointed to by `param_4`. If the `RAND_bytes` call is successful, the function returns 1. Otherwise, it calls the `ERR_GOST_error` function with the error code 0x6f7b and returns -1. If `param_2` is equal to 7, the function sets the value at the memory location pointed to by `param_4` to 0x32a (810 in decimal) and returns 1. If `param_4` is null, the function returns 0. If `param_2` is neither 6 nor 7, the function calls the `ERR_GOST_error`."
openssl-101u,O2,arm,gost_cipher_do_cnt,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost_cipher_do_cnt@0011a13c.c,"The function `gost_cipher_do_cnt` is a part of the GOST block cipher algorithm implementation. It takes four parameters - an integer, two pointers to unsigned integers, and a pointer to a byte. The function first checks if the pointer to the byte is null, and if it is, it sets a pointer to a default value. It then checks if the length of the byte array is less than or equal to 7, and if it is not, it sets the pointer to the byte array to the first byte after the first 8 bytes. If the byte array length is less than or equal to 7, it sets the pointer to the byte array to null. Next, the function checks if the second pointer to the unsigned integer is less than or equal to the fourth byte of the key, and if it is, it sets a boolean flag. It then checks if the fourth byte of the key is equal to the second pointer to the unsigned integer, and if it is.

The function takes in four parameters: param_1, param_2, param_3, and param_4. It first initializes some variables, including uVar10, which is set to 1. Then it enters a loop that iterates from 0 to the value of the fourth parameter (param_4). Within the loop, it first checks if the value of pbVar4 + 2 (a pointer to a byte) is less than the value of param_4. If it is, it performs some operations on the values at certain memory addresses and stores the result in a variable called iVar7. Next, it checks if the value of iVar1 is less than the value of param_4. If it is, it performs some operations on the values at certain memory addresses and stores the result in a variable called iVar2. After the loop is finished, it sets the value of a variable at a certain memory address (param_1 +)."
openssl-101u,O2,arm,gost_cipher_init,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost_cipher_init@0011acb0.c,"The `gost_cipher_init` function initializes the `EVP_CIPHER_CTX` context for the GOST cipher. It takes three parameters: `param_1` is a pointer to the context, `param_2` is the key length in bytes, and `param_3` is the initialization vector (IV). The function first checks if the `app_data` field of the context is null, which indicates that the context has not been initialized yet. If `app_data` is null, the function retrieves the GOST engine parameter, which is a string that specifies the GOST cipher and hash function to use. If the parameter is not set or is an empty string, the function uses the default GOST cipher parameters. Otherwise, it converts the parameter string to a numeric identifier using the `OBJ_txt2nid` function and checks if the identifier matches a known GOST cipher. If a matching cipher is found, the function initializes the cipher parameters and the key using the `g`."
openssl-101u,O2,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O2_extraction/GOST_CIPHER_PARAMS_new@00119eb4.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using ASN1_item_new() and returns void. It is defined by the ASN1_ITEM pointer PTR_GOST_CIPHER_PARAMS_it_00119ebc and does not take any arguments.
openssl-101u,O2,arm,gost_imit_final,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost_imit_final@0011aacc.c,"This function is the final step in the GOST 28147-89 encryption algorithm with MAC generation. It takes two parameters: param_1 is a pointer to a structure containing the encryption key, plaintext, and MAC; param_2 is a pointer to a buffer where the MAC will be stored. The function checks if the MAC key is valid and if the plaintext is shorter than 8 bytes, it is padded with zeros to a length of 8 bytes. If the MAC key is shorter than 8 bytes, the key is padded with zeros to a length of 8 bytes. If the MAC key is valid and the plaintext is longer than 8 bytes, the function performs key meshing and MAC generation. The key meshing step is only performed if the encryption key is a Cryptopro key and the plaintext is longer. If the MAC key is not valid, an error is thrown and the function exits."
openssl-101u,O2,arm,gost_imit_init_cpa,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost_imit_init_cpa@0011a418.c,"The function takes in a memory address as its parameter and initializes a variable to the value stored at the memory address plus 0xc. It then sets a series of bytes to 0 at various offsets starting at 0x1020 and sets two 4-byte values to 0 at specific memory addresses. Finally, it calls the gost_init function with several parameters, including the value stored at the initialized variable, a constant value representing a specific cryptographic parameter set, and a pointer to a specific memory address. The function returns 1."
openssl-101u,O2,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O2_extraction/GOST_KEY_PARAMS_new@00119e84.c,The function creates a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new function. The structure is defined in the PTR_GOST_KEY_PARAMS_it_00119e8c item template. It does not return any value.
openssl-101u,O2,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_arm_gcc_O2_extraction/GOST_KEY_TRANSPORT_free@00119e00.c,The function frees memory allocated to an ASN1_VALUE pointer using ASN1_item_free and takes an ASN1_ITEM structure pointer. It does not return a value.
openssl-101u,O2,arm,gost_param_free,./data/decomp/openssl-101u_arm_gcc_O2_extraction/gost_param_free@0011ae0c.c,"The ""gost_param_free"" function frees memory allocated for GOST parameters by checking if the ""gost_params"" variable is not equal to NULL (0x0) and using the ""CRYPTO_free"" function to free the memory. The function then sets ""gost_params"" to NULL (0x0) and returns without any value."
openssl-101u,O2,arm,hash_step,./data/decomp/openssl-101u_arm_gcc_O2_extraction/hash_step@0011aed8.c,"The first function takes in three parameters, checks if two pointers are aligned on 4-byte boundaries, initializes local variables, calls another function, and performs operations on two arrays. 

The second function takes in three pointers, initializes local variables, calls the ""gost_enc_with_key"" function twice, performs bitwise operations on the encrypted output, and returns the encrypted output.

The third function is a decryption function that takes in a key, IV, and input data block, expands the key, performs 32 rounds of encryption using the GOST block cipher algorithm, and performs additional operations to convert the input and output into 32-bit words and handle endianness issues."
openssl-101u,O2,arm,hwcrhk_init,./data/decomp/openssl-101u_arm_gcc_O2_extraction/hwcrhk_init@000f20a4.c,"The function initializes the HWCryptoHook library by loading its dynamic shared object (DSO) file and binding its functions. It creates a new RSA key handle index if one does not already exist. If the library fails to load or any of its required functions fail to bind, it sets an error code and returns an error. If the library and all its functions load successfully, it sets global function pointers to the loaded functions and returns success. Finally, it frees the DSO and resets all global function pointers to null."
openssl-101u,O2,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_arm_gcc_O2_extraction/i2d_GOST_KEY_AGREEMENT_INFO@00119e48.c,"The i2d_GOST_KEY_AGREEMENT_INFO function encodes an ASN1_VALUE structure into a binary format using the ASN1_ITEM structure PTR_GOST_KEY_AGREEMENT_INFO_it_00119e50. The encoded data is stored in a uchar array, which is passed to the function as a double pointer. The function returns without any value."
openssl-101u,O2,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_arm_gcc_O2_extraction/i2d_GOST_KEY_TRANSPORT@00119de8.c,The i2d_GOST_KEY_TRANSPORT function takes two parameters: param_1 and param_2. It calls the ASN1_item_i2d function with three parameters to serialize the GOST_KEY_TRANSPORT structure and write the bytes to the memory location pointed to by param_2. The function returns without a value.
openssl-101u,O2,arm,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_arm_gcc_O2_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@0008653c.c,"The function takes a BIGNUM pointer, an integer, an array of unsigned integers, and two unsigned integers as input. It expands the BIGNUM if necessary and performs a bitwise operation on the input array based on the values of the two unsigned integers. The resulting value is stored in the BIGNUM, and any leading zero values are removed. The function returns 1 if successful. If the second unsigned integer is less than 4, the function performs a loop that iterates over each word in the BIGNUM (up to the input integer) and performs a bitwise OR operation on the corresponding words in the input array."
openssl-101u,O2,arm,mul_1x1_ialu,./data/decomp/openssl-101u_arm_gcc_O2_extraction/mul_1x1_ialu@001212c0.c,"The function ""mul_1x1_ialu"" is empty and does not perform any operations or calculations related to multiplication or any other task."
openssl-101u,O2,arm,param_copy_gost94,./data/decomp/openssl-101u_arm_gcc_O2_extraction/param_copy_gost94@00118de8.c,"This function copies GOST 94 key parameters from one EVP_PKEY object to another. It retrieves the DSA key from the destination object and the parameters from the source object. It checks if the base IDs of the two objects are the same, and if not, an error is thrown. If the base IDs are the same, the function copies the parameters from the source object to the destination object. It checks if the source object has valid parameters and if the destination object has a DSA key associated with it. If the destination object does not have a DSA key, a new one is created and assigned."
openssl-101u,O2,arm,param_print_gost01,./data/decomp/openssl-101u_arm_gcc_O2_extraction/param_print_gost01@001199e4.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer. It retrieves the curve name of the EC_GROUP object associated with the EVP_PKEY object and prints it to the specified BIO object with the specified indentation. The function returns the value 1."
openssl-101u,O2,arm,param_print_gost94,./data/decomp/openssl-101u_arm_gcc_O2_extraction/param_print_gost94@00119970.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It initializes an array of BIGNUMs called local_1c and loops through an array of integers called R3410_paramset, which contains the values of different parameter sets for the GOST 94 algorithm. For each integer value in the array, it converts a corresponding string value to a BIGNUM and compares it to the BIGNUM value from the EVP_PKEY object. If the two values match, it sets the integer variable iVar4 to the value of the current integer in the loop and breaks out of the loop. If the loop completes without finding a matching value, it sets iVar4 to 0 and frees the local_1c array. It then prints out the name of the parameter set using the OBJ_nid2ln function and returns 1."
openssl-101u,O2,arm,pkey_ctrl_gost,./data/decomp/openssl-101u_arm_gcc_O2_extraction/pkey_ctrl_gost@00119398.c,"The function `pkey_ctrl_gost` takes in four parameters: an `EVP_PKEY` object, an integer `param_2`, a `X509_ALGOR` object `param_3`, and a `PKCS7_SIGNER_INFO` object `param_4`. The function performs different actions based on the value of `param_2`. If `param_2` is 1, 2, 5, or 7, the function sets the `local_1c` array to `param_3` or a new `X509_ALGOR` object, depending on the value of `param_2`. If `param_2` is 3, the function sets the `version` field of `param_4` to a new `ASN1_INTEGER` object with the value `0x329`. If `param_2` is 1 or 5, the function gets the algorithm information for the."
openssl-101u,O2,arm,priv_encode_gost,./data/decomp/openssl-101u_arm_gcc_O2_extraction/priv_encode_gost@00119560.c,"The function takes in two parameters, a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure. It first gets the base ID of the EVP_PKEY and converts it to an ASN1_OBJECT. It then calls the encode_gost_algor_params function to encode the algorithm parameters and stores the result in pval. If the base ID is for an EC key (0x32b), it gets the private key from the EVP_PKEY and sets it to bn. If the base ID is for a GOST R 34.10-2012 key (0x32c), it gets the second element of the BN array from the EVP_PKEY and sets it to bn. It then converts the private key BN to an ASN1_INTEGER and stores it in a. The ASN1_INTEGER is then serialized and stored in local_1c. Finally, the PKCS8_pkey_set0 function is called to set the private key information in the PKCS8."
openssl-101u,O2,arm,pub_encode_gost94,./data/decomp/openssl-101u_arm_gcc_O2_extraction/pub_encode_gost94@0011948c.c,"The function takes in a X509_PUBKEY object and an EVP_PKEY object as input parameters. It first gets the algorithm object corresponding to the EVP_PKEY object and saves the parameters of the EVP_PKEY object. It then calculates the number of bits in the public key and allocates memory to store it. It converts the public key to binary format and reverses the byte order. It then creates an ASN1_OCTET_STRING object to store the public key and encodes it. Finally, it sets the algorithm parameters and the public key in the X509_PUBKEY object and returns 0 if there was an error or 1 otherwise."
openssl-101u,O2,arm,pub_print_gost94,./data/decomp/openssl-101u_arm_gcc_O2_extraction/pub_print_gost94@00119a20.c,"This function takes a BIO object, an EVP_PKEY object, and an integer as parameters. It extracts the public key from the EVP_PKEY object and prints it to the BIO object. It then compares the parameters of the public key to a list of predefined parameter sets for the GOST R 34.10-94 algorithm. If it finds a match, it prints the name of the parameter set to the BIO object and returns 1. If no match is found, it returns 0 without printing anything."
openssl-101u,O2,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O2_extraction/RSA_padding_add_PKCS1_PSS@00120050.c,"The function takes an RSA key, a message hash, a hash function, and a salt length as input. It pads the message using the PKCS1-PSS padding scheme and returns the resulting padded message. It calculates the hash value size and RSA key size, determines the number of padding bits needed, and adds padding bits if necessary. The function generates a random salt value, calculates the hash of the message and salt, applies the PKCS1-MGF1 function to the salt to generate a mask, XORs it with the hash value, concatenates the result with the salt and additional padding bits to form the final padded message. If the salt length is -1, the default salt length is used. If it is -2, the maximum possible salt length is calculated given the RSA key size and hash value size. If any errors occur, they are handled appropriately."
openssl-101u,O2,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O2_extraction/RSA_verify_PKCS1_PSS@0011f9dc.c,"The function RSA_verify_PKCS1_PSS verifies a signature using the RSA algorithm with the PKCS1-PSS padding scheme. It takes in the RSA key, message hash, hash function used, encoded signature, and signature length. The function initializes an EVP_MD_CTX context, checks the validity of the signature length, calculates the RSA modulus, removes the first byte of the encoded signature if necessary, and checks if the signature length plus hash length plus one is less than the RSA key size. If this condition is true, it extracts the mask from the signature, applies the PKCS1-MGF1 function to generate a random mask, XORs the mask with the rest of the signature to recover the original message digest, and continues with the verification process."
openssl-101u,O2,arm,sha_block_data_order,./data/decomp/openssl-101u_arm_gcc_O2_extraction/sha_block_data_order@0011bcf0.c,"These function summaries describe the implementation of the SHA-1 hash algorithm. The algorithm processes input data in blocks of 64 bytes, using a series of logical and arithmetic operations to transform the data into a 160-bit hash value. The function initializes variables and loops through the data, performing bitwise operations and updating the variables. At the end of the loop, the final hash value is stored in a buffer. Another function reads input values from the user and stores them in an array until the user enters a value of 0, but the purpose of the function is unclear without additional context."
openssl-101u,O2,arm,SHA_Final,./data/decomp/openssl-101u_arm_gcc_O2_extraction/SHA_Final@0011cfd8.c,"The SHA_Final function is the final step in the SHA-1 hashing algorithm. It takes in a pointer to a buffer (md) where the resulting hash will be stored, and a pointer to a SHA_CTX structure (c) which contains the intermediate hash state. The function calculates the number of bytes in the last block of data using the ""num"" field of the SHA_CTX structure. It then appends a 1 bit followed by enough 0 bits to fill the last block. If the last block is not big enough to hold the 1 bit and padding, the function fills the last block with 0 bits and processes it using the sha_block_data_order function. The function then appends the total number of bits processed in the message to the last block and processes it using sha_block_data_order. Finally, it stores the resulting hash in the md buffer and cleans up the SHA_CTX structure by setting the ""num"" field to 0 and clearing the data buffer using the OPEN."
openssl-101u,O2,arm,srp_verify_server_param,./data/decomp/openssl-101u_arm_gcc_O2_extraction/srp_verify_server_param@00068fc8.c,"The `srp_verify_server_param` function takes four parameters and compares two BIGNUM values using the `BN_ucmp` function. If the result is less than -1, it sets `*param_2` to `0x2f` and returns 0. It also compares the number of bits in `*(BIGNUM **)(param_1 + 0x1a8)` with the value pointed to by `*(int *)(param_1 + 0x1cc)` and calls either `SRP_check_known_gN_param` or a function pointer pointed to depending on the result."
openssl-101u,O2,arm,SSLv23_method,./data/decomp/openssl-101u_arm_gcc_O2_extraction/SSLv23_method@000512ac.c,"The SSLv23_method function returns a pointer to an SSL_METHOD structure, which defines the SSLv23 protocol method. This is likely part of a larger SSL/TLS library used for secure communication over a network."
openssl-101u,O2,arm,start_hash,./data/decomp/openssl-101u_arm_gcc_O2_extraction/start_hash@0011b880.c,"The function takes a pointer to an array of 4-byte integers and checks the value of the third integer. If not equal to zero, it initializes the first four integers and sets the next 32 bytes to zero before returning the value of the third integer."
openssl-101u,O2,arm,surewarehk_finish,./data/decomp/openssl-101u_arm_gcc_O2_extraction/surewarehk_finish@000f2ff4.c,"The function surewarehk_finish() cleans up resources used by the SureWare hardware accelerator library by checking if the library has been loaded, calling the finish function, freeing the dynamic library object, freeing the logstream object if it is not null, setting all function pointers to null, and setting the surewarehk_dso pointer to null. It returns 1 if successful, and 0 if there is an error."
openssl-101u,O2,arm,sv_body,./data/decomp/openssl-101u_arm_gcc_O2_extraction/sv_body@0002686c.c,"The function `sv_body` handles incoming SSL connections in the s_server program. It allocates a buffer of size 0x4000 and creates a new SSL object. It sets up the SSL object to use the given socket for I/O and enters a loop to check for incoming data on the socket. It also handles SSL/TLS connection with the client by reading and writing data using the SSL/TLS protocol. If the connection is not established, it calls `init_ssl_connection` to establish the connection. If there is a need to renegotiate the SSL/TLS connection, the function calls `SSL_renegotiate` and `SSL_do_handshake` to perform the renegotiation. The function also handles several commands that can be sent by the client, such as ""q"" to quit the connection and ""B"" to initiate a heartbeat. If the `s_quiet` flag is set, it does not print any output."
openssl-101u,O2,arm,TLSv1_method,./data/decomp/openssl-101u_arm_gcc_O2_extraction/TLSv1_method@000525b8.c,"The TLSv1_method function returns a pointer to an SSL_METHOD data structure, which is stored at a specific memory location. The calling convention used by this function is unknown."
openssl-101u,O2,arm,__aeabi_idivmod,./data/decomp/openssl-101u_arm_gcc_O2_extraction/__aeabi_idivmod@00123244.c,"The function takes two integer parameters, param_1 and param_2. If param_2 is not zero, it calls the _divsi3_skip_div0_test() function and returns. If param_2 is zero, it modifies param_1 based on whether it is less than or greater than zero and calls the __aeabi_idiv0() function with the modified param_1 value."
openssl-101u,O2,arm,__libc_csu_init,./data/decomp/openssl-101u_arm_gcc_O2_extraction/__libc_csu_init@00123954.c,The function initializes the C runtime startup code by initializing a pointer to a function and calculating an integer value. It then loops through each function pointer and calls the function with parameters before returning.
openssl-101u,O2,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101u_arm_gcc_O2_extraction/__sha256_block_data_order_from_thumb@001239b8.c,"The functions all implement the SHA-256 hashing algorithm to process input data and produce a 256-bit hash value as output. They use various bitwise operations and constants to perform the hashing, and update variables and arrays as they process the input data. The functions take in different input parameters, including pointers to arrays of integers and the length of the message in bytes. They also use different local variables and perform different operations on the input data."
openssl-101u,O2,arm,__udivdi3,./data/decomp/openssl-101u_arm_gcc_O2_extraction/__udivdi3@00123658.c,"The function takes in four parameters: two 32-bit integers (param_1 and param_2) and two 64-bit integers (param_3 and param_4). It returns a 64-bit integer. 

If either param_3 or param_4 is zero, it returns zero. 

If param_2 is greater than or equal to 32, the function performs a series of calculations using the parameters and returns the result. 

If param_2 is less than 32 and either param_1 or param_3 is zero, it returns zero. 

If param_4 is less than param_2 and param_3 is less than param_1, it returns either 1 or param_2 (depending on the condition). 

If the fourth parameter is zero, the function performs a long division algorithm to calculate the quotient. It does this by shifting the third parameter to the left until it is greater than or equal to the second parameter. It then divides the shifted third parameter by its most significant 16 bits and multiplies the quotient by the original third parameter's least significant 16 bits. It subtracts this product from the shifted second and first parameters and repeats the process until the shifted third parameter is less than the second parameter. It then divides the result by the most significant 16 bits of the original third parameter and multiplies the quotient by the original third parameter's least significant 16 bits to get the final remainder. Finally, it combines the quotient and remainder to return the result."
openssl-101u,O2,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101u_arm_gcc_O2_extraction/___armv7_tick_from_thumb@001239c0.c,"The function is a tick handler for ARMv7 architecture that takes an integer and a pointer to an array of 32-bit integers. It retrieves a value from a coprocessor register and performs a VectorRoundHalvingAdd operation on two 64-bit floating point values. It then enters a loop that checks for exclusive access to a memory location and updates a pointer to that location. If the pointer is greater than 6, it jumps to a label. If the pointer is less than or equal to 6, the function enters a nested loop that writes zeros to memory locations pointed to by the array until the pointer reaches zero. After the nested loop completes, the function checks if a bit in the link register is set and performs another VectorRoundHalvingAdd operation. It then checks if another bit in the link register is set and performs another VectorRoundHalvingAdd."
openssl-101u,O3,arm,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_arm_gcc_O3_extraction/asn1_bio_callback_ctrl@00120dd0.c,"The `asn1_bio_callback_ctrl` function takes three parameters: `param_1`, `param_2`, and `param_3`. It checks if a pointer to a BIO object is not NULL by verifying the value stored at the memory address pointed to by `param_1 + 0x24`. If it is not NULL, the function calls `BIO_callback_ctrl` with the parameters `*(BIO **)(param_1 + 0x24)`, `param_2`, and `param_3`. If the value stored at the memory address pointed to by `param_1 + 0x24` is NULL, the function simply returns."
openssl-101u,O3,arm,asn1_bio_ctrl,./data/decomp/openssl-101u_arm_gcc_O3_extraction/asn1_bio_ctrl@00120e04.c,"The `asn1_bio_ctrl` function takes in a `BIO` structure pointer, an integer, a long integer, and a pointer to an integer. It checks if the `ptr` member of the `BIO` structure is NULL and returns 0 if it is. If the integer parameter is equal to 0x97, the function sets specific elements of the `ptr` array and returns 1. If the integer parameter is greater than 0x97, the function checks if it is equal to 0x99. If it is, the function sets a specific element of the `ptr` array and returns 1. If the integer parameter is less than 0, the function does not perform any action."
openssl-101u,O3,arm,asn1_bio_free,./data/decomp/openssl-101u_arm_gcc_O3_extraction/asn1_bio_free@00120ddc.c,"The function frees memory allocated to a BIO object by checking if the pointer to the BIO object is not null, then checking if the pointer to the data buffer inside the BIO object is not null. If both are not null, it frees the data buffer and the memory allocated to the BIO object. It sets relevant pointers to null and returns a boolean value indicating the success of the operation."
openssl-101u,O3,arm,asn1_bio_write,./data/decomp/openssl-101u_arm_gcc_O3_extraction/asn1_bio_write@00120fac.c,"The function takes in a BIO object, a data buffer, and a length. It writes the data to the BIO object by calling the appropriate method based on the current state of the BIO object. If the BIO object has no next_bio or ptr, or if the data buffer is NULL, the function returns NULL. Otherwise, it proceeds to switch on the current method of the BIO object. If the method is NULL, the function calls the function pointer stored in the ptr field of the BIO object to write the data to the BIO object. If the write operation fails, the function returns NULL. If the write operation succeeds, the function sets the method to 1 or 2 depending on whether there is more data to write. If the method is 1, the function writes the data to the next_bio in chunks until all the data has been written or an error occurs. If the write operation fails, the function returns NULL."
openssl-101u,O3,arm,BIO_asn1_get_suffix,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BIO_asn1_get_suffix@00121228.c,"The function BIO_asn1_get_suffix takes a BIO pointer, a pointer to a pointer to an undefined type (psuffix), and a pointer to a pointer to an undefined type (psuffix_free) as parameters. The function calls the BIO_ctrl function on the BIO pointer with the control code 0x98 and a value of 0. The result of this call is stored in lVar1. If lVar1 is greater than 0, the function sets the value of psuffix to the value of local_18 and psuffix_free to the value of puStack_14. The function then returns the value of lVar1."
openssl-101u,O3,arm,BIO_asn1_set_prefix,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BIO_asn1_set_prefix@001211d4.c,"The function takes in a BIO object and a prefix string, sets the prefix string to the BIO object using the control command 0x95, and returns the result. The prefix_free string is not used in this function."
openssl-101u,O3,arm,BN_GF2m_add,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_add@0011e2e0.c,"The function BN_GF2m_add() adds two binary polynomials represented as BIGNUMs and stores the result in a third BIGNUM pointer. It first checks the sizes of the input BIGNUMs and expands the size of the output BIGNUM to be at least as large as the larger of the input BIGNUMs using the bn_expand2() function. If the expansion fails, it returns 0. It then performs the XOR operation of the input BIGNUMs and stores the result in the output BIGNUM."
openssl-101u,O3,arm,BN_GF2m_mod,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod@0011e5b8.c,"The function BN_GF2m_mod takes three parameters: param_1, param_2, and param_3. The first two parameters are undefined, and the third parameter is a pointer to an array of integers. The function checks if the second element in the array pointed to by param_3 is equal to zero. If it is, the function returns 0. If the second element is not zero, the function calculates the length of the array by subtracting 1 from the second element and storing the result in iVar10. If iVar10 is less than 0, the function creates a local array of integers called aiStack_30 with a length of 7 and sets piVar7 to point to the first element of this array. If iVar10 is greater than or equal to 0, the function calculates the number of bits needed to represent the highest non-zero element in the array pointed to by param_3. The function then creates a local array of integers called ai."
openssl-101u,O3,arm,BN_GF2m_mod_arr,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_arr@0011e394.c,"The function BN_GF2m_mod_arr takes in three parameters: two BIGNUM pointers (param_1 and param_2) and a uint pointer (param_3) and returns an integer value. It first checks if the value of the uint pointer is zero. If it is, it sets the value of the first BIGNUM pointer (param_1) to 0 and returns 1. If the value of the uint pointer is non-zero, the function proceeds to check if the second BIGNUM pointer (param_2) is equal to the first BIGNUM pointer (param_1). If they are equal, it sets the value of the pointer puVar11 to the d field of the first BIGNUM pointer (param_1) and sets the value of iVar5 to the top field of the first BIGNUM pointer (param_1). If they are not equal, it sets the value of iVar5 to the top field of the second."
openssl-101u,O3,arm,BN_GF2m_mod_div,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_div@0011ee90.c,"The function BN_GF2m_mod_div is a part of the OpenSSL library and is used for division of binary polynomials in GF(2^m) field. It starts a BN_CTX to manage the creation and destruction of temporary BIGNUM objects. It obtains a BIGNUM object from the context and uses it to compute the inverse of the divisor in GF(2^m) field using BN_GF2m_mod_inv function. It allocates memory to store the bit positions of the non-zero bits in the dividend and computes the degree of the dividend polynomial. Finally, it calls the BN_GF2m_mod_mul_arr function to multiply the quotient and divisor and store the result."
openssl-101u,O3,arm,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_div_arr@0011efbc.c,"The function BN_GF2m_mod_div_arr takes in four parameters and a BN_CTX pointer. It starts a BN_CTX context, creates a new BIGNUM variable, sets it to 0, and iterates through the elements in param_4 until it reaches -1. For each element, the function sets the corresponding bit in the BIGNUM variable to 1. It then calls BN_GF2m_mod_div with the parameters and returns the result. Finally, it ends the BN_CTX context."
openssl-101u,O3,arm,BN_GF2m_mod_mul,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_mul@0011e8dc.c,"The function BN_GF2m_mod_mul performs modular multiplication on two BIGNUMs in GF(2^m) field, where m is a positive integer. It takes in five parameters: param_1, param_2, param_3, param_4, and param_5. param_1 and param_2 are pointers to the BIGNUMs to be multiplied. param_3 is a pointer to the BIGNUM that will hold the result of the multiplication. param_4 is a pointer to a BIGNUM that represents the modulus in GF(2^m) field. param_5 is an integer that specifies the degree of the irreducible polynomial used to define the GF(2^m) field. The function first calculates the number of bits in the modulus BIGNUM and adds 1 to it. It then allocates memory for an array of integers of size equal to the calculated value. If the memory allocation fails, the function returns."
openssl-101u,O3,arm,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_mul_arr@0011e778.c,"The function BN_GF2m_mod_mul_arr() takes in five arguments: an integer, two integer pointers, an integer, and a BN_CTX pointer. It returns an integer value. The function checks if the two integer pointers are equal. If they are, it calls the BN_GF2m_mod_sqr_arr() function with the same arguments and returns its result. If the two integer pointers are not equal, the function initializes a new BIGNUM variable 'a' using the BN_CTX_get() function. It then checks if the 'a' variable was successfully initialized and if it has enough memory allocated for the calculations. If not, it returns 0. Next, the function sets the 'top' field of the 'a' variable to the sum of the second elements of the two integer pointers plus 4. It then initializes the 'a' variable to all zeroes. The function then loops through the second element of the second integer pointer and multiplies each element with the corresponding."
openssl-101u,O3,arm,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_sqr@0011e9bc.c,"This function calculates the number of bits in the input BIGNUM and adds 1, allocates memory for an array of integers to store the positions of the non-zero bits in the input BIGNUM, iterates through the input BIGNUM and records the positions of the non-zero bits in the allocated array, calculates the number of leading zeroes in the array and determines if the input BIGNUM is zero, calls the BN_GF2m_mod_sqr_arr function with the allocated array as input if the input BIGNUM is not zero, frees the memory allocated for the array, and returns the result of the function call."
openssl-101u,O3,arm,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_sqrt@0011f21c.c,"The function BN_GF2m_mod_sqrt computes the square root of a BIGNUM in a finite field GF(2^m) and stores the result in another BIGNUM. The function takes four parameters: the output BIGNUM param_1, an integer param_2, the input BIGNUM param_3, and a BN_CTX object param_4 for temporary storage. 

The function first calculates the number of bits in the input BIGNUM and allocates an array of integers to store the positions of the set bits in the binary representation of the input BIGNUM. It then iterates over the words of the input BIGNUM, finds the positions of the set bits in each word, and stores them in the array.

Next, the function calculates the number of set bits in the input BIGNUM and uses this to determine the degree of the finite field extension. If there are no set bits, the input BIGNUM is zero and the output BIGNUM."
openssl-101u,O3,arm,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_GF2m_mod_sqr_arr@0011e65c.c,"This function starts a BN_CTX context and gets a new BIGNUM object from it. It then iterates through an input array, computes the square of each element using a precomputed table, sets the top field of the BIGNUM object to the size of the computed result, reduces the computed result modulo an input polynomial using the BN_GF2m_mod_arr function, and returns 1 if the reduction was successful and 0 otherwise. Finally, it ends the BN_CTX context."
openssl-101u,O3,arm,bn_GF2m_mul_2x2,./data/decomp/openssl-101u_arm_gcc_O3_extraction/bn_GF2m_mul_2x2@001213e0.c,"The function takes in five parameters, all of type undefined4 (which is a 32-bit unsigned integer). It returns an unsigned 64-bit integer. The function first checks if a certain bit is set in a global variable located at address DAT_00121500 + 0x1213ec. If the bit is set, the function calls a function mul_1x1_neon() three times and performs some bitwise operations on the results to calculate the final return value. If the bit is not set, the function calls a function mul_1x1_ialu() twice to calculate two intermediate values, and then performs some further calculations to calculate the final return value. The function stores some of the input parameters and intermediate values in an array of four unsigned integers located at the address pointed to by the first input parameter. The array is used to store the final result as well."
openssl-101u,O3,arm,BN_kronecker,./data/decomp/openssl-101u_arm_gcc_O3_extraction/BN_kronecker@0011dba4.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs a and b, which extends the Legendre symbol to all odd integers. It creates two BIGNUMs a_00 and a_01 using the BN_CTX_start and BN_CTX_get functions, and copies the values of a and b into a_00 and a_01 respectively using the BN_copy function. If a_01 is equal to zero, the function checks if a_00 is equal to one, and if so, it calculates the number of leading zeroes in a_00 and returns the result divided by 32. Otherwise, it returns 0xfffffffe. If a_01 is not equal to zero, the function checks if a_00 is less than one or greater than or equal to."
openssl-101u,O3,arm,by_dir_entry_free,./data/decomp/openssl-101u_arm_gcc_O3_extraction/by_dir_entry_free@000cd754.c,"The function takes a pointer to a pointer as input, which is expected to point to a dynamically allocated memory block. The function checks if the pointer is not null, and if so, it frees the memory block using the CRYPTO_free function. The function then checks if the third element of the pointer (which is expected to be a pointer to a stack structure) is not null. If it is not null, it frees the stack using the sk_pop_free function, passing a pointer to the by_dir_hash_free function as a parameter. Finally, the function frees the original pointer using the CRYPTO_free function and returns."
openssl-101u,O3,arm,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_arm_gcc_O3_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@00119ecc.c,"The function decodes a uchar array into an ASN1_VALUE structure using the GOST_CLIENT_KEY_EXCHANGE_PARAMS ASN1_ITEM definition, taking in a pointer to an ASN1_VALUE, a pointer to a uchar array, and a long integer representing the length of the uchar array. The function returns without any explicit value."
openssl-101u,O3,arm,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_arm_gcc_O3_extraction/d2i_GOST_KEY_PARAMS@00119e6c.c,"The function ""d2i_GOST_KEY_PARAMS"" decodes DER-encoded GOST key parameters into internal GOST key parameters. It takes in a pointer to an ASN1_VALUE, a double pointer to a uchar array, and a long integer. The function calls the ASN1_item_d2i function with the three parameters and a pointer to an ASN1_ITEM object. The ASN1_item_d2i function decodes the data and populates the ASN1_VALUE pointer with the resulting internal GOST key parameters. The function returns without any explicit value."
openssl-101u,O3,arm,decode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O3_extraction/decode_gost_algor_params@001188d0.c,"The function decodes GOST algorithm parameters from an X509_ALGOR structure and sets them in an EVP_PKEY structure. It first extracts the algorithm parameters from the X509_ALGOR structure and checks if they correspond to the GOST algorithm (OID 1.2.643.2.2.9). If they do, it determines the type of GOST algorithm (GOST R 34.10-2001 or GOST R 34.10-94) and sets the algorithm type in the EVP_PKEY structure. It then fills in the GOST algorithm parameters in the corresponding key structure (EC_KEY for GOST R 34.10-2001 and DSA for GOST R 34.10-94). If successful, it returns 1, otherwise it returns 0. If there is an error, it sets an error message using the ERR_GOST_error function."
openssl-101u,O3,arm,DES_xcbc_encrypt,./data/decomp/openssl-101u_arm_gcc_O3_extraction/DES_xcbc_encrypt@0011d0fc.c,"The functions both perform encryption using the DES algorithm with an initialization vector (IV). The first function specifically implements the DES-XCBC encryption algorithm and takes in additional arguments such as constant DES blocks and a flag indicating whether to encrypt or decrypt. It handles input byte arrays in 8-byte chunks and XORs them with the IV and constant DES block values before encrypting with DES. If the input length is not a multiple of 8 bytes, it handles the remaining bytes separately. The second function performs DES encryption in Cipher Block Chaining (CBC) mode and handles input messages of any length by dividing them into blocks and XORing each block with the previous block's encrypted output (or the IV for the first block)."
openssl-101u,O3,arm,dgram_ctrl,./data/decomp/openssl-101u_arm_gcc_O3_extraction/dgram_ctrl@000a2408.c,"The function `dgram_ctrl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. It initializes local variables and performs different actions based on the value of `param_2`, including setting `param_3` to a memory location or jumping to a common block of code.

The function takes in four parameters: a pointer to a structure, a pointer to a source buffer, the size of the source buffer, and a pointer to an output buffer. It checks for a specific byte pattern at the beginning of the source buffer and performs different operations based on the second byte, including setting the output size and copying bytes to the output buffer. One interesting case involves setting up a socket connection and setting a flag in the structure."
openssl-101u,O3,arm,dlfcn_bind_func,./data/decomp/openssl-101u_arm_gcc_O3_extraction/dlfcn_bind_func@0012070c.c,"The function takes two integer parameters, param_1 and param_2. If both parameters are not equal to zero, the function retrieves the topmost element from a stack pointed to by param_1 and attempts to find the symbol specified by param_2 using dlsym(). If successful, the function returns a pointer to the symbol. If unsuccessful, the function logs an error using ERR_put_error() and returns a null pointer. If either param_1 or param_2 is equal to zero, the function logs an error and returns a null pointer."
openssl-101u,O3,arm,dlfcn_bind_var,./data/decomp/openssl-101u_arm_gcc_O3_extraction/dlfcn_bind_var@001207e0.c,"The function takes two parameters, param_1 and param_2. If either of them is 0, it returns NULL. Otherwise, it initializes a pointer variable pvVar4 to NULL. Next, it checks if the number of elements in the stack pointed to by the pointer at param_1 is less than 1. If it is, it logs an error using the ERR_put_error function. If the stack has at least one element, it retrieves the last element from the stack and assigns it to pvVar4. If pvVar4 is NULL, it logs another error. If pvVar4 is not NULL, it attempts to retrieve the symbol named param_2 using the dlsym function. If dlsym returns NULL, it logs yet another error and retrieves the error message using the dlerror function. It then appends the error message to the error log using the ERR_add_error_data function. Finally, the function returns the value of pvVar4."
openssl-101u,O3,arm,dlfcn_globallookup,./data/decomp/openssl-101u_arm_gcc_O3_extraction/dlfcn_globallookup@00120520.c,"The function uses the dlfcn library to dynamically load a shared library and look up a symbol within it. It takes four parameters, which are not used in the function itself but are passed on to the dlopen and dlsym functions. It calls dlopen with a null filename and flags set to 1, indicating that the library should be loaded with global symbols. If dlopen succeeds, it calls dlsym with the handle returned by dlopen and the symbol name passed in as the first parameter. Finally, it calls dlclose to close the library handle and returns the result of dlsym, which should be a pointer to the requested symbol. If dlopen fails, it returns 0."
openssl-101u,O3,arm,doapr_outch.constprop.0,./data/decomp/openssl-101u_arm_gcc_O3_extraction/doapr_outch.constprop.0@0009f7cc.c,"The function takes in four parameters: void pointers param_1 and param_2, and uint pointers param_3 and param_4. It returns an undefined value. The function first checks if param_2 is equal to NULL. If it is, it sets uVar3 to the value pointed to by param_4 and uVar2 to the value pointed to by param_3. Otherwise, it sets uVar2 to the value pointed to by param_3 and uVar3 to the value pointed to by param_4. If uVar2 is equal to uVar3, the function checks if uVar2 is greater than 0x7ffffbff. If it is, the function returns 0. Otherwise, the function checks if *param_2 is equal to NULL. If it is, the function allocates memory of size uVar2 using CRYPTO_malloc and sets *param_2 to the allocated memory. If the allocation fails, the function returns."
openssl-101u,O3,arm,dtls1_link_min_mtu,./data/decomp/openssl-101u_arm_gcc_O3_extraction/dtls1_link_min_mtu@0005d398.c,"The function returns the minimum MTU (Maximum Transmission Unit) for a DTLS (Datagram Transport Layer Security) link, which is represented by the hexadecimal value 0x100 (256 in decimal)."
openssl-101u,O3,arm,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_mont_field_encode@0011f920.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The first parameter is used to access a BN_MONT_CTX structure stored at an offset of 0xa0. If this structure is not NULL, the function performs a Montgomery encoding of the second BIGNUM parameter using the third BIGNUM parameter and the Montgomery reduction factor stored in the BN_MONT_CTX structure. The result is stored in the second BIGNUM parameter. The function returns 1 on success and 0 on failure. If the BN_MONT_CTX structure is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101u,O3,arm,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_mont_field_sqr@0011f8e8.c,"The function ""ec_GFp_mont_field_sqr"" takes four parameters: an integer, two BIGNUM pointers, and a BN_CTX pointer. It checks if a BN_MONT_CTX pointer is not NULL, and if so, performs a modular multiplication of the second BIGNUM parameter with itself using the BN_mod_mul_montgomery function and the BN_MONT_CTX pointer, returning the result. If the BN_MONT_CTX pointer is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101u,O3,arm,ec_GFp_mont_group_init,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_mont_group_init@0011f6c4.c,"The `ec_GFp_mont_group_init` function initializes a Montgomery curve group in an elliptic curve cryptosystem by first calling `ec_GFp_simple_group_init` to initialize a simple curve group. It then sets two variables in the group structure to zero, which are used for Montgomery curve specific operations. The function does not return anything."
openssl-101u,O3,arm,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0012183c.c,"The function takes six parameters: an integer pointer, an integer, and four BIGNUM pointers. It returns a BIGNUM pointer. If the integer in the memory location pointed to by the integer pointer is zero, the function checks if the first two BIGNUM pointers are not null and copies them to the second and third parameters respectively. If the fourth BIGNUM pointer is not null, it is also copied to the fourth parameter. The function then returns either a pointer to the first non-null parameter or null if any of the copy operations failed. If the integer is not zero, the function checks if the sixth BIGNUM pointer is not null. If it is null, the function creates a new BN_CTX object and assigns it to the sixth parameter. The function then calls a function pointer stored in the memory location pointed to by the integer pointer, passing in the second parameter."
openssl-101u,O3,arm,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_group_check_discriminant@0012194c.c,"The function takes two parameters: an integer pointer and a BN_CTX pointer. It returns an integer value. It starts by checking if the BN_CTX pointer is null. If it is, it creates a new BN_CTX object and assigns it to the pointer. If the creation fails, an error is thrown and the function returns 0. The function then allocates memory for several BIGNUM objects using the BN_CTX object. Next, it checks if a specific function pointer in the integer pointer is null. If it is, it copies two BIGNUM objects from the integer pointer into the allocated memory. If it is not null, the function calls the function pointed to by the pointer, passing in the integer pointer and the BN_CTX pointer, and stores the result in the allocated memory. The function then performs some mathematical operations using the allocated BIGNUM objects and returns 1 if successful or 0 if any of the operations fail. Finally, the function frees the allocated memory and the."
openssl-101u,O3,arm,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_group_clear_finish@001215f4.c,"The function ec_GFp_simple_group_clear_finish takes an integer parameter (param_1) which is likely a pointer to an elliptic curve group structure. The function then clears and frees three big numbers (BIGNUMs) within the structure: one at offset 0x48, one at offset 0x74, and one at offset 0x88. These BIGNUMs likely represent important values for the elliptic curve group, such as the group order or the generator point. Once the BIGNUMs have been cleared and freed, the function returns."
openssl-101u,O3,arm,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_group_copy@00121fc8.c,"This function takes two integer parameters, assumed to be structures representing elliptic curve parameters in OpenSSL library. It copies the values of three BIGNUMs representing the prime modulus, the curve's A coefficient, and the curve's B coefficient from the second structure to the first structure. If successful, the function sets a flag in the first structure to indicate initialization and returns a pointer to the first structure. If unsuccessful, it returns a null pointer."
openssl-101u,O3,arm,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_group_get_degree@00121634.c,"The function takes an integer parameter (param_1) which is likely a pointer to a structure representing an elliptic curve group. It calls the BN_num_bits function from OpenSSL library passing a pointer to a BIGNUM object located at an offset of 0x48 from the beginning of the structure. This BIGNUM object likely represents the order of the group. The BN_num_bits function returns the number of bits in the BIGNUM object, which is the degree of the elliptic curve group. The function doesn't return anything, but it could be used to retrieve the degree of an elliptic curve group for further calculations."
openssl-101u,O3,arm,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_group_set_curve@0012203c.c,"The function `ec_GFp_simple_group_set_curve` sets the parameters of an elliptic curve over a finite field. It takes as input four BIGNUMs (`param_2`, `param_3`, `param_4`, and `param_5`) that represent the curve's coefficients, and an optional BN_CTX object (`param_5`) for temporary storage during computations. The function checks that the input `param_2` is valid, initializes a BN_CTX object if one was not provided as input, and computes `r = param_3 mod param_2`. If the curve has a cofactor (i.e., `param_4` is not equal to 1), it also computes `param_4 mod param_2`."
openssl-101u,O3,arm,ec_GFp_simple_invert,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_invert@00122730.c,"The function takes in an EC_GROUP object and an EC_POINT object as parameters. It checks if the EC_POINT is at infinity and returns 1 indicating failure. If the point is not at infinity and the y-coordinate of the point is non-zero, it calculates the inverse of the y-coordinate using BN_usub() function and returns the result."
openssl-101u,O3,arm,EC_GFp_simple_method,./data/decomp/openssl-101u_arm_gcc_O3_extraction/EC_GFp_simple_method@00122d2c.c,"The `EC_GFp_simple_method` function returns a pointer to an `EC_METHOD` structure that defines the operations that can be performed on an elliptic curve. The structure is cast to a pointer to `ret_9448`. However, the calling convention used by this function cannot be determined, suggesting that it may have been compiled with non-standard settings."
openssl-101u,O3,arm,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_point_copy@00122004.c,"The function copies the coordinates of one point on an elliptic curve in GF(p) to another point on the same curve. It takes two parameters, both of which are pointers to structures representing points on the curve. The function uses the BN_copy function from the OpenSSL library to copy the x-coordinate, y-coordinate, and z-coordinate of the second point to the corresponding coordinates of the first point. If all three BN_copy calls succeed, the function sets a flag indicating success and returns a pointer to this flag. Otherwise, it returns a null pointer to indicate failure."
openssl-101u,O3,arm,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_point_finish@001215d4.c,"The function takes an integer parameter, likely a pointer to a structure representing a point on an elliptic curve. It frees three BIGNUMs stored within the structure at specific offsets, likely representing the point's X, Y, and Z coordinates in some coordinate system. The function returns without any further action and is likely called when a point on the elliptic curve is no longer needed and its memory can be safely freed."
openssl-101u,O3,arm,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_point_get_affine_coordinates@00121ab4.c,"The function takes an EC_POINT structure as input and returns the affine coordinates of that point as BIGNUM structures. It first checks if the input point is at infinity, and initializes a BN_CTX object for temporary storage of BIGNUMs during calculations. The function retrieves four BIGNUMs from the BN_CTX object for intermediate calculations. If the curve has a special form, it retrieves the x-coordinate of the point directly from the EC_POINT structure. Otherwise, it calculates the x-coordinate using a curve-specific function. If the x-coordinate is equal to one and the y-coordinate is not needed, the function returns 1. Otherwise, it calculates the modular inverse of the x-coordinate with respect to the curve's order and uses it."
openssl-101u,O3,arm,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_arm_gcc_O3_extraction/ec_GFp_simple_point_set_affine_coordinates@0012215c.c,"This function takes an EC_GROUP object, an EC_POINT object, two BIGNUM objects representing the x and y coordinates of the point in affine coordinates, and a BN_CTX object for temporary memory allocation. If both x and y coordinates are not NULL, the function sets the point's coordinates using the EC_POINT_set_Jprojective_coordinates_GFp function with the z-coordinate set to 1. If either x or y coordinates are NULL, the function generates an error message using the ERR_put_error function and returns 0. The function returns an integer indicating success (1) or failure (0)."
openssl-101u,O3,arm,encode_gost_algor_params,./data/decomp/openssl-101u_arm_gcc_O3_extraction/encode_gost_algor_params@00119098.c,"The function takes an EVP_PKEY parameter and encodes it into an ASN1_STRING format using the GOST algorithm parameters. It creates a new ASN1_STRING object and a GOST_KEY_PARAMS object. If either of these objects fail to be created, an error is thrown and the function returns NULL. The function determines the type of the EVP_PKEY using EVP_PKEY_base_id. If it is a EC key, it gets the curve name and sets it as the first parameter in the GOST_KEY_PARAMS object. If it is a R3410 key, it gets the parameter set and compares it to the known parameter sets, setting the appropriate curve name as the first parameter in the GOST_KEY_PARAMS object. The second parameter in the GOST_KEY_PARAMS object is always set to the OID for the GOST algorithm. The GOST_KEY_PARAMS object is then encoded into the ASN1_STRING object using i2d_GOST_KEY_PARAMS. If the encoding is unsuccessful, an error is thrown."
openssl-101u,O3,arm,get_gost_engine_param,./data/decomp/openssl-101u_arm_gcc_O3_extraction/get_gost_engine_param@0011ae64.c,"The function takes an integer parameter called ""param_1"". If ""param_1"" is not equal to 0, it returns a null pointer. Otherwise, it checks if the global variable ""gost_params"" is null. If it is null, it tries to get the value of the environment variable ""CRYPT_PARAMS"" using the getenv function. If the value of ""CRYPT_PARAMS"" is null, it returns a null pointer. Otherwise, it copies the value of ""CRYPT_PARAMS"" to the ""gost_params"" variable using the BUF_strdup function and returns the value of ""gost_params""."
openssl-101u,O3,arm,gost2001_param_encode,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost2001_param_encode@00118c28.c,This function takes an ECC key pair represented by an EVP_PKEY object as input. It extracts the associated curve name in the form of a numeric identifier from the EC_GROUP object and converts it to an ASN1_OBJECT structure using OBJ_nid2obj. The resulting ASN1_OBJECT is then encoded into a binary format using i2d_ASN1_OBJECT and stored in the memory location pointed to by the param_2 parameter.
openssl-101u,O3,arm,gost_cipher_cleanup,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost_cipher_cleanup@0011a024.c,"The function accesses a memory location using an integer parameter and calls the `gost_destroy` function with a pointer to a location in memory offset by 0xc from the accessed memory location. This indicates that the accessed memory location contains a pointer to a `gost` structure, and the `gost_destroy` function is used to free the memory allocated to this structure. The function then sets a memory location at an offset of 0x54 from the input parameter to 0 and returns 1. The purpose of this memory location is not clear from the code provided."
openssl-101u,O3,arm,gost_cipher_ctl,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost_cipher_ctl@0011a46c.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function calls the `RAND_bytes` function to generate a random byte sequence of length `*(int *)(param_1 + 0x58)` and stores it in the buffer pointed to by `param_4`. If `RAND_bytes` returns a positive value, indicating success, the function returns 1. Otherwise, it calls the `ERR_GOST_error` function to report the error and returns -1. If `param_2` is equal to 7, the function checks if `param_4` is not equal to NULL. If it is not NULL, the function stores the value 0x32a in the memory location pointed to by `param_4` and returns 1. If `param_4` is NULL, the function does not modify any memory and returns -1."
openssl-101u,O3,arm,gost_cipher_do_cnt,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost_cipher_do_cnt@0011a13c.c,"The first function is responsible for encrypting data using a counter mode (CTR) and takes four parameters: an integer, a pointer to an array of unsigned integers, another pointer to an array of unsigned integers, and a pointer to a byte array. It generates keystream using the GOST cipher in counter mode and XORs it with the plaintext to produce the ciphertext. It handles remaining bytes separately if the plaintext is not aligned on a 4-byte boundary. The function returns 1 on success.

The second function takes four parameters: param_1, param_2, param_3, and param_4. Param_1 is a pointer to a structure that contains some data. Param_2 is a pointer to a buffer where the function will write some data. Param_3 is a pointer to another buffer that contains some data. Param_4 is the size of the buffer pointed to by param_2. It XORs each byte in the buffer pointed to by param_1 with the corresponding byte in the buffer pointed to by param_3 and stores the result in the buffer pointed to by param_2. The function returns 0 if param_1 is NULL or if param_4 is less than 0x30."
openssl-101u,O3,arm,gost_cipher_init,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost_cipher_init@0011acb0.c,"The function initializes the GOST cipher context with the specified parameters. It first checks if the app_data field of the context is null, and if so, it retrieves the GOST engine parameters from the get_gost_engine_param() function. If the retrieved parameters are empty or null, it uses the default GOST 28147-89 parameter set and sets the cipher_data field of the context accordingly. Otherwise, it converts the retrieved parameters to an object identifier (OID) using the OBJ_txt2nid() function and searches for a matching parameter set in the gost_cipher_list. If a match is found, it sets the cipher_data field of the context with the corresponding parameter set and initializes the GOST cipher with the gost_init() function. If the param_2 argument is not zero, it sets the key for the GOST cipher with the gost_key() function. If the param_3 argument is not null, it copies the initialization vector (IV) from param_3 to the context."
openssl-101u,O3,arm,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O3_extraction/GOST_CIPHER_PARAMS_new@00119eb4.c,The function creates a new instance of the GOST_CIPHER_PARAMS data structure by calling the ASN1_item_new function with a pointer to the ASN1_ITEM structure representing the data type. It returns without any further processing.
openssl-101u,O3,arm,gost_imit_final,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost_imit_final@0011aacc.c,"The function `gost_imit_final` takes two parameters, an integer `param_1` and an undefined value `param_2`. It retrieves the value of an integer variable `iVar1` from the memory location pointed to by an integer variable `iVar2` plus an offset of `0x103c`. If `iVar1` is equal to zero, it calls the `ERR_GOST_error` function with error code `0x8c` and error message ""gost_crypt.c"" at line number `0x239`, and then jumps to `LAB_0011ab00`. Next, it retrieves the value of an integer variable `iVar1` from the memory location pointed to by `iVar2` plus an offset of `0x1030`. If `iVar1` is equal to zero, it checks if another integer variable at `iVar2` plus an offset of `0x1038` is not equal to zero. If..."
openssl-101u,O3,arm,gost_imit_init_cpa,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost_imit_init_cpa@0011a418.c,"The function initializes variables in memory pointed to by the first parameter, sets specific bytes to 0 and 1, calls the function gost_init, and returns 1."
openssl-101u,O3,arm,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_arm_gcc_O3_extraction/GOST_KEY_PARAMS_new@00119e84.c,"The function creates a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new function, defined by the PTR_GOST_KEY_PARAMS_it_00119e8c ASN1_ITEM object, and returns the structure."
openssl-101u,O3,arm,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_arm_gcc_O3_extraction/GOST_KEY_TRANSPORT_free@00119e00.c,"The function frees memory allocated to an ASN1_VALUE structure, using the 'ASN1_item_free' function with a pointer to an ASN1_ITEM structure of type 'GOST_KEY_TRANSPORT_it' as the second parameter. It takes the ASN1_VALUE structure as a parameter named 'param_1' and returns afterwards."
openssl-101u,O3,arm,gost_param_free,./data/decomp/openssl-101u_arm_gcc_O3_extraction/gost_param_free@0011ae0c.c,"The `gost_param_free` function deallocates memory used by the GOST parameters by checking if the global variable `gost_params` is not equal to null pointer. If it is not null, it frees the memory allocated to `gost_params` using the `CRYPTO_free` function and sets `gost_params` to null."
openssl-101u,O3,arm,hash_step,./data/decomp/openssl-101u_arm_gcc_O3_extraction/hash_step@0011aed8.c,"The first function takes in an integer and two pointers to unsigned integers. It copies the values of the pointers into local variables or XORs them depending on the least significant two bits of the pointers. It then calls another function called `gost_enc_with_key` with several arguments, including the integer parameter, the local variables, and the first pointer. The result is stored in another local variable. The function then performs several XOR and memmove operations on the local variables and the values pointed to by the second pointer. The resulting values are stored in additional local variables. Finally, the function updates the values pointed to by the second pointer with the new values and returns.

The second function performs encryption using the GOST block cipher algorithm with a given key and input data. It takes in two parameters - the key and the input data. It initializes some local variables and performs some bitwise operations on them. It then calls the `gost_enc_with_key` function with the key and input data as parameters and stores the result in a local variable. Next, it performs some more bitwise operations on the input data and stores the results in various local variables. It then calls `gost_enc_with_key` again with the same key and a modified version of the input data and stores the result in another local variable. Finally, it performs some more bitwise operations on the second result and stores the results in various local variables. It then returns the final set of local variables as the encrypted output.

The third function takes in three parameters: a pointer to a 32-byte key, a pointer to a 32-byte input buffer, and a pointer to a 32-byte output buffer. It initializes several local variables and then performs a series of XOR and bit-shift operations on them. It then calls another function called ""gost_enc_with_key"" with several of these variables as arguments. After the ""gost_enc_with_key"" function returns, the function performs more XOR and bit-shift operations on the local variables and the input buffer. It then XORs the resulting values with the output buffer and stores the result in the output buffer. Finally, the function checks whether the value stored at the address pointed to by a local variable is equal to another local variable. If they are not equal, the function throws an error and exits."
openssl-101u,O3,arm,hwcrhk_init,./data/decomp/openssl-101u_arm_gcc_O3_extraction/hwcrhk_init@000f20a4.c,"The function initializes the HWCryptoHook library by loading the library file, binding its functions, and setting some global variables. If the library file fails to load or any of the required functions fail to bind, an error is thrown. The function also sets up a mutex callback function if it is not disabled. Finally, the function returns 1 if the RSA key handle index is successfully created or if it already exists, and returns 0 otherwise."
openssl-101u,O3,arm,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_arm_gcc_O3_extraction/i2d_GOST_KEY_AGREEMENT_INFO@00119e48.c,The function takes in an ASN1_VALUE structure pointer and a uchar double pointer. It converts the ASN1_VALUE structure into a uchar array using the GOST_KEY_AGREEMENT_INFO ASN1 item template with the ASN1_item_i2d function. The resulting uchar array is stored in the memory location pointed to by the double pointer. The function returns without any value.
openssl-101u,O3,arm,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_arm_gcc_O3_extraction/i2d_GOST_KEY_TRANSPORT@00119de8.c,"The function i2d_GOST_KEY_TRANSPORT encodes an ASN1_VALUE structure into a byte array and stores it in the memory location pointed to by the second parameter, which is a pointer to a pointer of unsigned char. It takes two parameters, an ASN1_VALUE pointer and the aforementioned pointer, and calls the ASN1_item_i2d function with these parameters and the ASN1_ITEM structure for GOST_KEY_TRANSPORT. The function does not return any value."
openssl-101u,O3,arm,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_arm_gcc_O3_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@0008653c.c,"The function takes a BIGNUM structure, an integer, an array of unsigned integers, and two unsigned integers as input. If the BIGNUM structure has fewer digits than the input integer, it expands to have the required number of digits. The function then copies the unsigned integers from the input array to the BIGNUM structure, optimizing for cases where the input integer is less than 4 or greater than or equal to 4. If the input integer is less than 4, the function loops through each digit in the BIGNUM structure and sets it to the bitwise OR of a subset of the unsigned integers in the input array, determined by the value of the second unsigned integer input. If the expansion of the BIGNUM structure fails, the function returns 0."
openssl-101u,O3,arm,mul_1x1_ialu,./data/decomp/openssl-101u_arm_gcc_O3_extraction/mul_1x1_ialu@001212c0.c,"The function ""mul_1x1_ialu"" returns without performing any actions."
openssl-101u,O3,arm,param_copy_gost94,./data/decomp/openssl-101u_arm_gcc_O3_extraction/param_copy_gost94@00118de8.c,"The function copies parameters from one EVP_PKEY object to another for the GOST94 algorithm. It takes two EVP_PKEY pointers as input and checks if the base IDs of the two objects match. If they don't, an error is thrown and the function returns 0. If they do match, the function proceeds to copy the parameters from param_2 to param_1 by creating a new DSA object if necessary and assigning it to param_1. It then duplicates the BIGNUM objects from param_2 into the corresponding fields in the DSA object. Finally, if the private key in the DSA object is not null, it is also copied."
openssl-101u,O3,arm,param_print_gost01,./data/decomp/openssl-101u_arm_gcc_O3_extraction/param_print_gost01@001199e4.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer value. It gets the EC_KEY object from the EVP_PKEY object, then gets the EC_GROUP object from the EC_KEY object. It gets the curve name of the EC_GROUP object and stores it in the variable 'n'. The function indents the output buffer using the BIO_indent function and checks if the indentation was successful. If successful, it converts the curve name to a string using the OBJ_nid2ln function and prints it to the output buffer using the BIO_printf function. The function returns 1 if the indentation was successful, indicating that the output was printed successfully to the buffer."
openssl-101u,O3,arm,param_print_gost94,./data/decomp/openssl-101u_arm_gcc_O3_extraction/param_print_gost94@00119970.c,"The `param_print_gost94` function takes in a BIO object, an EVP_PKEY object, and an integer, and returns an integer value. It gets the internal key representation from the EVP_PKEY object, creates an array of BIGNUM pointers, and loops through the `R3410_paramset` array to compare the string representation of the parameters to the public key parameters stored in `pvVar2`."
openssl-101u,O3,arm,pkey_ctrl_gost,./data/decomp/openssl-101u_arm_gcc_O3_extraction/pkey_ctrl_gost@00119398.c,"The function `pkey_ctrl_gost` takes four parameters: `param_1` (an EVP_PKEY object), `param_2` (an integer), `param_3` (a pointer to a X509_ALGOR object), and `param_4` (a pointer to a PKCS7_SIGNER_INFO object). The function performs different actions based on the value of `param_2`. If `param_2` is 1, 2, 5, or 7, the function sets `local_1c[0]` to the value of `param_3`. If `param_2` is 1 or 5, the function gets the algorithm information from `param_4` and sets `local_20` to the algorithm information. If `param_2` is 2 or 7, the function encodes the GOST algorithm parameters and sets `pval` to the encoded value."
openssl-101u,O3,arm,priv_encode_gost,./data/decomp/openssl-101u_arm_gcc_O3_extraction/priv_encode_gost@00119560.c,"The function takes in two parameters, a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure. It encodes the GOST algorithm parameters using the encode_gost_algor_params function and sets the result as the algorithm parameters for the private key in the PKCS8_PRIV_KEY_INFO structure. If the EVP_PKEY structure is of type EC or ECDH, it retrieves the private key from the EVP_PKEY structure and converts it to an ASN1_INTEGER using BN_to_ASN1_INTEGER. It then sets the ASN1_INTEGER as the private key value for the PKCS8_PRIV_KEY_INFO structure. Finally, it returns nothing."
openssl-101u,O3,arm,pub_encode_gost94,./data/decomp/openssl-101u_arm_gcc_O3_extraction/pub_encode_gost94@0011948c.c,"This function encodes a GOST 94 public key and sets the encoded key as the parameters of an X509_PUBKEY structure. It takes two parameters: param_1, which is a pointer to an X509_PUBKEY structure, and param_2, which is a pointer to an EVP_PKEY structure containing the GOST 94 public key. 

First, it gets the GOST 94 algorithm object and checks if there are any saved parameters for the key. If there are, it encodes the parameters using the encode_gost_algor_params() function and sets them to local_34. Next, it calculates the length of the GOST 94 public key and allocates memory for it. It then converts the key to binary format and stores it in the allocated memory. After that, it creates an ASN1_OCTET_STRING structure and sets its data to the binary representation of the public key. It then encodes the ASN1_OCTET_STRING structure."
openssl-101u,O3,arm,pub_print_gost94,./data/decomp/openssl-101u_arm_gcc_O3_extraction/pub_print_gost94@00119a20.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It extracts the public key from the EVP_PKEY object and prints it to the BIO object. It compares the parameter set of the public key to a list of predefined parameter sets and prints the matching parameter set to the BIO object. It returns 1."
openssl-101u,O3,arm,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O3_extraction/RSA_padding_add_PKCS1_PSS@00120050.c,"The function performs PKCS1 PSS padding scheme on a message hash using a provided salt length and hash function. It generates a random salt of the specified length, concatenates it with the message hash, and applies the MGF1 function to generate a mask that is XORed with the padded message hash. The function sets the last byte of the EM buffer to a fixed value and returns the padded message. If an error occurs during the padding process, the function returns 0."
openssl-101u,O3,arm,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_arm_gcc_O3_extraction/RSA_verify_PKCS1_PSS@0011f9dc.c,"The function RSA_verify_PKCS1_PSS verifies a digital signature using the RSA-PSS algorithm. It initializes an EVP_MD_CTX structure for use with the hash function, checks the size and validity of the signature, and decodes the signature using PKCS1_MGF1. It performs a bitwise XOR operation between the decoded signature and a mask generated from the hash of the message. If the decoded signature is valid, the function checks if the remaining bytes are equal to the hash of the message concatenated with some padding. If so, the signature is valid and the function returns."
openssl-101u,O3,arm,sha_block_data_order,./data/decomp/openssl-101u_arm_gcc_O3_extraction/sha_block_data_order@0011bcf0.c,"The functions all implement the SHA-1 hashing algorithm, which takes in input data and produces a 160-bit hash value as output. The input data is processed in blocks of 512 bits, with each block consisting of 16 32-bit words. The algorithm uses a series of bitwise operations, logical operations, and additions to transform the input data and update a set of variables or registers. The specific operations used are based on the SHA-1 algorithm specification. At the end of processing all blocks, the final values of the variables or registers are combined to produce the SHA-1 hash output, which is returned."
openssl-101u,O3,arm,SHA_Final,./data/decomp/openssl-101u_arm_gcc_O3_extraction/SHA_Final@0011cfd8.c,"The SHA_Final function takes in a message digest (md) and a SHA_CTX structure (c) as inputs. It determines the number of bytes in the message (c->num) and adds a padding byte (0x80) to the end of the message. If there is not enough space for padding and a 64-bit length value, the function fills the remaining space with zeros and processes the block. Otherwise, it fills the remaining space with zeros and adds the 64-bit length value to the end of the message. The function sets the values of the SHA_CTX data structure to the appropriate byte order and processes the final block of data. After processing the final block, the function sets the SHA_CTX num value to zero, cleans up the data structure, and sets the values of the message digest (md) to the final hash values. Finally, the function returns 1 to indicate success."
openssl-101u,O3,arm,srp_verify_server_param,./data/decomp/openssl-101u_arm_gcc_O3_extraction/srp_verify_server_param@00068fc8.c,"The function `srp_verify_server_param` takes four parameters: an integer `param_1`, a pointer to an undefined 4-byte value `param_2`, and two 4-byte integers `param_3` and `param_4`. The function first compares two BIGNUM values located at offsets `0x1ac` and `0x1a8` in memory. If the first BIGNUM value is greater than or equal to the second BIGNUM value, or if another BIGNUM value located at offset `0x1b4` is less than the second BIGNUM value, or if the fourth byte of the BIGNUM value at offset `0x1b4` is 0, the function sets the value pointed to by `param_2` to `0x2f` and returns 0. Otherwise, the function calculates the number of bits in the second BIGNUM value and compares it to the value located."
openssl-101u,O3,arm,SSLv23_method,./data/decomp/openssl-101u_arm_gcc_O3_extraction/SSLv23_method@000512ac.c,"The SSLv23_method function returns a pointer to an SSL_METHOD structure stored in SSLv23_method_data_18415, which likely implements the SSLv23 protocol. The function has no input parameters and its calling convention is unknown."
openssl-101u,O3,arm,start_hash,./data/decomp/openssl-101u_arm_gcc_O3_extraction/start_hash@0011b880.c,"The function takes in a pointer to an array of undefined 4-byte integers as its parameter. It retrieves the value at the third index of the array and stores it in the variable iVar1. If iVar1 is not equal to 0, the function proceeds to set the values of the fourth to eighth elements of the array to 0 using the memset function. It then sets the first element of the array to 0, the second element to 0, the third element to 0, and the fourth element to 0. Finally, the function returns the value of iVar1."
openssl-101u,O3,arm,surewarehk_finish,./data/decomp/openssl-101u_arm_gcc_O3_extraction/surewarehk_finish@000f2ff4.c,"This function checks if the surewarehk_dso variable is null. If it is null, it sets the SUREWARE_lib_error_code to the next error in the library and returns 0. If it is not null, it calls the p_surewarehk_Finish function and frees the surewarehk_dso variable. If the DSO_free function returns 0, it sets the SUREWARE_lib_error_code to the next error in the library and returns 0. If logstream is not null, it frees it. It sets all the function pointers to null and returns 1."
openssl-101u,O3,arm,sv_body,./data/decomp/openssl-101u_arm_gcc_O3_extraction/sv_body@0002686c.c,"The function `sv_body` is a server-side SSL/TLS implementation that sets up a socket to listen for incoming connections, accepts incoming connections, and handles SSL/TLS communication with the client. It allocates a buffer and sets the SSL object's I/O BIO and accept mode. It also sets various options and callbacks on the SSL object, such as session ID context, message callback, and TLS extension debug callback. If debugging is turned on, it sets the SSL object's debug options and sets a callback function for dumping the SSL/TLS messages. 

The function is the main body of a TLS server program. It sets up a socket to listen for incoming connections, and for each connection, it performs a TLS handshake and then reads and writes data over the secure connection. It creates a SSL_CTX object that contains the TLS configuration for the server. If the server is in ""quiet"" mode, it will only exit if the client sends a ""q"" or ""Q"" character. Otherwise, the server will respond to various commands sent by the client, such as printing statistics or renegotiating the TLS connection. If the server encounters any errors during the TLS, it will handle them accordingly."
openssl-101u,O3,arm,TLSv1_method,./data/decomp/openssl-101u_arm_gcc_O3_extraction/TLSv1_method@000525b8.c,The function returns a pointer to an SSL_METHOD structure representing the TLSv1 protocol. It is likely that the function simply returns a pointer to a global variable containing the necessary data. The warning about an unknown calling convention is due to the function having no parameters or local variables.
openssl-101u,O3,arm,__aeabi_idivmod,./data/decomp/openssl-101u_arm_gcc_O3_extraction/__aeabi_idivmod@00123244.c,"The function performs integer division and modulus operation for ARM processors. It takes two integer parameters and checks if param_2 is zero. If not, it performs the operation param_1 / param_2 and param_1 % param_2 by calling _divsi3_skip_div0_test(). If param_1 is positive, it limits the result to the maximum value of a signed integer, and if param_1 is negative, it limits the result to the minimum value of a signed integer. Finally, it calls __aeabi_idiv0() to perform the division and returns the result."
openssl-101u,O3,arm,__libc_csu_init,./data/decomp/openssl-101u_arm_gcc_O3_extraction/__libc_csu_init@00123954.c,"The function __libc_csu_init initializes the C runtime environment by calling the _init function and then loops through a list of function pointers stored in memory, calling each function with the given parameters. The number of function pointers to call is calculated by subtracting the address of a pointer to the end of the list from a constant value and then dividing the result by 4. The function returns once all the function pointers have been called."
openssl-101u,O3,arm,__sha256_block_data_order_from_thumb,./data/decomp/openssl-101u_arm_gcc_O3_extraction/__sha256_block_data_order_from_thumb@001239b8.c,"The functions all implement the SHA-256 hashing algorithm to process input data and generate a 256-bit hash value. They use a combination of bitwise operations, additions, and XOR operations to update intermediate hash values and process data in blocks of 512 or 64 bytes. The functions also initialize variables and constants specific to the SHA-256 algorithm."
openssl-101u,O3,arm,__udivdi3,./data/decomp/openssl-101u_arm_gcc_O3_extraction/__udivdi3@00123658.c,"The function takes four unsigned integers as input and performs arithmetic operations on them to return a 64-bit unsigned integer as output. It checks if any input values are zero and returns zero if so. If param_3 is less than or equal to param_1 and param_4 is less than or equal to param_2, it performs calculations and returns the result. If param_3 is greater than param_1 or param_4 is greater than param_2, it sets flag variables based on the relationship between the inputs and performs unsigned integer division using a series of multiplications and subtractions."
openssl-101u,O3,arm,___armv7_tick_from_thumb,./data/decomp/openssl-101u_arm_gcc_O3_extraction/___armv7_tick_from_thumb@001239c0.c,"The function is a low-level system function for ARMv7 architecture that takes in an integer and a pointer to an array of undefined 4-byte values. It performs a vector rounding operation using two double-precision floating point values and updates the value at a memory location pointed to by a pointer obtained from another coprocessor register. If the array is greater than 6 bytes in size, it jumps to a label and continues execution. Otherwise, it sets each byte of the array to 0 until it reaches the end of the array. It then checks the value of the LR and performs more vector rounding operations. It checks a boolean flag and either continues execution or jumps to another label. If the flag is false, it enters another."
openssl-101u,O0,x86,aep_mod_exp.part.0,./data/decomp/openssl-101u_x86_gcc_O0_extraction/aep_mod_exp.part.0@0819cda0.c,"The function `aep_mod_exp_part_0` performs modular exponentiation using an external hardware security module (HSM) if available, and falls back to the software implementation if the HSM is not available or encounters an error. It first calls `aep_get_connection` to obtain a connection to the HSM. If the function returns 0, indicating a successful connection, it calls the external function `p_AEP_ModExp` to perform the modular exponentiation operation using the HSM. If the operation is successful, the function updates the connection status in a table and returns 1. If the operation fails, it logs an error and closes the connection to the HSM. If `aep_get_connection` returns a non-zero value, indicating that the HSM is not available or encountered an error, the function falls back to the software implementation of modular exponentiation using the `BN_mod_exp` function from OpenSSL. The result of the operation is returned."
openssl-101u,O0,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_x86_gcc_O0_extraction/asn1_bio_callback_ctrl@081e50a0.c,"The function takes in three parameters: param_1, param_2, and param_3. It checks if the value stored at the memory address pointed to by (param_1 + 0x24) is not equal to NULL. If it is not NULL, then it calls the BIO_callback_ctrl function with the parameters param_2 and param_3, passing the value stored at the memory address pointed to by (param_1 + 0x24) as the first argument. Finally, it returns the value returned by BIO_callback_ctrl. If the value stored at the memory address pointed to by (param_1 + 0x24) is NULL, then the function returns 0."
openssl-101u,O0,x86,asn1_bio_ctrl,./data/decomp/openssl-101u_x86_gcc_O0_extraction/asn1_bio_ctrl@081e5160.c,"The function `asn1_bio_ctrl` takes in a `bio_st` structure pointer `param_1`, an integer `param_2`, a long integer `param_3`, and an integer pointer `param_4`. The function first checks if the `ptr` field of the `bio_st` structure is NULL. If it is, the function returns 0. If `param_2` is 0x97, the function sets the 10th and 11th elements of the `piVar2` array (which is a pointer to the `bio_st` structure's `ptr` field) to the values pointed to by `param_4` and `param_4[1]`, respectively, and returns 1. If `param_2` is 0x95, the function sets the 8th and 9th elements of the `piVar2` array to the values pointed to by `param_4`."
openssl-101u,O0,x86,asn1_bio_free,./data/decomp/openssl-101u_x86_gcc_O0_extraction/asn1_bio_free@081e50c0.c,"The function takes an integer parameter, assumed to be a pointer to a BIO structure. It retrieves the pointer to the internal data buffer of the BIO structure. If this pointer is not null, it checks if the pointer to the data buffer inside the internal data buffer is also not null. If it is not null, it frees the memory allocated for the data buffer. It then frees the memory allocated for the internal data buffer. Finally, it sets some fields of the BIO structure to zero and returns 1 to indicate success. If the pointer to the internal data buffer is null, it returns 0 to indicate failure."
openssl-101u,O0,x86,asn1_bio_write,./data/decomp/openssl-101u_x86_gcc_O0_extraction/asn1_bio_write@081e5460.c,"The `asn1_bio_write` function in OpenSSL library writes ASN.1 data to a BIO object. It takes a pointer to a BIO object, a pointer to a buffer containing the data to be written, and the length of the data as parameters. The function validates the input parameters and returns 0 if any of them are invalid. It uses a state machine with five states to keep track of the progress of the write operation. The initial state is 0 and the function transitions to state 3 if the data being written is an ASN.1 object."
openssl-101u,O0,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BIO_asn1_get_suffix@081e5870.c,"The function takes a BIO object, a pointer to a pointer to an undefined type called ""psuffix"", and a pointer to a pointer to an undefined type called ""psuffix_free"". The function returns an integer value. The function first declares a local variable ""lVar1"" of type long and a local variable ""local_18"" of type pointer to undefined type. It also declares a local variable ""local_14"" of type pointer to undefined type and initializes it to NULL. It declares a local variable ""local_10"" of type integer and initializes it to the value at the memory location pointed to by the expression ""*(int *)(in_GS_OFFSET + 0x14)"". The function then calls the BIO_ctrl function with the BIO object, a control command value of 0x98, a parameter value of 0, and a pointer to ""local_18"". This function returns a long value that is stored in ""lVar1"". If the value of ""local_18"" is not NULL, the function sets the value of ""psuffix"" to the value of ""local_18"" and sets the value of ""psuffix_free"" to the value of ""local_14"". The function then returns 1. If ""local_18"" is NULL, the function sets the value of ""psuffix"" to NULL and sets the value of ""psuffix_free"" to NULL. The function then returns 0."
openssl-101u,O0,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BIO_asn1_set_prefix@081e5770.c,"The function BIO_asn1_set_prefix takes in three arguments: a BIO object pointer (b), a pointer to an undefined1 variable (prefix), and a pointer to another undefined1 variable (prefix_free). The function initializes a local variable local_10 to the value of *(int *)(in_GS_OFFSET + 0x14), sets local variables local_18 and local_14 to the values of prefix and prefix_free, respectively, and then calls the BIO_ctrl function with parameters b, 0x95, 0, and a pointer to local_18. Finally, the function checks if the value of local_10 is still equal to *(int *)(in_GS_OFFSET + 0x14)."
openssl-101u,O0,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_get0_nist_prime_224@081e58e0.c,The function returns a pointer to a BIGNUM structure that contains the NIST prime number for 224-bit elliptic curve cryptography. The value of the prime number is stored in the global variable _bignum_nist_p_224. The function does not take any parameters and its calling convention is unknown.
openssl-101u,O0,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_get0_nist_prime_384@081e5900.c,"The function returns a pointer to a BIGNUM struct that contains the NIST prime number with 384 bits, stored in a static memory location called ""_bignum_nist_p_384"". The calling convention of the function is unknown."
openssl-101u,O0,x86,BN_GF2m_add,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_add@081dfc60.c,"The function BN_GF2m_add takes in three parameters: a BIGNUM pointer param_1, an integer pointer param_2, and another integer pointer param_3. It returns an integer value. The function first checks the sizes of param_2 and param_3 and swaps them if necessary, so that param_2 always contains the smaller value. It then checks if the size of param_1 is large enough to hold the result and expands it if necessary. Next, the function performs a bitwise XOR operation between the integers pointed to by param_2 and param_3 and stores the result in the BIGNUM pointed to by param_1. The function also updates the top field of param_1 to reflect the new size of the BIGNUM. Finally, the function removes any trailing zeros from the BIGNUM and returns 1 to indicate success."
openssl-101u,O0,x86,BN_GF2m_mod,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod@081dfe00.c,"The function BN_GF2m_mod takes two BIGNUM pointers (param_1 and param_2) and an integer pointer (param_3) as input parameters. It returns an undefined 4-byte value. The function first checks if the second integer in the integer pointer (param_3[1]) is equal to zero. If it is, an error message is printed and the function returns 0. If param_3[1] is not zero, the function calculates the positions of the set bits in the binary representation of the second BIGNUM (param_2) and stores them in an array called local_38. If there are more than 6 set bits, an error message is printed and the function returns 0. If the first element of local_38 is zero, the function sets the first BIGNUM (param_1) to zero and returns 1. If the first element of local_38 is not zero, the function checks if param."
openssl-101u,O0,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_arr@081dfd60.c,"This function takes in three parameters: two BIGNUM pointers and an integer pointer. It first checks if the integer pointed to by the third parameter is zero, and if it is, sets the value of the first BIGNUM pointer to zero and returns 1. If the integer is not zero, the function checks if the first BIGNUM pointer is equal to the second BIGNUM pointer. If they are not equal, the function expands the first BIGNUM pointer to have the same number of words as the second BIGNUM pointer, and copies the values of the second BIGNUM pointer into the first BIGNUM pointer. The function then calls another function, BN_GF2m_mod_arr_part_0(), and returns its result."
openssl-101u,O0,x86,BN_GF2m_mod_div,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_div@081e1700.c,"The function BN_GF2m_mod_div performs modular division in a binary field GF(2^m). It takes in four parameters: an undefined value param_1, an undefined value param_2, a BIGNUM pointer param_4 representing the dividend, and a BN_CTX pointer param_5. The function first starts a BN_CTX context using BN_CTX_start and allocates memory for a BIGNUM pointer pBVar2 using BN_CTX_get. It then computes the modular inverse of the divisor param_3 with respect to the binary field using BN_GF2m_mod_inv. If the modular inverse cannot be computed or memory allocation fails, the function returns 0. Next, the function computes the number of bits in the dividend using BN_num_bits and adds 1 to get the number of words needed to represent the dividend. It then allocates memory for an array of integers using CRYPTO_malloc. If the dividend has a top value of 0, indicating that it is..."
openssl-101u,O0,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_div_arr@081e18b0.c,"This function starts two BN_CTX contexts, creates a BIGNUM object ""a"", sets its bits specified by an array, calculates the inverse of ""a"" modulo a parameter, calculates the number of bits in ""a"", iterates through the bits and stores the bit positions of the set bits in an array. It returns 0 if there are no set bits or if the memory allocation failed. Finally, it calls BN_GF2m_mod_mul_arr with several parameters."
openssl-101u,O0,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_mul@081e0dc0.c,"The function BN_GF2m_mod_mul is a part of the OpenSSL library and is used for performing multiplication of two elements in a finite field GF(2^m). The function takes five parameters, including three integers and two pointers to BIGNUM structures. The function first calculates the number of bits in the first BIGNUM parameter and allocates memory for an array of integers to store the indices of non-zero bits in the BIGNUM parameter. If the allocation fails, the function returns 0. Next, the function checks if the first BIGNUM parameter is non-zero and iterates over its words to find the indices of non-zero bits using bit manipulation. The indices are stored in the previously allocated array. The function then checks if the number of non-zero bits is less than or equal to the number of bits in the first BIGNUM parameter plus one. If not, the function returns an error. Otherwise, it calls the function BN_GF2m_mod_mul."
openssl-101u,O0,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_mul_arr@081e0190.c,"The first function, BN_GF2m_mod_mul_arr, is a function in OpenSSL's implementation of elliptic curve cryptography that performs multiplication of two binary polynomials in GF(2^m) field. It takes in four input parameters and uses a lookup table for squaring and a precomputed table for multiplication.

The second function takes in three parameters and performs a series of operations on the input buffer using the integers in the array as constants, and stores the result in the output buffer.

The third function, a decompiled version of BN_GF2m_mod_arr, performs modular reduction of a binary polynomial represented as a BIGNUM in GF(2^m) field. It takes in five parameters and checks if the input BIGNUM is zero before performing the reduction."
openssl-101u,O0,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_sqr@081e0f10.c,"The function BN_GF2m_mod_sqr performs a modular squaring operation on a BIGNUM object in GF(2^m) field, where m is a positive integer. It calculates the number of bits in the BIGNUM object, allocates memory for a temporary array of integers to store the positions of the non-zero bits in the BIGNUM object, and iterates through the BIGNUM object to store the positions of the non-zero bits in the temporary array. If the temporary array is not empty, the function calls BN_GF2m_mod_sqr_arr to perform the modular squaring operation on the temporary array, and returns the result. If the temporary array is empty, the function returns 0. The function also handles memory allocation errors and reports them using the ERR_put_error function."
openssl-101u,O0,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_sqrt@081e1eb0.c,"The function BN_GF2m_mod_sqrt calculates the square root of a binary field element using a polynomial basis. It takes in four parameters: param_1 (a BIGNUM pointer), param_2 (an integer), param_3 (another BIGNUM pointer), and param_4 (a BN_CTX pointer). The function first calculates the number of bits in param_3 and allocates memory accordingly. It then converts param_3 into an array of bit positions using a bitwise operation. If the first bit in the bit position array is set, it performs a modular exponentiation operation using BN_GF2m_mod_exp_arr and sets the result in param_1. If the first bit is not set, it sets param_1 to 0. Finally, the function frees the memory allocated and returns the result of the operation (either 0 or 1)."
openssl-101u,O0,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_GF2m_mod_sqr_arr@081dff80.c,"The function takes in four parameters: a BIGNUM pointer, two integer pointers, and a BN_CTX pointer. It returns a boolean value. The function starts the BN_CTX and creates a new BIGNUM object called ""a"" using the BN_CTX_get function. If a is NULL, the function returns false. If a is not NULL, the function proceeds to square the input array (param_2) and store the result in a using a precomputed lookup table called SQR_tb. The function then checks if the second input integer pointer (param_3) is equal to zero. If it is, the function sets the output BIGNUM pointer (param_1) to zero and returns true. If param_3 is not zero, the function checks if param_1 is equal to a. If they are not equal, it expands param."
openssl-101u,O0,x86,BN_kronecker,./data/decomp/openssl-101u_x86_gcc_O0_extraction/BN_kronecker@081deef0.c,"The BN_kronecker function calculates the Kronecker symbol of two BIGNUMs (a and b) using the binary method. It allocates memory for two BIGNUMs, a_00 and a_01, using the BN_CTX_start and BN_CTX_get functions. It copies the value of a into a_00 and b into a_01 using the BN_copy function. If either a_01 or a_00 are NULL, it returns an error code (-2). If a_01 is empty, it sets the result to 0xfffffffe and returns it. Otherwise, it checks if either a_00 or a_01 are odd. If either is odd, it sets a variable uVar4 to 0 and then finds the lowest bit where a_01 is set to 1 using the BN_is_bit_set function. It then shifts a_01 to the right by u."
openssl-101u,O0,x86,by_dir_entry_free,./data/decomp/openssl-101u_x86_gcc_O0_extraction/by_dir_entry_free@08166860.c,"The function ""by_dir_entry_free"" frees the memory allocated for a ""by_dir_entry"" structure, which contains a pointer to a hash table and other metadata. It takes a double pointer ""param_1"" as input and first checks if the value pointed to by ""param_1"" is not NULL. If it is not NULL, it frees the memory using the ""CRYPTO_free"" function. Next, it checks if the value pointed to by the third element of ""param_1"" (which is cast to a ""_STACK*"" type) is not NULL. If it is not NULL, it frees the memory using the ""sk_pop_free"" function with the ""by_dir_hash_free"" function as the second argument. Finally, it frees the memory pointed to by ""param_1"" using the ""CRYPTO_free"" function."
openssl-101u,O0,x86,cswift_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O0_extraction/cswift_rand_bytes@0819edc0.c,"The function uses CryptoSwift to generate random bytes, taking in an array of 32-bit integers and the number of bytes to generate as parameters. It acquires an access context and generates random bytes in chunks of 1024 bytes until the remaining number of bytes is less than or equal to 1024. It then generates the remaining bytes and stores them in the input array. If any errors occur, it sets an error code and returns 0. If successful, it returns 1."
openssl-101u,O0,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_x86_gcc_O0_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9f40.c,"The function takes in three parameters: a pointer to an ASN1_VALUE object (param_1), a double pointer to a uchar object (param_2), and a long integer (param_3). It then calls the ASN1_item_d2i function, passing in the three parameters and a pointer to an ASN1_ITEM object representing the GOST_CLIENT_KEY_EXCHANGE_PARAMS type. This function decodes the binary data pointed to by param_2 into an ASN1_VALUE object of the type specified by the ASN1_ITEM object. The function returns without any explicit return value."
openssl-101u,O0,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_x86_gcc_O0_extraction/d2i_GOST_KEY_PARAMS@081d9e40.c,"The function takes in three parameters: a double pointer to an ASN1_VALUE, a double pointer to an unsigned character array, and a long integer. It uses the ASN1_item_d2i() function to decode the GOST_KEY_PARAMS_it ASN1_ITEM from the uchar array pointed to by the second parameter, and store the decoded data in the ASN1_VALUE pointed to by the first parameter. The function does not return anything."
openssl-101u,O0,x86,decode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O0_extraction/decode_gost_algor_params@081d79d0.c,"The function decodes GOST algorithm parameters from an X509_ALGOR structure and sets them in an EVP_PKEY structure. It determines the type of key (EC or DSA) based on the algorithm OID and sets the EVP_PKEY type accordingly. If the key is an EC key, it creates a new EC_KEY object and fills it with the GOST2001 parameters. If the key is a DSA key, it creates a new DSA object and fills it with the GOST94 parameters. If any errors occur during the decoding process, the function returns 0. Otherwise, it returns 1."
openssl-101u,O0,x86,DES_xcbc_encrypt,./data/decomp/openssl-101u_x86_gcc_O0_extraction/DES_xcbc_encrypt@081de220.c,"The two functions implement encryption using the DES block cipher. The first function uses the DES-XCBC algorithm to provide message authentication, while the second function uses the CBC mode to encrypt the input message. Both functions take in a key, an initialization vector, and an input buffer, and output the encrypted message. The length of the message is specified as a parameter in the first function, while the second function pads any remaining bytes in the input buffer with zeros. The first function also generates a key for the message authentication code using the parameters ""inw"" and ""outw""."
openssl-101u,O0,x86,dgram_ctrl,./data/decomp/openssl-101u_x86_gcc_O0_extraction/dgram_ctrl@0811e8c0.c,"The first function, `dgram_ctrl`, takes four parameters: an integer `param_1`, an undefined 4-byte value `param_2`, a size_t value `param_3`, and a pointer to an undefined 4-byte value `param_4`. The function performs various actions related to socket options depending on the value of `param_2`.

The second function takes four parameters: a pointer to a structure, an operation code, a pointer to a source buffer, and a pointer to a destination buffer. The function checks if the operation code is valid and performs the corresponding operation on the source buffer, storing the result in the destination buffer."
openssl-101u,O0,x86,dlfcn_bind_func,./data/decomp/openssl-101u_x86_gcc_O0_extraction/dlfcn_bind_func@081e4600.c,"The function takes in two integer parameters, param_1 and param_2. It first checks if either of the parameters are equal to zero, and if so, sets the variable iVar1 to 0x43 and line to 0x109. Otherwise, it checks the number of values in a stack located at the memory address stored in param_1+4. If the number of values is less than 1, it sets iVar1 to 0x69 and line to 0x10d. If there is at least one value in the stack, it retrieves the last value and attempts to find a symbol with the name stored in param_2 using the dlsym function. If dlsym returns a non-zero value, the function returns that value. If dlsym returns zero, the function sets an error message using the ERR_put_error and ERR_add_error_data functions, and returns 0."
openssl-101u,O0,x86,dlfcn_bind_var,./data/decomp/openssl-101u_x86_gcc_O0_extraction/dlfcn_bind_var@081e4700.c,"The function takes in two parameters, param_1 and param_2. It checks if either of the parameters are equal to 0, and if so, it sets the variable ""line"" to 0xeb and returns the integer value 0x43. If both parameters are non-zero, it retrieves the number of elements in a stack stored at the memory address pointed to by (param_1 + 4). If the number of elements is less than 1, it sets the variable ""line"" to 0xef and returns the integer value 0x69. If the number of elements is greater than or equal to 1, it retrieves the last element in the stack and attempts to find a symbol with the name specified by param_2 within the library pointed to by the retrieved element. If the symbol is found, it returns the integer value of the symbol. If the symbol is not found, it sets the variable ""line"" to 0xf9, adds."
openssl-101u,O0,x86,dlfcn_globallookup,./data/decomp/openssl-101u_x86_gcc_O0_extraction/dlfcn_globallookup@081e4320.c,"The function takes in an argument of type undefined4 and returns an undefined4 value. It calls the dlopen function with arguments 0 and 1 to open the dynamic library specified by the filename 0 with the RTLD_LAZY flag. If dlopen fails to open the library, the function returns 0. If dlopen is successful, the function then calls dlsym with the handle returned by dlopen and the symbol name specified by the argument param_1. This function returns a pointer to the symbol if it is found in the library, or NULL if it is not found. The function then calls dlclose with the handle returned by dlopen to close the library, regardless of whether dlsym was successful or not. Finally, the function returns the value returned by dlsym (i.e., a pointer to the symbol or NULL). Overall, this function is a wrapper for the dlsym function."
openssl-101u,O0,x86,doapr_outch.constprop.0,./data/decomp/openssl-101u_x86_gcc_O0_extraction/doapr_outch.constprop.0@0811a260.c,"The function takes four parameters, two of which are pointers to pointers, and two of which are pointers to unsigned integers. It first checks if the second parameter is NULL or if the value pointed to by the third parameter is not equal to the value pointed to by the fourth parameter. If either of these conditions is true, the function jumps to a label and checks if the value pointed to by the fourth parameter is less than or equal to the value pointed to by the third parameter. If it is, the function returns 1. If not, the function checks if the value pointed to by the first parameter is NULL. If it is, the function returns 0. If the second parameter is not NULL and the value pointed to by the third parameter is equal to the value pointed to by the fourth parameter, the function checks if the value pointed to by the third parameter is greater than 0x7ffffbff. If it is, the function returns 0. Otherwise, the"
openssl-101u,O0,x86,dtls1_link_min_mtu,./data/decomp/openssl-101u_x86_gcc_O0_extraction/dtls1_link_min_mtu@080bb4c0.c,"The function dtls1_link_min_mtu returns a value of 0x100, which is 256 in decimal and is likely the minimum MTU for a DTLS link."
openssl-101u,O0,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_mont_field_encode@081e2b20.c,"The function takes four parameters: an integer, a pointer to a BIGNUM structure (param_2), a pointer to another BIGNUM structure (param_3), and a BN_CTX structure (param_4). It retrieves a BN_MONT_CTX pointer from the integer parameter's offset +0xa0. If the pointer is not null, the function performs modular multiplication of param_2 and param_3 using the BN_mod_mul_montgomery function with the montgomery multiplication context, RR, from the BN_MONT_CTX structure. The result is stored in param_2. If the BN_MONT_CTX pointer is null, the function generates an error using the ERR_put_error function and returns 0."
openssl-101u,O0,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_mont_field_sqr@081e2ac0.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. If the BN_MONT_CTX pointer stored at offset 0xa0 of the integer parameter is not NULL, the function computes the square of the second BIGNUM parameter using Montgomery multiplication with the third BIGNUM parameter and the BN_MONT_CTX pointer. The result is stored in the first BIGNUM parameter. The function returns the result of the multiplication. If the BN_MONT_CTX pointer is NULL, the function generates an error using the ERR_put_error function and returns 0."
openssl-101u,O0,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_mont_group_init@081e26d0.c,"The `ec_GFp_mont_group_init` function initializes a Montgomery elliptic curve group by calling `ec_GFp_simple_group_init` to initialize the group as a simple elliptic curve group. It sets two additional parameters to zero that are specific to Montgomery curves and used in group operations, and then returns."
openssl-101u,O0,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_nist_field_mul@081e2e50.c,"The function takes four parameters: an integer, two BIGNUM pointers, and a BN_CTX pointer. It returns a boolean value. The function first checks if any of the input parameters are NULL. If so, it logs an error message using the ERR_put_error function. If the BN_CTX pointer is NULL, the function creates a new BN_CTX object using the BN_CTX_new function. It then multiplies the second and third BIGNUMs together using the BN_mul function and stores the result in the first BIGNUM. It then reduces the result modulo a specific value using a function pointer stored in the integer parameter. Finally, it frees the BN_CTX object and returns a boolean value indicating whether the multiplication and reduction were successful. If the BN_CTX pointer is not NULL, the function simply multiplies the second and third BIGNUMs together using the BN_mul function and stores the result in the first BIGNUM. It then reduces the result modulo a specific value using a function pointer."
openssl-101u,O0,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_nist_group_copy@081e2c50.c,The `ec_GFp_nist_group_copy` function copies the value at offset 0xa8 from the second elliptic curve group structure to the same offset in the first structure. It then calls `ec_GFp_simple_group_copy` to copy the rest of the data. The function does not return any explicit value.
openssl-101u,O0,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_nist_group_set_curve@081e2c70.c,"The function `ec_GFp_nist_group_set_curve` sets the curve parameters for a group of elliptic curve points. It takes in five parameters: an integer, a BIGNUM pointer, and three undefined 4-byte values. If the fifth parameter, `param_5`, is null, it creates a new BN_CTX object and starts it. If `param_5` is not null, it starts a new BN_CTX object. It then gets the NIST prime number for curves of size 192, 224, 256, 384, and 521 bits, and compares it with the second parameter, `param_2`, which is the curve modulus. If `param_2` is equal to one of the NIST primes, the function sets a function pointer to the corresponding NIST modulus function and calls `ec_GFp_simple_group_set_curve` to set the curve parameters. If `param_2` is not equal to any of the NIST primes, the function does not set the curve parameters."
openssl-101u,O0,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e77c0.c,"The function takes in six parameters: an integer pointer, an integer, and four BIGNUM pointers. It returns a boolean value. The function first checks if a certain integer value (stored at an offset of the integer pointer) is equal to zero. If it is, it checks if the three BIGNUM pointers (param_3, param_4, and param_5) are null or not. If any of them are not null, it copies the corresponding BIGNUM value from the input integer array to the corresponding output BIGNUM pointer and returns true. If all three output BIGNUM pointers are null, it returns true. If the integer value is not zero, it creates a BN_CTX object if the input BN_CTX pointer is null. It then calls a function pointer stored in the integer array (at an offset of 0x94) with the input integer array, the output BIGNUM pointer, and the corresponding input BIGNUM pointer as arguments."
openssl-101u,O0,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_group_check_discriminant@081e7990.c,"The function `ec_GFp_simple_group_check_discriminant` checks if the discriminant of a given elliptic curve over a finite field is non-zero. It takes two arguments: an integer pointer `param_1` which contains information about the elliptic curve, and a `BN_CTX` pointer `param_2` which is used for temporary storage during calculations. The function first initializes a `BN_CTX` if `param_2` is null. It then allocates five `BIGNUM` variables using `BN_CTX_get` for temporary storage. If the elliptic curve's `a` and `a_00` coefficients are already present in `param_1`, they are copied to the `BIGNUM` variables `a` and `a_00` respectively. Otherwise, the function calls the appropriate function pointer (if present) to compute `a` and `a_00` from `param_1`. Next, the function checks if either `a` or `a_00` is zero, and returns an error code if so."
openssl-101u,O0,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_group_clear_finish@081e7420.c,"The `ec_GFp_simple_group_clear_finish` function takes an integer parameter, likely a pointer to an elliptic curve group structure, and frees three BIGNUM variables within the structure representing parameters of the elliptic curve group. The function does not return any value."
openssl-101u,O0,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_group_copy@081e8570.c,"The function copies BIGNUM values, order, and cofactor from one elliptic curve group to another, both represented by integer pointers to structures. It returns 1 if the copy operation is successful and 0 otherwise."
openssl-101u,O0,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_group_get_degree@081e7490.c,"The function takes a single integer parameter representing an elliptic curve group and calls the OpenSSL library function BN_num_bits() on a BIGNUM object located at an offset of 0x48 bytes from the start of the structure. This function calculates the number of bits in the BIGNUM object, which represents the order of the group. The result is not returned or stored anywhere, indicating that this function is used for informational purposes only."
openssl-101u,O0,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_group_set_curve@081e8660.c,"The function sets parameters for an elliptic curve over a finite field using four large integers as input. It checks that the modulus is valid, creates a BN_CTX object if one is not provided, and computes the remainder of the second parameter modulo the modulus. It also allocates temporary storage for two BIGNUMs and sets the sign of the modulus to positive. There is an optional function pointer stored."
openssl-101u,O0,x86,ec_GFp_simple_invert,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_invert@081e9390.c,"The function takes in an EC_GROUP pointer and an EC_POINT pointer. It checks if the point is at infinity or has a zero z-coordinate. If the point is not at infinity and has a non-zero z-coordinate, it calculates the inverse of the point using a BN_usub() function call and returns the result. If the point is at infinity or has a zero z-coordinate, it returns 1 indicating that the inverse does not exist."
openssl-101u,O0,x86,EC_GFp_simple_method,./data/decomp/openssl-101u_x86_gcc_O0_extraction/EC_GFp_simple_method@081e9ed0.c,"The function returns a pointer to an EC_METHOD object from an external library or header file. It has no input parameters, and the warning message suggests it may use an unrecognized calling convention and have additional parameters not visible in the decompiled code."
openssl-101u,O0,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_point_copy@081e85f0.c,"The function takes in two parameters, param_1 and param_2, which are pointers to structures containing BIGNUM values. The function copies the BIGNUM values stored at offsets 4, 0x18, and 0x2c in the structure pointed to by param_2 to the structure pointed to by param_1 at the same offsets. It also copies the 4-byte value stored at offset 0x40 in the structure pointed to by param_2 to the same offset in the structure pointed to by param_1. The function returns 1 if all copy operations are successful and 0 otherwise."
openssl-101u,O0,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_point_finish@081e73f0.c,"The function takes an integer parameter (param_1) which is assumed to be a pointer to a structure representing an elliptic curve point in the GF(p) field. It frees the memory allocated for the x-coordinate, y-coordinate, and z-coordinate of the point using the BN_free() function from OpenSSL's BIGNUM library. This function is responsible for freeing the memory allocated for an elliptic curve point in the GF(p) field."
openssl-101u,O0,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7c00.c,"The function takes an EC_POINT and EC_GROUP structure along with BN_CTX and BIGNUM structures for temporary and output storage. It checks if the point is at infinity and returns false if it is. If a BN_CTX structure is not provided, the function creates one and allocates four BIGNUM structures for temporary storage. It then computes the x-coordinate of the input point using the elliptic curve group's point multiplication function, if defined. If the x-coordinate is not equal to 1, it computes the inverse of the x-coordinate modulo the order of the curve, and uses it to compute the y-coordinate of the input point using the curve equation. If the curve does not have a point multiplication function defined, the function uses a pre-defined function to compute the x-coordinate of the input."
openssl-101u,O0,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O0_extraction/ec_GFp_simple_point_set_affine_coordinates@081e88d0.c,"The function sets the affine coordinates of an elliptic curve point on a given curve. It takes in as parameters a pointer to the curve group, a pointer to the point whose coordinates are to be set, the x-coordinate and y-coordinate of the point, and a BN_CTX structure for temporary storage during the computation. The function checks if both the x and y coordinates are not NULL. If either of them is NULL, it sets an error and returns 0. If both coordinates are non-NULL, the function creates a BIGNUM object z and sets its value to 1. Then, it calls the EC_POINT_set_Jprojective_coordinates_GFp function to set the point's coordinates in Jacobian projective form using the x and y coordinates and the value of z. This function returns an integer value, which is returned by the ec_GFp."
openssl-101u,O0,x86,encode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O0_extraction/encode_gost_algor_params@081d8c50.c,"The function takes an EVP_PKEY pointer as input and returns an ASN1_STRING pointer as output. It encodes the GOST algorithm parameters for the given key and returns it as an ASN1_STRING. First, it creates a new ASN1_STRING object and a GOST_KEY_PARAMS object using the GOST_KEY_PARAMS_new() function. If either of these objects cannot be created, it sets an error code and returns a null pointer. Next, it determines the type of key using EVP_PKEY_base_id(). If the key is an EC key, it gets the curve name using EC_GROUP_get_curve_name(). If the key is a R3410 key, it gets the parameter set using EVP_PKEY_get0() and compares it with the pre-defined parameter sets in R3410_paramset. If a parameter set is found, it sets the corresponding object identifier (OID) in the GOST_KEY_PARAMS object. It then sets the OID for the digest algorithm (0x336) in."
openssl-101u,O0,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_x86_gcc_O0_extraction/general_allocate_boolean.constprop.5@08187cc0.c,"The function ""general_allocate_boolean_constprop_5"" takes in two character pointers, an integer, and three more integers. It checks if the first character pointer is NULL and returns an error code of 0xc4 if it is. If the first character pointer is not NULL, it checks if the second character pointer is also not NULL and returns an error code of 0xc6 if it is NULL. If both character pointers are not NULL, the function loops through each character of the first character pointer and checks if it is present in the second character pointer. If it is, the function returns an error code of 0x6c. If the second character pointer is not empty and no characters from the first character pointer are present in it, the function checks if the fifth parameter is not zero. If it is zero, the function returns an error code of 0x6d."
openssl-101u,O0,x86,get_gost_engine_param,./data/decomp/openssl-101u_x86_gcc_O0_extraction/get_gost_engine_param@081db600.c,"The function takes an integer parameter ""param_1"". If ""param_1"" is not zero, it returns null. If ""gost_params"" is null, the function retrieves the value of ""CRYPT_PARAMS"" using getenv(). If ""CRYPT_PARAMS"" is null, the function returns null. Otherwise, it allocates memory for the string using BUF_strdup() and assigns it to ""gost_params"". The function returns the value of ""gost_params""."
openssl-101u,O0,x86,gost2001_param_encode,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost2001_param_encode@081d7f80.c,"The function extracts the EC_GROUP object associated with an EVP_PKEY object assumed to contain an EC_KEY object. It retrieves the curve name of the group and uses it to get an ASN1_OBJECT object, which is encoded into a byte string using i2d_ASN1_OBJECT. The resulting byte string is stored in the memory location pointed to by the param_2 argument."
openssl-101u,O0,x86,gost_cipher_cleanup,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost_cipher_cleanup@081da1a0.c,"The function cleans up resources allocated for the GOST cipher algorithm by calling `gost_destroy` to free memory, setting a value to zero, and returning 1 to indicate success."
openssl-101u,O0,x86,gost_cipher_ctl,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost_cipher_ctl@081da6f0.c,"The function `gost_cipher_ctl` takes four parameters: an integer `param_1`, an integer `param_2`, an undefined 4-byte value `param_3`, and a pointer to an array of undefined 4-byte values `param_4`. If `param_2` is equal to 6, the function calls the `RAND_bytes` function to generate random bytes and stores them in the memory location pointed to by `param_4`. If the call to `RAND_bytes` is successful, the function returns 1. Otherwise, it calls the `ERR_GOST_error` function and returns -1. If `param_2` is equal to 7, the function checks if `param_4` is not equal to NULL. If it is not NULL, it sets the value pointed to by `param_4` to 0x32a and returns 1. Otherwise, it returns 0. If `param_2` is neither, the function's behavior is undefined."
openssl-101u,O0,x86,gost_cipher_do_cnt,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost_cipher_do_cnt@081da310.c,"The function `gost_cipher_do_cnt` is a part of the GOST block cipher algorithm implementation. It takes four parameters - an integer `param_1`, two byte arrays `param_2` and `param_3`, and an unsigned integer `param_4`. The function checks if the value of the integer stored at the address `param_1 + 0x50` is zero. If it is, it sets the variable `local_20` to 8 and `uVar4` to 0. Otherwise, if the value is less than 8 and the `param_4` is not zero, it XORs the bytes in `param_3` with the bytes in `param_1 + 0x30` and stores the result in `param_2`. It repeats this process until it has XORed all the bytes or until 7 bytes have been XORed. If 8 bytes have been XORed, it sets the variable."
openssl-101u,O0,x86,gost_cipher_init,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost_cipher_init@081db320.c,"The function initializes the GOST cipher context with cipher parameters and engine, sets an IV and key if provided, and returns 1 for success."
openssl-101u,O0,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O0_extraction/GOST_CIPHER_PARAMS_new@081d9f00.c,The function creates a new instance of the GOST_CIPHER_PARAMS data structure using the ASN1_item_new function with the GOST_CIPHER_PARAMS_it parameter. It does not return a value (void).
openssl-101u,O0,x86,gost_imit_final,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost_imit_final@081dafc0.c,"The function `gost_imit_final` takes two parameters, an integer `param_1` and an undefined value `param_2`. It retrieves two integer values `iVar1` and `iVar2` from memory addresses `param_1 + 0xc` and `iVar1 + 0x103c`, respectively. If `iVar2` is zero, the function calls `ERR_GOST_error` with error code `0x8c` and error message ""gost_crypt.c"" at line number `0x239` and jumps to `LAB_081db01a`. Otherwise, if the integer value at memory address `iVar1 + 0x1030` is zero and the integer value at memory address `iVar1 + 0x1038` is not zero, the function sets the values of `local_28` and `local_24` to zero and calls the `gost` function."
openssl-101u,O0,x86,gost_imit_init_cpa,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost_imit_init_cpa@081da680.c,"The function initializes the GOST 28147-89 cipher in the CPA mode by setting fields to zero and one, and calling gost_init with CryptoProParamSetA. It takes an integer parameter and returns 1 to indicate success."
openssl-101u,O0,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O0_extraction/GOST_KEY_PARAMS_new@081d9e80.c,The function creates a new instance of the GOST_KEY_PARAMS structure using ASN1_item_new with GOST_KEY_PARAMS_it parameter and returns without any further actions.
openssl-101u,O0,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_x86_gcc_O0_extraction/GOST_KEY_TRANSPORT_free@081d9d20.c,The function frees the memory allocated to a GOST key transport object represented by an ASN1_VALUE pointer using the GOST_KEY_TRANSPORT_it ASN1_ITEM type as a parameter. It returns without any value and is used to release memory when GOST key transport objects are no longer needed.
openssl-101u,O0,x86,gost_param_free,./data/decomp/openssl-101u_x86_gcc_O0_extraction/gost_param_free@081db560.c,"The ""gost_param_free"" function checks if ""gost_params"" is not NULL, frees the allocated memory using ""CRYPTO_free"", sets ""gost_params"" to NULL, and returns without value. It is used to release memory used by GOST parameters when they are no longer needed."
openssl-101u,O0,x86,hash_step,./data/decomp/openssl-101u_x86_gcc_O0_extraction/hash_step@081db6d0.c,"The first three function summaries describe a function that performs some kind of encryption/decryption using the GOST cipher. The function takes in parameters, initializes local variables, performs bitwise operations and XORs on the variables, calls the `gost_enc_with_key` function multiple times with different parameters, and updates the input parameters with the final values of the copied variables.

The fourth function summary describes a function that takes in two parameters and checks if the length of the first parameter is greater than or equal to 4. If it is, the function extracts the first 4 bytes of the first parameter and checks if it is equal to a constant value of 0x12345678. If it is, the function extracts the next 4 bytes of the first parameter and checks if it is equal to the length of the second parameter. If it is, the function returns 0."
openssl-101u,O0,x86,hwcrhk_init,./data/decomp/openssl-101u_x86_gcc_O0_extraction/hwcrhk_init@081a16a0.c,"The function initializes the hardware crypto hook library, sets up mutex callbacks if not disabled, and returns 1 with a global variable indicating the index for the RSA key handle if successful. If unsuccessful, it sets an error code and returns 0. Finally, it cleans up by freeing the library and resetting all function pointers to null."
openssl-101u,O0,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_x86_gcc_O0_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9de0.c,The i2d_GOST_KEY_AGREEMENT_INFO function takes an ASN1_VALUE parameter and a uchar** parameter. It encodes the ASN1_VALUE structure into a binary format using the ASN1_item_i2d function and the GOST_KEY_AGREEMENT_INFO_it ASN1_ITEM. The resulting binary format is stored in the memory pointed to by the uchar** parameter. The function does not return a value.
openssl-101u,O0,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_x86_gcc_O0_extraction/i2d_GOST_KEY_TRANSPORT@081d9ce0.c,"The function encodes a GOST key transport object into a binary format using ASN1_item_i2d() and stores it in a memory location pointed to by a double pointer to an unsigned character. It takes two parameters: a pointer to the ASN1_VALUE structure representing the GOST key transport object, and a double pointer to an unsigned character. The function does not return any value."
openssl-101u,O0,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101u_x86_gcc_O0_extraction/load_pkcs12.constprop.4@0807a4c0.c,"The function `load_pkcs12_constprop_4` takes in several parameters including two `BIO` pointers, a string, a function pointer, and two double pointers to `EVP_PKEY` and `X509` structures. It first reads in a PKCS12 file using `d2i_PKCS12_bio()` and checks if it was successfully loaded. If not, it prints an error message and returns 0. If the PKCS12 file was loaded successfully, the function verifies the MAC using `PKCS12_verify_mac()`. If the MAC verification fails, it prompts the user for a password using the provided `password_callback` function pointer (or a default function if none was provided). It then attempts to verify the MAC again using the entered password. If the MAC verification still fails, it prints an error message and returns 0. If the MAC verification succeeds, the function parses the PKCS12 file using `PKCS12_parse()` and stores the data."
openssl-101u,O0,x86,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_x86_gcc_O0_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@080f1a40.c,"The function takes in a BIGNUM pointer, an integer, a uint pointer, another integer, and another integer as parameters. It first checks if the BIGNUM's dmax value is less than the second integer parameter, and if so, it expands the BIGNUM to accommodate the new size. If it cannot expand the BIGNUM, it returns 0. The function then sets a variable uVar9 to 1 shifted left by the second integer parameter modulo 32. If the second integer parameter is less than 4, the function enters a loop that copies values from the uint pointer to the BIGNUM's d array, with each value being shifted by uVar9 bits. If the second integer parameter is greater than or equal to 4, the function enters another loop that copies values from the uint pointer to the BIGNUM's d array, with each value being a combination of four values from the uint pointer that are shifted by different amounts based on the position."
openssl-101u,O0,x86,padlock_init,./data/decomp/openssl-101u_x86_gcc_O0_extraction/padlock_init@081a8550.c,"The ""padlock_init"" function checks if ""padlock_use_rng"" or ""padlock_use_ace"" is not equal to zero and returns a boolean value accordingly. It is used to verify if the components required for the padlock encryption/decryption algorithm are present."
openssl-101u,O0,x86,padlock_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O0_extraction/padlock_rand_bytes@081a7660.c,"The function padlock_rand_bytes takes a pointer to an undefined data type and an integer value as parameters and returns an undefined 4-byte value. It checks if the integer value is less than 8 and generates random bytes and stores them in the memory location pointed to by the first parameter until it has generated the requested number of bytes. If the integer value is greater than or equal to 8, it checks if there is enough space in the memory location pointed to by the first parameter to store 8 bytes. If there is not enough space, it returns 0. The function uses the xstore_available function to check if there is enough space in the memory location to store the requested number of bytes and also checks if the current thread's stack has been corrupted by comparing the."
openssl-101u,O0,x86,param_copy_gost94,./data/decomp/openssl-101u_x86_gcc_O0_extraction/param_copy_gost94@081d82c0.c,"The function takes in two EVP_PKEY pointers as parameters, param_1 and param_2. It retrieves the DSA key from param_1 and the parameters from param_2. The function checks if the base id of param_1 matches that of param_2. If they match, it checks if the parameters in param_2 are not NULL. If they are NULL, it raises an error. If the parameters are not NULL, the function assigns a new DSA key to param_1 if it is NULL. It then copies the parameters from param_2 to the corresponding fields in the DSA key in param_1. If the DSA key in param_1 already has values in its fields, those values are freed and replaced with the new values from param_2. Finally, if the private key in the DSA key in param_1 is non-zero, the public key is computed using the new parameters."
openssl-101u,O0,x86,param_print_gost01,./data/decomp/openssl-101u_x86_gcc_O0_extraction/param_print_gost01@081d86e0.c,"This function takes in a BIO object, an EVP_PKEY object, and an integer value. It extracts the EC_KEY object from the EVP_PKEY object and retrieves the EC_GROUP object associated with the key. It then indents the output in the BIO object by the number of spaces specified by the 'param_3' parameter, and checks if the indentation was successful. If it was, it retrieves the name of the curve using the 'OBJ_nid2ln' function and prints it to the BIO object along with a message indicating that it is the parameter set. Finally, the function returns 1 if the indentation was successful, indicating that the output was printed to the BIO object. Otherwise, it returns 0."
openssl-101u,O0,x86,param_print_gost94,./data/decomp/openssl-101u_x86_gcc_O0_extraction/param_print_gost94@081d8750.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer value and returns an undefined value. Within the function, it initializes a BIGNUM object using BN_new() and compares its value with a list of predefined parameter sets stored in the R3410_paramset structure. If a match is found, the corresponding parameter set identifier is stored in a variable. The function then prints the parameter set identifier to the BIO object using the BIO_indent(), OBJ_nid2ln(), and BIO_printf() functions. Finally, the function checks if a variable value matches the value stored in the GS register offset by 0x14."
openssl-101u,O0,x86,pkey_ctrl_gost,./data/decomp/openssl-101u_x86_gcc_O0_extraction/pkey_ctrl_gost@081d90e0.c,"The function `pkey_ctrl_gost` takes four parameters: an EVP_PKEY object, an integer, another integer, and a PKCS7_SIGNER_INFO object. The function performs different actions based on the value of the second parameter. If the value is not expected, an error code is returned. If the value is 1, the function extracts algorithm information from the fourth parameter and sets the values of two variables accordingly. It then sets the algorithm identifier for GOST R 34.10-2001 signature algorithm and the algorithm identifier for the key exchange algorithm."
openssl-101u,O0,x86,pkey_free_gost94,./data/decomp/openssl-101u_x86_gcc_O0_extraction/pkey_free_gost94@081d86c0.c,"The function takes an integer parameter called ""param_1"" and checks if the value stored at the memory address ""param_1 + 0x14"" (which is a pointer to a DSA structure) is not equal to NULL. If it is not NULL, the function calls DSA_free() to free the memory allocated to the DSA structure. If the pointer is NULL, the function simply returns."
openssl-101u,O0,x86,priv_encode_gost,./data/decomp/openssl-101u_x86_gcc_O0_extraction/priv_encode_gost@081d9420.c,"The function takes in a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure, and returns an integer value. It gets the base ID of the EVP_PKEY structure and converts it to an ASN1_OBJECT using the OBJ_nid2obj() function. It calls the encode_gost_algor_params() function to get the parameters for the GOST algorithm. If the parameters are successfully obtained, the function checks the base ID of the EVP_PKEY structure again. If it is 0x32b, it gets the private key from the EC_KEY structure using EC_KEY_get0_private_key() function. If it is 0x32c, it gets the private key from the BIGNUM structure using EVP_PKEY_get0() function. Then, it converts the private key to an ASN1_INTEGER using the BN_to_ASN1_INTEGER() function and encodes it using the i2d_ASN1_INTEGER() function."
openssl-101u,O0,x86,pub_encode_gost94,./data/decomp/openssl-101u_x86_gcc_O0_extraction/pub_encode_gost94@081d92d0.c,"The function takes in an X509_PUBKEY and an EVP_PKEY as parameters. It retrieves the public key from the EVP_PKEY, converts it to binary format, and stores it in the X509_PUBKEY object. It also retrieves the object identifier (OID) of the algorithm used to generate the key and stores it in the X509_PUBKEY object. If the save_parameters flag of the EVP_PKEY is set, it encodes the algorithm parameters using the encode_gost_algor_params() function and stores them in the X509_PUBKEY object. The function creates an ASN1_OCTET_STRING object containing the little-endian public key, serializes it to a byte array, and stores it in the X509_PUBKEY object."
openssl-101u,O0,x86,pub_print_gost94,./data/decomp/openssl-101u_x86_gcc_O0_extraction/pub_print_gost94@081d8840.c,"This function retrieves and prints the public key from an EVP_PKEY object, compares it to predefined parameter sets in the R3410_paramset structure, prints the parameter set if a match is found, and returns 1."
openssl-101u,O0,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O0_extraction/RSA_padding_add_PKCS1_PSS@081e3950.c,"1. The RSA_padding_add_PKCS1_PSS function adds padding to a message for RSA encryption using the PKCS1 PSS scheme. It takes in an RSA key, a message hash, an EVP_MD object representing the hash algorithm used, and the length of the salt to be used in the padding. The function determines the size of the hash output and checks if the salt length is valid. If the salt length is -2, the function generates a random salt and initializes an EVP_MD_CTX object to compute the hash of the message and salt. Otherwise, if the salt length is specified, the function initializes the EVP_MD_CTX object and computes the hash of the message and salt. The function then generates a mask for the salt using the PKCS1 MGF1 function and XORs it with the salt. It then sets the necessary bits for the padding and returns the padded message. If any errors occur during the padding process, the function returns an error code.

2. The function takes in a pointer to a structure and an integer value. It then checks if the integer value is greater than or equal to a value stored in the structure at a specific offset. If it is, the function calls the ""__stack_chk_fail"" function, which terminates the program with an error message. If the integer value is less than the value in the structure, the function returns the integer value."
openssl-101u,O0,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O0_extraction/RSA_verify_PKCS1_PSS@081e3030.c,"The function RSA_verify_PKCS1_PSS is used to verify a message signature using the RSA-PSS algorithm. It takes as input an RSA key, a message hash, a hash function, a signature, and the length of the signature. The function initializes an EVP_MD_CTX structure to hold the context for the message digest operation, checks the size of the hash function output, and calculates the size of the RSA key and padding bits to verify the signature. It generates a mask using PKCS1_MGF1, XORs the mask with the signature to recover the original message digest, and checks the validity of the recovered message digest by comparing it with the input message hash."
openssl-101u,O0,x86,sha_block_data_order,./data/decomp/openssl-101u_x86_gcc_O0_extraction/sha_block_data_order@081dcdc0.c,"The following functions implement the SHA-1 hashing algorithm to process a block of data. They take in a message as input and produce a fixed-size 160-bit hash value as output. Each function processes the input message in blocks of 512 bits using a series of logical and arithmetic operations. The final hash value is stored in an output buffer or returned as a 20-byte array. The functions are designed to produce a secure and collision-resistant hash value for a given message. Additionally, there is a function that takes in a character array and an integer, and returns the length of the string represented by the character array."
openssl-101u,O0,x86,SHA_Final,./data/decomp/openssl-101u_x86_gcc_O0_extraction/SHA_Final@081de090.c,"The function takes in a pointer to an array of unsigned characters (md) and a pointer to a SHA_CTX structure (c). It returns an integer value of 1. The function declares local variables, retrieves values from the SHA_CTX structure, sets a byte in the data field to 0x80, and checks a condition based on the retrieved value."
openssl-101u,O0,x86,srp_verify_server_param,./data/decomp/openssl-101u_x86_gcc_O0_extraction/srp_verify_server_param@080cee70.c,"The function takes in an integer and a pointer to an undefined 4-byte variable. It compares two BIGNUM variables located at specific offsets in the integer parameter. If certain conditions are met, it sets the undefined variable to 0x2f and returns 0. If not, it compares the number of bits in the second BIGNUM to an integer located at a specific offset in the integer parameter. If the number of bits is less than this integer value, it sets the undefined variable to 0x47 and returns 0. If neither of the above conditions are met, it checks if a specific code pointer in the integer parameter is null. If it is null, the function..."
openssl-101u,O0,x86,SSLv23_method,./data/decomp/openssl-101u_x86_gcc_O0_extraction/SSLv23_method@080a84e0.c,"The SSLv23_method function returns a pointer to an SSL_METHOD structure in OpenSSL. It uses the SSLv23_method_data_15764 variable and may be implemented in a low-level language. The function does not follow a standard calling convention and has locked parameter storage, indicating it is not designed to accept parameters."
openssl-101u,O0,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_x86_gcc_O0_extraction/SSL_SESSION_free.part.2@080c3230.c,"The function frees memory allocated for an SSL session. It first frees any extended data associated with the session and securely erases certain parts of the memory. It then frees any associated certificates and SSL_CIPHER objects, as well as any other memory associated with the session. The entire memory block is securely erased before being freed."
openssl-101u,O0,x86,start_hash,./data/decomp/openssl-101u_x86_gcc_O0_extraction/start_hash@081dc670.c,"The function takes in a pointer to an array of 32-bit integers as its parameter. If the third element of the array is not equal to zero, it initializes the array by setting certain elements to zero. It sets the fifth and eleventh elements to zero, followed by a series of consecutive elements starting from the sixth element until the end of the block of memory allocated for the array. The size of this block is determined by subtracting the address of the fifth element from the address of the parameter, adding 0x30, and rounding down to the nearest multiple of 4. It then sets the twelfth and nineteenth elements to zero, followed by a series of consecutive elements starting from the thirteenth element until the end of the block of memory allocated for the array."
openssl-101u,O0,x86,surewarehk_finish,./data/decomp/openssl-101u_x86_gcc_O0_extraction/surewarehk_finish@081a36a0.c,"The function checks if the surewarehk_dso variable is null. If it is, sets the SUREWARE_lib_error_code and line variables to specific values and sets iVar1 to 0x70. If surewarehk_dso is not null, calls the p_surewarehk_Finish function, sets uVar2 to 1, and frees the surewarehk_dso variable. If DSO_free returns a non-zero value, sets the SUREWARE_lib_error_code and line variables to specific values and sets iVar1 to 0x68. Sets uVar2 to 0 and calls ERR_put_error with the SUREWARE_lib_error_code, 0x67, iVar1, ""e_sureware.c"", and line as arguments. Frees the logstream variable and sets all the p_surewarehk_* function pointers to null. Returns uVar2."
openssl-101u,O0,x86,sv_body,./data/decomp/openssl-101u_x86_gcc_O0_extraction/sv_body@08068440.c,"The functions handle SSL connections. 

`sv_body` is a server program that accepts SSL/TLS connections from clients. It initializes the SSL library and loads certificates, creates a socket and binds it to a port, listens for incoming connections on the socket, accepts connections and initiates SSL handshake, loops to read and write data, handles client commands, and closes the connection if there is an error or a shutdown command is received. 

The decompiled function takes a socket file descriptor and an SSL context as parameters, sets up an SSL connection with the client using the SSL_accept function, reads and writes data using SSL_read and SSL_write, checks for pending data using SSL_pending, handles SSL errors using ERR_print_errors, and cleans up memory before returning success or failure."
openssl-101u,O0,x86,TLSv1_method,./data/decomp/openssl-101u_x86_gcc_O0_extraction/TLSv1_method@080aa220.c,"The function returns a pointer to an SSL_METHOD structure representing the TLSv1 protocol. It obtains the pointer by casting the address of a global variable named TLSv1_method_data_15770 to an SSL_METHOD pointer. The function does not take any parameters, and the calling convention is unknown."
openssl-101u,O0,x86,__libc_csu_init,./data/decomp/openssl-101u_x86_gcc_O0_extraction/__libc_csu_init@081ea170.c,"The function __libc_csu_init initializes the C runtime environment before executing the main function. It calls the _init function to initialize the C library and then executes functions in the __frame_dummy_init_array_entry array for global object initialization. The function takes parameters param_1, param_2, and param_3 before returning."
openssl-101u,O0,x86,__udivdi3,./data/decomp/openssl-101u_x86_gcc_O0_extraction/__udivdi3@081e9ee0.c,"The function takes four unsigned integers as input: param_1, param_2, param_3, and param_4. It returns an unsigned 64-bit integer that represents the result of dividing the 128-bit integer formed by concatenating param_2 and param_1 with the 64-bit integer formed by concatenating param_4 and param_3. The function first checks if param_4 is zero. If it is, it performs a simple division using the 32-bit division operator and returns the result as a 64-bit integer. If param_4 is not zero, the function performs a more complex division using bitwise operations. The function calculates the number of bits needed to represent param_4, then shifts the values of param_2 and param_3 accordingly. It then performs the division using the long division algorithm, and returns the result as a 64-bit integer. If the result of the division is too large to fit in a 32-bit integer, the function handles it appropriately."
openssl-101u,O1,x86,aep_mod_exp.part.0,./data/decomp/openssl-101u_x86_gcc_O1_extraction/aep_mod_exp.part.0@0819cda0.c,"The function `aep_mod_exp_part_0` implements modular exponentiation using a hardware accelerator device called AEP. It establishes a connection with the AEP device using `aep_get_connection`, then calls `p_AEP_ModExp` to perform the operation. If successful, it updates the connection status and returns 1. If it fails, it closes the connection and returns the result using OpenSSL. If the connection cannot be established, it returns the result using OpenSSL. The function takes five arguments, including a pointer to the B."
openssl-101u,O1,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_x86_gcc_O1_extraction/asn1_bio_callback_ctrl@081e50a0.c,"The function takes three parameters: param_1, param_2, and param_3. It checks if the value stored at the memory address pointed to by param_1 plus 0x24 is null. If it's not null, it calls the BIO_callback_ctrl function with the parameters passed to the function and returns the return value of that function call. If the value stored at the memory address pointed to by param_1 plus 0x24 is null, the function returns 0."
openssl-101u,O1,x86,asn1_bio_ctrl,./data/decomp/openssl-101u_x86_gcc_O1_extraction/asn1_bio_ctrl@081e5160.c,"The function takes in a pointer to a BIO object, a control command (param_2), a control argument (param_3), and a pointer to an integer (param_4). If the pointer to the BIO object is null, the function returns 0. If the control command is 0x97, the function sets the values of two integers in the BIO object to the values pointed to by param_4 and returns 1. If the control command is 0x95, the function sets the values of two other integers in the BIO object to the values pointed to by param_4 and returns 1. If the control command is 0xb, the function checks if the BIO object has a next_bio field. If it does not, the function returns 0. If it does, the function checks the value of an integer in the BIO object, and depending on its value, performs different actions. If the value is 2, the function..."
openssl-101u,O1,x86,asn1_bio_free,./data/decomp/openssl-101u_x86_gcc_O1_extraction/asn1_bio_free@081e50c0.c,"The function `asn1_bio_free` frees memory allocated to an ASN1 BIO structure. It retrieves a pointer to the memory allocated for the BIO structure using an offset of 0x20 from the input parameter. If this pointer is not NULL, the function checks if the pointer to the data buffer (located at an offset of 4 from the BIO structure pointer) is also not NULL. If it is not NULL, the function frees the memory allocated to the data buffer using `CRYPTO_free`. Next, the function frees the memory allocated to the BIO structure using `CRYPTO_free`. It then sets the values of the offsets at 0xc, 0x20, and 0x14 from the input parameter to 0. Finally, the function returns a value of 1 to indicate that memory was freed, or 0 if no memory was freed."
openssl-101u,O1,x86,asn1_bio_write,./data/decomp/openssl-101u_x86_gcc_O1_extraction/asn1_bio_write@081e5460.c,"The `asn1_bio_write` function writes data to a BIO object in ASN.1 format. It checks the validity of input parameters and the state of the BIO object. If the state is less than 5, it enters a switch statement. If the state is 0, it calculates the size of the ASN.1 object, puts the object in the buffer, and updates the state to 3. If the state is 3, it writes the data to the next BIO object and updates the buffer and state accordingly. If the write fails, it clears the BIO flags and retries the write. If the state is 4, it writes the remaining data in the buffer to the next BIO object and updates the buffer and state accordingly. If there is no more data in the buffer, it updates the state to 2. If the state is 2, it writes the input data to the next BIO object and updates the state."
openssl-101u,O1,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BIO_asn1_get_suffix@081e5870.c,"The function takes in a BIO object, a pointer to a suffix, and a pointer to a suffix free variable. It retrieves the suffix from the BIO object using the BIO_ctrl function and stores it in a local variable. It also retrieves the suffix free variable and stores it in a separate local variable. If the length of the suffix is greater than 0, the function sets the values of the suffix and suffix free pointers to the respective local variables. The function returns the length of the suffix. If a stack overflow is detected, the function calls the __stack_chk_fail() function."
openssl-101u,O1,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BIO_asn1_set_prefix@081e5770.c,"The function BIO_asn1_set_prefix sets the prefix for a BIO pointer to the value pointed to by a prefix pointer. It calls the BIO_ctrl function with the control command 0x95 and passes in a pointer to the prefix. The function returns the result of the BIO_ctrl function. If there is a stack check failure, the function does not return. The function also takes in a pointer to a prefix_free function."
openssl-101u,O1,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_get0_nist_prime_224@081e58e0.c,"The function returns a pointer to a constant BIGNUM value representing the NIST prime number 224-bit. The value is stored in a static array named ""_bignum_nist_p_224"". The function does not take any parameters and the calling convention is unknown. The warning message indicates that the function may not be compatible with the current system's calling convention."
openssl-101u,O1,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_get0_nist_prime_384@081e5900.c,"The ""get0"" function returns a pointer to a static array called _bignum_nist_p_384 that contains a 384-bit NIST prime number stored in a BIGNUM structure. It does not modify the array or the structure. However, the warning message suggests that the calling convention used by the function may not be recognized by the decompiler."
openssl-101u,O1,x86,BN_GF2m_add,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_add@081dfc60.c,"The function takes three parameters: a BIGNUM structure pointer (param_1), and two integer pointers (param_2 and param_3). It first checks which of the two integer pointers has a larger value and swaps them if necessary. It then checks if the size of the BIGNUM structure pointed to by param_1 is smaller than the larger integer value. If it is, it expands the BIGNUM structure to accommodate the larger value. Next, the function XORs the values pointed to by the two integer pointers and stores the result in the BIGNUM structure pointed to by param_1. If the size of the resulting BIGNUM structure is smaller than the larger integer value, the function copies the remaining values from the larger integer pointer into the BIGNUM structure. Finally, the function trims any leading zero values from the resulting BIGNUM structure."
openssl-101u,O1,x86,BN_GF2m_mod,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod@081dfe00.c,"The function BN_GF2m_mod takes in three parameters: param_1, param_2, and param_3. Param_1 and param_2 are BIGNUM pointers, and param_3 is an integer array containing information about the irreducible polynomial used in Galois field arithmetic. The function checks if param_3[1] is equal to 0 and calculates the positions of non-zero bits in param_2. If there are more than 6 non-zero bits, an error message is set and the function returns 0. If the first element of the non-zero bit array is 0, param_1 is set to 0 and the function returns 1. If param_1 and param_2 are not the same pointer, the function checks if param."
openssl-101u,O1,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_arr@081dfd60.c,"The function BN_GF2m_mod_arr takes three parameters: param_1, param_2, and param_3. It returns an undefined value (represented as undefined4). The function first checks if the value of param_3 is zero. If it is, it sets the value of param_1 to zero and returns 1. If param_3 is not zero, the function checks if param_1 and param_2 are the same. If they are not the same, it expands param_1 to the same size as param_2. It then copies the contents of param_2 to param_1. The function then calls the function BN_GF2m_mod_arr_part_0, which is not shown in this code snippet. The function returns the value returned by BN_GF2m_mod_arr_part_0."
openssl-101u,O1,x86,BN_GF2m_mod_div,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_div@081e1700.c,"BN_GF2m_mod_div is a low-level function in OpenSSL's BIGNUM library that performs modular division in a binary field. It takes three BIGNUMs (param_2, param_3, and param_4) and a BN_CTX structure as input. The function first computes the modular inverse of param_4 with respect to param_3 using BN_GF2m_mod_inv. It returns 0 if the inverse cannot be computed. Next, the function allocates temporary memory to hold an array of integers representing the positions of the non-zero bits in param_4. The array is used to speed up the function."
openssl-101u,O1,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_div_arr@081e18b0.c,"The function BN_GF2m_mod_div_arr takes in four parameters: param_1, param_2, param_3, and param_4, as well as a BN_CTX pointer param_5. Inside the function, BN_CTX_start is called twice to initialize two BIGNUM variables, a and pBVar3. If either of these variables is null, the function returns 0. The function sets the value of a based on the values in the array pointed to by param_4. It sets a bit in a for each index in the array that is not equal to -1. The function then computes the inverse of param_3 modulo a using BN_GF2m_mod_inv and stores the result in pBVar3. If the inverse cannot be computed, the function returns 0. The function then allocates memory for an array of integers with a size of (number of bits in a + 1) * 4. If..."
openssl-101u,O1,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_mul@081e0dc0.c,"The BN_GF2m_mod_mul function in the OpenSSL library performs binary polynomial multiplication in the GF(2^m) field. It takes five parameters, including pointers to BIGNUM structures representing the operands. The function calculates the number of bits in the first operand, allocates memory accordingly, and extracts and stores the positions of set bits. It calls the BN_GF2m_mod_mul_arr function to perform the multiplication using precomputed values and returns the result. If there is an error, it sets an error code and returns 0."
openssl-101u,O1,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_mul_arr@081e0190.c,"The first function, BN_GF2m_mod_mul_arr, is a helper function for performing modular multiplication in a binary field. It takes four arrays of integers as input, representing two binary polynomials, and outputs the result of their multiplication modulo a given irreducible polynomial. The function uses bitwise operations and table lookups to perform the multiplication.

The second function takes in three parameters and performs a series of operations on the input buffer using the key buffer and stores the result in the output buffer. It initializes several local variables and iterates through the input buffer two bytes at a time.

The third function, a decompiled version of the OpenSSL library's BN_GF2m_mod function, performs modular reduction of a binary polynomial represented as a BIGNUM object. It takes five parameters and initializes some local variables before performing the reduction."
openssl-101u,O1,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_sqr@081e0f10.c,"The function BN_GF2m_mod_sqr performs a modular squaring operation on a binary polynomial represented as a BIGNUM structure. It first allocates memory for an array of integers to store the exponents of the non-zero coefficients of the polynomial. It then extracts the exponents of the non-zero coefficients of the polynomial and stores them in the array. The array is then passed to the BN_GF2m_mod_sqr_arr function to perform the modular squaring operation. The result of the operation is returned as an integer, and the allocated memory is freed."
openssl-101u,O1,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_sqrt@081e1eb0.c,"The function BN_GF2m_mod_sqrt computes the square root of a binary polynomial in GF(2^m) field. It takes four parameters: a BIGNUM pointer to store the result, an integer parameter, a BIGNUM pointer representing the input polynomial, and a BN_CTX pointer for temporary storage. The function calculates the number of bits in the input polynomial and allocates memory for an array of integers to store the positions of the non-zero bits in the polynomial. It then iterates through the polynomial, storing the positions of the non-zero bits in the array. Next, the function checks if the input polynomial is zero or not. If it is zero, the function sets the result to zero and returns 1. Otherwise, it computes the square root of the polynomial using the BN_GF2m_mod_exp_arr function and sets the result to the computed square root. Finally, the function frees the memory allocated for the array and returns the result of the computation."
openssl-101u,O1,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_GF2m_mod_sqr_arr@081dff80.c,"The function BN_GF2m_mod_sqr_arr takes in four parameters: a BIGNUM pointer, two integer pointers, and a BN_CTX pointer. It starts a BN_CTX to perform operations on big numbers and checks if the BIGNUM pointer is null. If it is not null, the function checks the size of the BIGNUM pointer and expands it if necessary. Then it iterates through the second integer pointer, squares each element using precomputed values, and stores the squared values in the BIGNUM pointer. Finally, the function sets the top value of the BIGNUM pointer and removes any leading zeros. If the value of the first integer pointer is 0, the function returns false."
openssl-101u,O1,x86,BN_kronecker,./data/decomp/openssl-101u_x86_gcc_O1_extraction/BN_kronecker@081deef0.c,"The function BN_kronecker computes the Kronecker symbol of two BIGNUMs a and b using the extended binary GCD algorithm. The Kronecker symbol is a generalization of the Legendre symbol to composite moduli. It returns an integer value that indicates whether b is a quadratic residue modulo a or not. The possible values are -2, -1, 0, 1, and 2. The function first initializes two BIGNUM variables a_00 and a_01 using the BN_CTX_get function. It then checks if either of these variables is null or if BN_copy fails to copy a into a_00. If any of these conditions is true, the function returns -2. Next, it checks if a_01 is equal to zero, and if so, it checks if a_00 is equal to one. If a_00 is equal to one, the function returns 1; otherwise, it returns 0. If a_01 is not equal to zero, the function proceeds to compute the Kronecker symbol using the extended binary GCD algorithm."
openssl-101u,O1,x86,by_dir_entry_free,./data/decomp/openssl-101u_x86_gcc_O1_extraction/by_dir_entry_free@08166860.c,"The ""by_dir_entry_free"" function frees memory associated with a directory entry. It checks if the input pointer is not null and frees the memory using CRYPTO_free. It also checks if the third element of the parameter (assumed to be a pointer to a stack) is not null and frees the stack using sk_pop_free, passing in ""by_dir_hash_free"" as an argument. Finally, it frees the entire parameter using CRYPTO_free and returns."
openssl-101u,O1,x86,cswift_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O1_extraction/cswift_rand_bytes@0819edc0.c,"The function `cswift_rand_bytes` generates a specified number of random bytes using the CryptoSwift hardware accelerator. It takes two arguments: a pointer to a buffer to store the generated bytes and the number of bytes to generate. The function first acquires an access context using the `CSwift_AcquireAccContext` function. If successful, it generates random bytes using the `CSwift_SimpleRequest` function in chunks of 1024 bytes or less until the requested number of bytes has been generated. If the requested number of bytes is not a multiple of 1024, the function generates the remaining bytes in a separate call to `CSwift_SimpleRequest`. The generated bytes are then copied to the buffer pointed to by the first argument. If an error occurs during the generation of random bytes, an error message is added to the OpenSSL error queue using the `ERR_put_error` function. Finally, the function releases the access context using the `CSwift_ReleaseAcc` function."
openssl-101u,O1,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_x86_gcc_O1_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9f40.c,This function takes in three parameters and returns nothing. It uses the ASN1_item_d2i function with an ASN1_ITEM structure to decode a DER-encoded data stream into a C structure. Its purpose is to convert a DER-encoded GOST client key exchange parameters data stream into a C structure.
openssl-101u,O1,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_x86_gcc_O1_extraction/d2i_GOST_KEY_PARAMS@081d9e40.c,"The function takes in a pointer to an ASN1_VALUE, a pointer to an unsigned character buffer, and a long integer representing the length of the buffer. It then calls the ASN1_item_d2i function to decode an ASN.1 structure from the buffer. The function returns void."
openssl-101u,O1,x86,decode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O1_extraction/decode_gost_algor_params@081d79d0.c,"The function decodes algorithm parameters for the GOST algorithm from an X509_ALGOR structure and sets them in an EVP_PKEY structure. It retrieves the algorithm parameters from the X509_ALGOR structure and checks if it is the GOST algorithm. If it is, it decodes the parameters using the d2i_GOST_KEY_PARAMS function and checks the type of the EVP_PKEY structure. If the EVP_PKEY structure is an EC_KEY, it fills the GOST2001 parameters using the fill_GOST2001_params function. If it is a DSA, it fills the GOST94 parameters using the fill_GOST94_params function. If the decoding or setting of the parameters fails, it returns 0. Otherwise, it returns 1."
openssl-101u,O1,x86,DES_xcbc_encrypt,./data/decomp/openssl-101u_x86_gcc_O1_extraction/DES_xcbc_encrypt@081de220.c,"These functions both involve the DES encryption algorithm, which is a symmetric key algorithm used for encryption and decryption of data. They both take in an initialization vector (IV) as a parameter, and perform encryption on the input data in blocks of 8 bytes. The first function, DES_xcbc_encrypt, uses the XCBC (eXclusive Cipher Block Chaining) mode of operation and takes in additional parameters such as a DES key schedule and constant cblocks. The second function returns the encrypted data as output and handles padding of input data if it is not a multiple of 8 bytes."
openssl-101u,O1,x86,dgram_ctrl,./data/decomp/openssl-101u_x86_gcc_O1_extraction/dgram_ctrl@0811e8c0.c,"The function `dgram_ctrl` takes in four parameters - an integer `param_1`, an undefined value `param_2`, a size_t value `param_3`, and a pointer to an undefined value `param_4`. The function switches on the value of `param_2` and performs different actions based on its value. If `param_2` is 8, the function sets `param_3` to the value stored at the memory location `param_1 + 0x10`. If `param_2` is 9, the function sets the value stored at the memory location `param_1 + 0x10` to `param_3` and sets `param_3` to 1.

The function also initializes some variables, including a local variable `local_20` which is set to the value stored at the memory location pointed to by the value in the `in_GS_OFFSET` register plus 0x14.

The function takes four input parameters: a pointer to a struct, an integer, a pointer to a buffer, and the size of the buffer. It switches on the integer input parameter and performs different actions based on its value. If the integer is 0x20, it sets the value of a variable in the struct to the value of the buffer and returns the size of the buffer. If the integer is 0x2f, it checks if the first two bytes of the buffer are equal to 10. If they are, it sets the size of the buffer to either 0x500 or 0x240 minus a variable depending on the value of the next two bytes of the buffer. If the integer is 0x31, it checks if the first two bytes of the buffer are equal to 10. If they are, it sets the size of the buffer to either 0x1c or 0x1c depending on the value of."
openssl-101u,O1,x86,dlfcn_bind_func,./data/decomp/openssl-101u_x86_gcc_O1_extraction/dlfcn_bind_func@081e4600.c,"The function takes two integer parameters, param_1 and param_2. It checks if either of the parameters are equal to zero. If so, it sets the line variable to 0x109 and the iVar1 variable to 0x43. If both parameters are non-zero, it gets the number of elements in a stack stored at the memory address specified by param_1 + 4. If the number of elements in the stack is less than 1, it sets the line variable to 0x10d and the iVar1 variable to 0x69. If the number of elements in the stack is 1 or greater, it retrieves the last element in the stack using the sk_value function. It checks if the last element in the stack is not equal to NULL. If it is not NULL, it calls the dlsym function with the last element in the stack and param_2 as parameters. If dlsym returns 0, it adds an error message."
openssl-101u,O1,x86,dlfcn_bind_var,./data/decomp/openssl-101u_x86_gcc_O1_extraction/dlfcn_bind_var@081e4700.c,"The function takes in two integer parameters: param_1 and param_2. It checks if either parameter is equal to 0, and if so, sets the line variable to 0xeb and returns 0x43. Otherwise, it gets the number of elements in a stack pointed to by the value at address (param_1 + 4) and stores it in the variable iVar1. If iVar1 is less than 1, it sets the line variable to 0xef and returns 0x69. Otherwise, it gets the value at the top of the stack and stores it in the variable pvVar2. If pvVar2 is not equal to NULL, it calls the dlsym function with parameters pvVar2 and param_2. If the return value of dlsym is 0, it sets an error message and returns 0. Otherwise, it returns the value returned by dlsym. If pvVar2 is NULL, it sets the line variable."
openssl-101u,O1,x86,dlfcn_globallookup,./data/decomp/openssl-101u_x86_gcc_O1_extraction/dlfcn_globallookup@081e4320.c,"The function takes in a parameter of type undefined4 and returns an undefined4 value. It calls dlopen with a null pointer and the flag 1 to open the dynamic linker library. If dlopen returns 0, the function returns 0. Otherwise, it calls dlsym with the handle returned by dlopen and the parameter passed into the function. It then calls dlclose with the handle returned by dlopen and returns the value returned by dlsym. This function is likely used to dynamically load and access symbols in shared libraries."
openssl-101u,O1,x86,doapr_outch.constprop.0,./data/decomp/openssl-101u_x86_gcc_O1_extraction/doapr_outch.constprop.0@0811a260.c,"The function `doapr_outch_constprop_0` takes four parameters: `param_1_00`, `param_2`, `param_3`, and `param_1`, which are all pointers to `void` and `uint` types. The function returns an `undefined4` value. It first checks if `param_2` is equal to `NULL` or if the value pointed to by `param_3` is not equal to the value pointed to by `param_1`. If either of these conditions is true, it jumps to the label `LAB_0811a278`. If the above conditions are not true, the function checks if the value pointed to by `param_3` is greater than `0x7ffffbff`. If it is, the function returns `0`. If the above conditions are not true, the function sets `pvVar1` to the value pointed to by `param_2` and sets `uVar`."
openssl-101u,O1,x86,dtls1_link_min_mtu,./data/decomp/openssl-101u_x86_gcc_O1_extraction/dtls1_link_min_mtu@080bb4c0.c,"The function sets a minimum MTU size for the DTLS protocol link to prevent packet fragmentation and performance issues. It returns the value 0x100, equivalent to 256 in decimal."
openssl-101u,O1,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_mont_field_encode@081e2b20.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. If the BN_MONT_CTX pointer is not null, the function uses BN_mod_mul_montgomery() function to perform a Montgomery multiplication of the second and third parameters, using the modulus and precomputed values in the BN_MONT_CTX structure. The result is stored in the first parameter. The function then returns the result of the multiplication. If the BN_MONT_CTX pointer is null, the function generates an error message using the ERR_put_error() function and returns 0."
openssl-101u,O1,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_mont_field_sqr@081e2ac0.c,"The function takes four parameters - an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It performs a modular multiplication of the second BIGNUM parameter with itself using the BN_mod_mul_montgomery() function and the BN_MONT_CTX pointer stored at offset 0xa0 of the integer parameter. The result is stored in the first BIGNUM parameter. If the BN_MONT_CTX pointer is NULL, the function logs an error using the ERR_put_error() function and returns 0. The function returns the result of the modular multiplication or 0 if an error occurred."
openssl-101u,O1,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_mont_group_init@081e26d0.c,The `ec_GFp_mont_group_init` function initializes a Montgomery elliptic curve group by first initializing a simple elliptic curve group using the `ec_GFp_simple_group_init` function. It then sets two variables to zero at specific memory offsets and returns. These variables are likely used in the Montgomery multiplication algorithm.
openssl-101u,O1,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_nist_field_mul@081e2e50.c,"The function is a C implementation of multiplication in a NIST elliptic curve field. It takes four parameters: an integer representing the curve parameters, and three BIGNUMs representing the operands to be multiplied. It also takes a BN_CTX pointer for temporary storage. The function first checks if any of the parameters are NULL and if so, it sets an error flag. If the BN_CTX pointer is NULL, it creates a new one. It then performs the multiplication of the two operands using BN_mul() function and stores the result in the third operand. Finally, it performs a modular reduction using a function pointer stored in the curve parameters and returns the result. If any of the operations fail, the function returns false."
openssl-101u,O1,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_nist_group_copy@081e2c50.c,"The function `ec_GFp_nist_group_copy` copies the curve parameters from the source group to the destination group. It takes two parameters, `param_1` and `param_2`, where the first parameter is the destination group and the second parameter is the source group. The function copies the value at offset 0xa8 in the source group to the same offset in the destination group. It then calls `ec_GFp_simple_group_copy` to copy the remaining group parameters from the source group to the destination group. The function returns after completing these operations."
openssl-101u,O1,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_nist_group_set_curve@081e2c70.c,"The function takes in five parameters: an integer, a BIGNUM pointer, and three undefined values. It first checks if the fifth parameter (BN_CTX pointer) is NULL. If it is, it creates a new BN_CTX object and starts it, and then gets a BIGNUM from it. If it is not NULL, it starts the BN_CTX and gets a BIGNUM from it. It then compares the second parameter (a BIGNUM pointer) with the NIST prime curves of various sizes (192, 224, 256, 384, and 521 bits) to determine which curve to use. If a matching curve is found, it sets the appropriate modular reduction function and calls the ec_GFp_simple_group_set_curve function with the same parameters. If no matching curve is found, it sets the return value to 0 and adds an error to the OpenSSL error queue. Finally, it ends the BN_CTX object and frees it if necessary."
openssl-101u,O1,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e77c0.c,"The function takes in six parameters: an integer pointer, an integer, and four BIGNUM pointers, and returns a boolean value. It first checks if a certain field in the structure pointed to by the integer pointer is zero. If it is, it copies the values of the second, third, and fourth BIGNUM pointers to the first, second, and third BIGNUM pointers, respectively. If the fourth BIGNUM pointer is not null, it also copies its value to the fourth BIGNUM pointer passed in. If the field is not zero, the function creates a BN_CTX object (if one was not passed in) and uses it to compute the J-projective coordinates of the point represented by the second and third BIGNUM pointers. The resulting values are then copied to the first, second, and third BIGNUM pointers, respectively. If the fourth BIGNUM pointer is not null, its value is also computed and copied. If everything succeeds, the function returns true."
openssl-101u,O1,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_group_check_discriminant@081e7990.c,"The function checks the discriminant of an elliptic curve in the field of integers modulo a prime number. It takes an array of integers representing the curve parameters and a BN_CTX object for temporary storage of big numbers as input. It returns a boolean value indicating whether the discriminant is valid. The function initializes a BN_CTX object if one is not provided and obtains temporary BIGNUM objects from the BN_CTX for computation. It checks if a specific function pointer in the curve parameters is null and copies the values of two curve parameters into the temporary BIGNUM objects if it is. If the function pointer is not null, it calls the function pointed to by the pointer to compute the values of the two curve parameters. The function then computes the discriminant of the curve using the formula `d = -16*(4*a^3 + 27*b^2)`, where `a` and `b` are the curve parameters. If the discriminant is valid, it returns true."
openssl-101u,O1,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_group_clear_finish@081e7420.c,"The function frees three BIGNUM variables stored at specific offsets from the integer parameter (0x48, 0x74, and 0x88), and then returns without any other action."
openssl-101u,O1,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_group_copy@081e8570.c,"This function copies the contents of one EC group structure to another by copying the prime, order, and generator fields using the BN_copy function, as well as the cofactor field. It returns 1 if all copy operations are successful, and 0 otherwise."
openssl-101u,O1,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_group_get_degree@081e7490.c,The function calculates the degree of the field over which an elliptic curve group is defined by calling BN_num_bits on a BIGNUM object within the group structure. The result of BN_num_bits is not used or returned.
openssl-101u,O1,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_group_set_curve@081e8660.c,"The function takes in four BIGNUM parameters and a BN_CTX parameter. It first checks if the number of bits in the second parameter is greater than or equal to 3 and if the least significant bit of the second parameter is set to 1. If not, it returns an error. If a BN_CTX parameter is not provided, it creates a new one and allocates memory for two BIGNUM parameters. It then copies the second parameter into the first BIGNUM parameter, sets its sign to positive, and calculates the remainder of the third parameter divided by the second parameter using the BN_nnmod function. If the remainder is 0, it returns an error. If the function pointer at offset 0x90 of the first parameter is not null, it calls that function with the first parameter, the second parameter, and the remainder as arguments. If the function returns an error, it returns. It then calculates the remainder of the fourth parameter divided by the second parameter using BN_nn."
openssl-101u,O1,x86,ec_GFp_simple_invert,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_invert@081e9390.c,"The function takes in an EC_GROUP pointer and an EC_POINT pointer as parameters. It checks if the point is at infinity or not by calling EC_POINT_is_at_infinity function. If the point is not at infinity and its z-coordinate is not equal to zero, it calculates the inverse of the point by subtracting the y-coordinate from the order of the group and returning the result. If the point is at infinity or its z-coordinate is equal to zero, it returns 1 indicating failure to calculate the inverse."
openssl-101u,O1,x86,EC_GFp_simple_method,./data/decomp/openssl-101u_x86_gcc_O1_extraction/EC_GFp_simple_method@081e9ed0.c,"The decompiled function returns a pointer to a structure of type EC_METHOD, which likely contains function pointers for operations on elliptic curves over a finite field. However, the decompiler is unable to determine the calling convention used, resulting in a warning. The decompiler needs to know the convention used to properly decompile the function."
openssl-101u,O1,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_point_copy@081e85f0.c,"This function takes in two integer parameters, param_1 and param_2, and copies the BIGNUM values stored in param_2 to param_1 by calling BN_copy. It copies the BIGNUM values stored at offset 4, 0x18, and 0x2c in param_2 to the same offsets in param_1. If all three BN_copy calls are successful, the function sets the value stored at offset 0x40 in param_1 to the value stored at offset 0x40 in param_2 and returns 1. Otherwise, it returns 0."
openssl-101u,O1,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_point_finish@081e73f0.c,"The function frees memory allocated for three BIGNUMs representing x, y, and z coordinates of an elliptic curve point in GF(p) field, and returns."
openssl-101u,O1,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7c00.c,"The function takes an EC_POINT object, an EC_GROUP object, two BIGNUM objects, and a BN_CTX object as input. It checks if the input point is at infinity and initializes a BN_CTX object if one was not provided. It then computes the x and y coordinates of the point in affine form using a precomputed table of multiples if available or by computing the inverse of the x-coordinate and reducing both coordinates modulo the curve if not."
openssl-101u,O1,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O1_extraction/ec_GFp_simple_point_set_affine_coordinates@081e88d0.c,"The function takes an EC group and an EC point as input along with two BIGNUMs representing the affine coordinates of the point and a BN_CTX object. It first checks if the affine coordinates are not null. If they are not null, it sets the point's coordinates in Jacobian projective coordinates using EC_POINT_set_Jprojective_coordinates_GFp and returns the result. If the affine coordinates are null, it generates an error and returns 0."
openssl-101u,O1,x86,encode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O1_extraction/encode_gost_algor_params@081d8c50.c,"The function takes an EVP_PKEY pointer as input and encodes the parameters of a GOST algorithm into an ASN1_STRING structure. It creates a new ASN1_STRING object and a new GOST_KEY_PARAMS object. It determines the type of GOST algorithm based on the input EVP_PKEY. If the algorithm is an elliptic curve algorithm, it gets the curve name and creates an ASN1_OBJECT with that name. If the algorithm is a R3410 algorithm, it gets the parameter set and compares it with the parameters in the EVP_PKEY object to determine the correct OID for the parameters. It then creates an ASN1_OBJECT with that OID. It sets the two objects in the GOST_KEY_PARAMS object and encodes it into the ASN1_STRING object. If successful, it sets the type of the ASN1_STRING object to 0x10 and returns it."
openssl-101u,O1,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_x86_gcc_O1_extraction/general_allocate_boolean.constprop.5@08187cc0.c,"The function takes in parameters including two strings, an integer, and several other integers. It checks if the first string is null and returns an error code if so. It then checks if each character in the first string is present in the second string and returns an error code if not. If certain conditions are met, it allocates memory for an integer array, sets the values of the array based on the input parameters, creates a stack (if it does not already exist), and pushes the integer array onto the stack. It returns the index of the pushed element in the stack minus a certain value."
openssl-101u,O1,x86,get_gost_engine_param,./data/decomp/openssl-101u_x86_gcc_O1_extraction/get_gost_engine_param@081db600.c,"The function takes an integer parameter called ""param_1"" and returns a character pointer (i.e., a string). It first checks if the parameter is not equal to zero, in which case it returns a null pointer. If the global variable ""gost_params"" is null, it gets the value of the environment variable ""CRYPT_PARAMS"" using the getenv() function. If this environment variable is also null, it returns a null pointer. Otherwise, it allocates memory for ""gost_params"" using the BUF_strdup() function and returns its value. The purpose of this function is to retrieve the value of a GOST engine parameter, which is stored in an environment variable or in a global variable."
openssl-101u,O1,x86,gost2001_param_encode,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost2001_param_encode@081d7f80.c,"This function extracts an EC_KEY object from an EVP_PKEY object, retrieves the associated EC_GROUP object, gets the curve name of the group, converts it to an ASN1_OBJECT structure, encodes it into a binary format using i2d_ASN1_OBJECT, and stores the result in the param_2 pointer for use in cryptographic operations."
openssl-101u,O1,x86,gost_cipher_cleanup,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost_cipher_cleanup@081da1a0.c,"The function takes an integer parameter `param_1` and cleans up a GOST cipher object by calling the `gost_destroy` function with a pointer to a calculated memory location. It also resets a flag or state variable by setting the value at `param_1 + 0x54` to zero. The function returns 1, although it is unclear why as it is not used within the function or in the provided code snippet."
openssl-101u,O1,x86,gost_cipher_ctl,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost_cipher_ctl@081da6f0.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function generates random bytes and stores them in the memory location pointed to by `param_4`. If the random bytes are successfully generated, the function returns 1. If there is an error generating the random bytes, the function calls `ERR_GOST_error` and returns 0xffffffff. If `param_2` is equal to 7, the function sets the value at the memory location pointed to by `param_4` to 0x32a and returns 1. If `param_4` is equal to NULL, the function returns 0. If `param_2` is not equal to 6 or 7, the function calls `ERR_GOST_error` and returns 0xffffffff."
openssl-101u,O1,x86,gost_cipher_do_cnt,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost_cipher_do_cnt@081da310.c,"The `gost_cipher_do_cnt` function encrypts data using the GOST cipher in CNT mode. It takes four parameters: an integer representing the cipher context, a byte array for input data, a byte array for output data, and an unsigned integer representing the length of the input data. The function checks if the counter value is zero, and if it is, sets a local variable and another variable to specific values. If the counter value is less than 8 and the input data length is not zero, the function XORs the counter value with the first byte of the input data and stores the result in the first byte of the output data. This process repeats for the next 7 bytes of the input and output data arrays."
openssl-101u,O1,x86,gost_cipher_init,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost_cipher_init@081db320.c,"The function initializes the GOST cipher context with the given parameters, including determining the appropriate cipher to use based on the parameter or defaulting to the first cipher in the GOST cipher list. The cipher data field of the context is set to the cipher identifier, a null initialization vector, and the key schedule initialized with the cipher parameters. If a key is provided, it is used to initialize the key schedule. If an initialization vector is provided, it is copied to the original initialization vector field of the context and then copied to the current initialization vector field. The function returns 1 on success and 0 on failure."
openssl-101u,O1,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O1_extraction/GOST_CIPHER_PARAMS_new@081d9f00.c,"The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function, which is defined in an ASN.1 format and specifies the parameters for the GOST cipher algorithm. It does not take any input parameters and does not return anything."
openssl-101u,O1,x86,gost_imit_final,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost_imit_final@081dafc0.c,"The function `gost_imit_final` takes two parameters, an integer `param_1` and an undefined 4-byte integer `param_2`. It retrieves the value of an integer `iVar1` from the memory location pointed to by `param_1` plus an offset of 0xc. It then retrieves the value of an integer `iVar2` from the memory location pointed to by `iVar1` plus an offset of 0x103c. If `iVar2` is equal to 0, the function calls `ERR_GOST_error` with the error code 0x8c and the message ""gost_crypt.c"", and then jumps to the label `LAB_081db01a`. Otherwise, if the value of an integer located at the memory location pointed to by `iVar1` plus an offset of 0x1030 is equal to 0, the function checks if the value of an integer located at the memory location pointed."
openssl-101u,O1,x86,gost_imit_init_cpa,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost_imit_init_cpa@081da680.c,The function initializes parameters for a GOST block cipher implementation by setting certain values to zero and one at specific offsets in a structure. It then calls the gost_init function with the retrieved address and a constant value representing a specific set of parameters for the GOST cipher. The function returns 1 to indicate success.
openssl-101u,O1,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O1_extraction/GOST_KEY_PARAMS_new@081d9e80.c,"The function creates a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new function, which is defined by the GOST_KEY_PARAMS_it ASN1 item type. It does not return any value."
openssl-101u,O1,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_x86_gcc_O1_extraction/GOST_KEY_TRANSPORT_free@081d9d20.c,"The function GOST_KEY_TRANSPORT_free() frees the memory allocated to an ASN1_VALUE pointer using the ASN1_item_free() function. The ASN1_ITEM structure that defines the type of the ASN1_VALUE is passed as the second argument, specifically the GOST_KEY_TRANSPORT_it structure. The function does not return a value."
openssl-101u,O1,x86,gost_param_free,./data/decomp/openssl-101u_x86_gcc_O1_extraction/gost_param_free@081db560.c,"The ""gost_param_free"" function frees the memory allocated to the ""gost_params"" variable. It checks if the variable is not null and uses the ""CRYPTO_free"" function to free the memory. It also sets the ""gost_params"" variable to null and returns nothing."
openssl-101u,O1,x86,hash_step,./data/decomp/openssl-101u_x86_gcc_O1_extraction/hash_step@081db6d0.c,The functions all involve initializing local variables and performing bitwise operations on them. They also call the function gost_enc_with_key to perform encryption using different keys and additional data. The exact purpose and security properties of this encryption are unclear without additional context. One function checks for stack overflow attacks and terminates the program if detected. Another function updates the values of pointers to arrays based on calculations using elements of another array.
openssl-101u,O1,x86,hwcrhk_init,./data/decomp/openssl-101u_x86_gcc_O1_extraction/hwcrhk_init@081a16a0.c,"The function initializes the HWCryptoHook library by loading and binding its functions, and setting up mutex callbacks if not disabled. It returns 1 and sets a handle index for RSA keys if successful, or puts an error in the queue and returns 0 if unsuccessful. It also frees the library and resets all function pointers."
openssl-101u,O1,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_x86_gcc_O1_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9de0.c,"The function i2d_GOST_KEY_AGREEMENT_INFO takes two parameters: param_1, a pointer to an ASN1_VALUE structure containing data to be encoded, and param_2, a pointer to a pointer to an unsigned character that will hold the encoded data. The function uses the ASN1_item_i2d function to encode the data in param_1 into the buffer pointed to by param_2, with the third parameter being a pointer to the ASN1_ITEM structure for the GOST_KEY_AGREEMENT_INFO type. The function returns without a value after the encoding is complete."
openssl-101u,O1,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_x86_gcc_O1_extraction/i2d_GOST_KEY_TRANSPORT@081d9ce0.c,The function encodes an ASN1_VALUE structure into an ASN.1 DER format using the ASN1_ITEM structure for the GOST_KEY_TRANSPORT type. It takes two parameters: a pointer to the ASN1_VALUE structure and a double pointer to an unsigned char array. The resulting bytes are stored in the uchar array and the function returns without any value.
openssl-101u,O1,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101u_x86_gcc_O1_extraction/load_pkcs12.constprop.4@0807a4c0.c,"The function `load_pkcs12_constprop_4` takes in several parameters, including two `BIO` pointers, a string, a function pointer, and two double pointers to `EVP_PKEY` and `X509` structures. It uses the `d2i_PKCS12_bio` function to read in a PKCS12 file from the second `BIO` pointer. If the PKCS12 file cannot be loaded, an error message is printed and the function returns 0. If the PKCS12 file is successfully loaded, the function uses `PKCS12_verify_mac` to verify the MAC of the PKCS12 file. If the MAC verification fails, the function attempts to use a password callback function (specified by the `param_1` function pointer) to get a password to use for MAC verification. If the password callback function returns an error, an error message is printed and the function returns 0. If the MAC verification is successful."
openssl-101u,O1,x86,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_x86_gcc_O1_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@080f1a40.c,"The function checks if the input BIGNUM pointer has enough space allocated to store the uint values pointed to by the input uint pointer. If not, it expands the space allocated to the BIGNUM pointer to match the input integer. It then copies the uint values pointed to by the input uint pointer to the BIGNUM's data array, starting from the beginning of the array if the second input integer is less than 4. If the second input integer is greater than or equal to 4, it sets a byte variable to the second input integer minus 2 and two uint variables to 2 to the power of the byte variable and the integer value of the first input integer shifted to the right by the byte variable. It then copies the uint values pointed to by the input uint pointer to the BIGNUM."
openssl-101u,O1,x86,padlock_init,./data/decomp/openssl-101u_x86_gcc_O1_extraction/padlock_init@081a8550.c,"The ""padlock_init"" function checks if ""padlock_use_rng"" and ""padlock_use_ace"" are not equal to zero. If either is not equal to zero, the function returns true, indicating successful initialization. Otherwise, it returns false to indicate initialization failure."
openssl-101u,O1,x86,padlock_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O1_extraction/padlock_rand_bytes@081a7660.c,"The ""padlock_rand_bytes"" function generates a specified number of random bytes and returns an undefined 4-byte value. It takes a pointer to an undefined type and an integer representing the number of bytes to generate as parameters. 

If the requested number of bytes is less than 8, the function enters a loop that generates random bytes using the xstore_available function until the requested number of bytes is reached. The generated byte is stored at the address pointed to by the first parameter and the pointer is incremented. 

If the requested number of bytes is 8 or more, the function generates 8 bytes at a time until the requested number of bytes is reached. If the hardware random number generator is not available or there is an error, the function returns 0. 

The function also includes a check to ensure that the stack has not been corrupted."
openssl-101u,O1,x86,param_copy_gost94,./data/decomp/openssl-101u_x86_gcc_O1_extraction/param_copy_gost94@081d82c0.c,"The function param_copy_gost94 takes in two EVP_PKEY pointers as parameters, param_1 and param_2. It retrieves the DSA key from param_1 and the key parameters from param_2, checks if the base IDs of both parameters are the same, assigns the DSA key to param_1 if it is not already assigned, frees any existing BIGNUM values in the DSA key, duplicates the BIGNUM values from the key parameters into the DSA key, computes the corresponding public key if the DSA key has a private key, throws an error if the base IDs of the parameters are not the same, and returns a void pointer indicating success or failure."
openssl-101u,O1,x86,param_print_gost01,./data/decomp/openssl-101u_x86_gcc_O1_extraction/param_print_gost01@081d86e0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer, and extracts the EC_KEY and EC_GROUP objects from the EVP_PKEY object. It then prints the curve name of the EC_GROUP object to the BIO object with indentation specified by the third parameter. The function returns 1 if the printing was successful, otherwise it returns 0."
openssl-101u,O1,x86,param_print_gost94,./data/decomp/openssl-101u_x86_gcc_O1_extraction/param_print_gost94@081d8750.c,"The function takes in a BIO object for output, an EVP_PKEY object, and an integer for indentation. It obtains the public key from the EVP_PKEY object and stores it in a void pointer variable. It creates a new BIGNUM object and initializes it to 0. It checks if the parameter set for the GOST R 34.10-94 signature algorithm is defined in the R3410_paramset structure. If it is defined, it loops through the structure to compare the parameter set with the public key obtained earlier. If a match is found, it frees the BIGNUM object and stores the corresponding parameter set value in the iVar2 variable. If a match is not found, it sets the iVar2 variable to 0. It indents the output using the BIO_indent() function and prints the integer value of 1."
openssl-101u,O1,x86,pkey_ctrl_gost,./data/decomp/openssl-101u_x86_gcc_O1_extraction/pkey_ctrl_gost@081d90e0.c,"The `pkey_ctrl_gost` function takes four parameters: an `EVP_PKEY` pointer, an integer `param_2`, an integer `param_3`, and a `PKCS7_SIGNER_INFO` pointer `param_4`. It initializes a local variable `local_20` to the value stored at the memory location pointed to by the `GS_OFFSET` register plus 0x14 to check for stack overflows. The function switches on the value of `param_2`. If `param_2` is not one of the cases handled by the switch, the function returns -2 (0xfffffffe) and jumps to `LAB_081d9128`. If `param_2` is 1, the function sets two local variables `local_28` and `local_24` to NULL, gets the base ID of the key pointed to by `param_1`, and gets the algorithms."
openssl-101u,O1,x86,pkey_free_gost94,./data/decomp/openssl-101u_x86_gcc_O1_extraction/pkey_free_gost94@081d86c0.c,"The function takes an integer parameter `param_1` and frees the memory allocated to a DSA structure if it exists. It checks if the value stored at the memory location `param_1 + 0x14` (which is assumed to be a pointer to a DSA structure) is not equal to NULL. If it is not NULL, then the function calls `DSA_free()` function to free the memory allocated to the DSA structure. If the pointer is NULL, the function simply returns."
openssl-101u,O1,x86,priv_encode_gost,./data/decomp/openssl-101u_x86_gcc_O1_extraction/priv_encode_gost@081d9420.c,"The function takes two parameters: a PKCS8_PRIV_KEY_INFO structure pointer and an EVP_PKEY structure pointer. It returns an integer value. The function gets the base ID of the EVP_PKEY using the EVP_PKEY_base_id() function and converts it to an ASN1_OBJECT using the OBJ_nid2obj() function. Then, it calls the encode_gost_algor_params() function to get the parameters for the GOST algorithm and stores the result in pval. Next, it checks the base ID to determine if the EVP_PKEY is an EC_KEY or a BIGNUM. If it's an EC_KEY, it gets the private key using EC_KEY_get0_private_key() and stores it in bn. If it's a BIGNUM, it gets the BIGNUM from the EVP_PKEY and stores it in bn. Finally, it converts the BIGNUM to an ASN1_INTEGER using BN_to_ASN1_INTEGER() and stores the result in a."
openssl-101u,O1,x86,pub_encode_gost94,./data/decomp/openssl-101u_x86_gcc_O1_extraction/pub_encode_gost94@081d92d0.c,"The function encodes a GOST 94 public key into an X509_PUBKEY structure by getting the object ID of the GOST 94 algorithm and saving its parameters if specified. It then converts the GOST 94 public key into a binary format and creates an ASN1_OCTET_STRING from it. Finally, it sets the parameters and the binary data of the GOST 94 public key into the X509_PUBKEY structure using the X509_PUBKEY_set0_param function and returns an integer value indicating the success or failure of the operation. The function takes in two parameters: a pointer to the X509_PUBKEY structure and a pointer to the EVP_PKEY structure containing the GOST 94 public key."
openssl-101u,O1,x86,pub_print_gost94,./data/decomp/openssl-101u_x86_gcc_O1_extraction/pub_print_gost94@081d8840.c,"The function extracts a public key from an EVP_PKEY object and prints it to a BIO object. It then searches for a matching parameter set and prints the name to the BIO object if found, or ""Parameter set: "" if not found. The function returns 1."
openssl-101u,O1,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O1_extraction/RSA_padding_add_PKCS1_PSS@081e3950.c,"The first function, RSA_padding_add_PKCS1_PSS, adds padding to a message using the PKCS1 PSS scheme for RSA encryption. It takes in an RSA object pointer, message hash pointer, hash function pointer, and salt length as input. The function calculates the hash size and checks the validity of the salt length. It generates a random salt of the appropriate length if the salt length is -2. It initializes an EVP_MD_CTX object and initializes the hash function. It updates the hash with the appropriate values and generates the mask using the PKCS1 MGF1 function. It XORs the mask with the salt and places the result in the appropriate location in the message. It sets the appropriate header bytes and returns 1 if successful.

The second function takes in a pointer to a memory location and a size value. It checks if the pointer is within the range of the stack memory by comparing it with the stack pointer and the global variable _GS_OFFSET. If the pointer is not within the stack memory range, it calls the __stack_chk_fail() function, which terminates the program. If the pointer is within the stack memory range, it returns the size value passed as a parameter."
openssl-101u,O1,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O1_extraction/RSA_verify_PKCS1_PSS@081e3030.c,"The function RSA_verify_PKCS1_PSS verifies a signature generated using PSS with RSA. It takes in the RSA public key, message hash, hash function used, signature, and signature length. The function initializes an EVP_MD_CTX structure, checks the signature length and hash output size, computes the RSA modulus size, checks padding bits, and extracts the mask used in signature generation. It XORs the mask with the signature to obtain the encoded message and checks for non-zero padding bits or the first byte of the encoded message."
openssl-101u,O1,x86,sha_block_data_order,./data/decomp/openssl-101u_x86_gcc_O1_extraction/sha_block_data_order@081dcdc0.c,"The functions are implementing the SHA-1 hashing algorithm to process a block of data or a message and produce a fixed-size output hash value. They operate on 512-bit blocks of data or messages at a time and use a series of bitwise and arithmetic operations to transform the input into the output hash value. The final output is a 160-bit hash value. The functions initialize several variables with constants and initial values and then loop through each block of data or message, performing a series of operations on each block to update the values of the variables. These operations include bitwise shifts, bitwise OR and XOR operations, addition, and multiplication. At the end of each block, the updated values of the variables are combined using additional bitwise and arithmetic operations to produce the final hash value. One of the functions takes in a pointer to a character array (string) and an integer and counts the number of times the integer appears in the string."
openssl-101u,O1,x86,SHA_Final,./data/decomp/openssl-101u_x86_gcc_O1_extraction/SHA_Final@081de090.c,"The SHA_Final function is the final step in the SHA-1 hashing process. It takes in a message digest (md) and a SHA_CTX structure (c) that contains the intermediate hash values and other information. First, it retrieves the number of bytes processed so far (c->num) and the data buffer (c->data). It appends a 1 bit to the data buffer and pads it with zeros until there are only 8 bytes remaining. If there are not enough bytes to append the padding, it processes the current block and starts a new one. Next, it sets the last two 32-bit words of the data buffer to the high and low bits of the total number of bits processed. It then processes the final block of data using the sha_block_data_order function. After the final block is processed, it retrieves the intermediate hash values from the SHA_CTX structure and stores them in the message digest buffer (md). It then cleans up the SHA_CTX structure and returns."
openssl-101u,O1,x86,srp_verify_server_param,./data/decomp/openssl-101u_x86_gcc_O1_extraction/srp_verify_server_param@080cee70.c,"The function takes in two parameters: an integer and a pointer to an undefined 4-byte value. It compares two BIGNUM values stored at specific offsets within the integer parameter. If the first value is greater than or equal to the second value, or if another BIGNUM value is equal to zero, the function sets the value pointed to by the second parameter to 0x2f and returns 0. If the number of bits in one of the BIGNUM values is less than a value stored at a specific offset within the integer parameter, the function sets the value pointed to by the second parameter to 0x47 and returns 0. If neither of the above conditions are met, the function checks whether a specific function pointer stored at an offset within the integer parameter is null. If it is null, the function checks whether the BIGNUM value is less than a value stored at another offset within the integer parameter. If it is less than, the function sets the value pointed to by the second parameter to 0x5a and returns 0. If it is not less than, the function sets the value pointed to by the second parameter to 0x6b and returns 0."
openssl-101u,O1,x86,SSLv23_method,./data/decomp/openssl-101u_x86_gcc_O1_extraction/SSLv23_method@080a84e0.c,The SSLv23_method function returns a pointer to an SSL_METHOD data structure named SSLv23_method_data_15764. It does not have any parameters and its calling convention is unknown.
openssl-101u,O1,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_x86_gcc_O1_extraction/SSL_SESSION_free.part.2@080c3230.c,"The function frees an SSL session object and its associated data. It first frees any custom data associated with the object using CRYPTO_free_ex_data(). It then cleanses certain memory areas using OPENSSL_cleanse(), which overwrites the memory with zeroes to prevent sensitive data from remaining in memory. Next, it frees any certificate information, private keys, and other data associated with the session. Finally, it cleanses the entire session object and frees it using CRYPTO_free()."
openssl-101u,O1,x86,start_hash,./data/decomp/openssl-101u_x86_gcc_O1_extraction/start_hash@081dc670.c,"The function takes a pointer to an array of 32-bit integers as its parameter. If the value at index 2 of the array is not equal to 0, the function initializes various elements of the array to 0, including setting the values at indices 4 and 11 to 0 and initializing two blocks of memory. Finally, it sets the values at indices 0, 1, and 3 to 0 and returns 1. If the value at index 2 of the array is equal to 0, the function simply returns 0."
openssl-101u,O1,x86,surewarehk_finish,./data/decomp/openssl-101u_x86_gcc_O1_extraction/surewarehk_finish@081a36a0.c,"1. Check if surewarehk_dso is null
2. If it is null, set SUREWARE_lib_error_code to the next error code in the library and return an error code
3. If it is not null, call the p_surewarehk_Finish function, free the surewarehk_dso object, and set SUREWARE_lib_error_code to the next error code in the library if it is null. If freeing the surewarehk_dso object fails, set SUREWARE_lib_error_code to the next error code in the library and return an error code
4. Free the logstream object
5. Set all function pointers to null and return a success code"
openssl-101u,O1,x86,sv_body,./data/decomp/openssl-101u_x86_gcc_O1_extraction/sv_body@08068440.c,"The functions described handle SSL connections and involve initializing SSL context and objects, setting up the listening socket, performing SSL handshake and data transfer operations, handling various commands received from the client, and appropriately handling errors. The functions also involve creating a buffer to store incoming data, setting up various SSL options, and cleaning up the SSL connection and freeing the buffer used for data storage. The functions take in parameters such as a socket file descriptor and an SSL context."
openssl-101u,O1,x86,TLSv1_method,./data/decomp/openssl-101u_x86_gcc_O1_extraction/TLSv1_method@080aa220.c,"The function returns a pointer to the SSL_METHOD data structure for the TLSv1 protocol, which defines the methods used by the SSL/TLS protocol for a specific version. It does this by accessing the global variable TLSv1_method_data_15770, which contains the data structure for the TLSv1 protocol."
openssl-101u,O1,x86,__libc_csu_init,./data/decomp/openssl-101u_x86_gcc_O1_extraction/__libc_csu_init@081ea170.c,"The function __libc_csu_init initializes the C runtime environment for the program. It calls the _init() function to initialize the C library. It then loops through the __frame_dummy_init_array_entry array and calls each function in the array with the parameters param_1, param_2, and param_3. This array contains functions registered by the linker to be called during program startup. The function uses a do-while loop to iterate through the array, starting at index 0 and incrementing the index until it reaches the end of the array. Once it has called all the functions in the array, it returns. The warning message at the beginning of the function is related to a security feature in some compilers that replaces the get_pc_thunk_bx function with an injected version. This warning indicates that the original function has been replaced with the injected version."
openssl-101u,O1,x86,__udivdi3,./data/decomp/openssl-101u_x86_gcc_O1_extraction/__udivdi3@081e9ee0.c,"The function takes in four unsigned integers as parameters: param_1, param_2, param_3, and param_4. It returns an unsigned 64-bit integer (ulonglong) as the result of dividing param_1 and param_2 by param_3 and param_4. If param_4 is 0, the function first checks if param_2 is less than param_3. If it is, it returns the result of dividing the concatenation of param_2 and param_1 by param_3, masked with 0xffffffff. Otherwise, it calculates the quotient of param_2 divided by param_3 and the remainder of that division as a 64-bit integer, and then divides the concatenation of param_2 and param_1 by param_3, returning the quotient as an unsigned 32-bit integer. If param_4 is not 0, the function first checks if param_2 is less than param_4."
openssl-101u,O2,x86,aep_mod_exp.part.0,./data/decomp/openssl-101u_x86_gcc_O2_extraction/aep_mod_exp.part.0@0819cda0.c,"The `aep_mod_exp_part_0` function implements modular exponentiation using a hardware accelerator and takes five parameters. It first tries to obtain a connection to the hardware accelerator using `aep_get_connection`. If successful, it performs the modular exponentiation using the `p_AEP_ModExp` function and updates the connection table. If the operation fails, it falls back to using software (i.e., `BN_mod_exp`). If `aep_get_connection` fails, it updates the error code and uses software. Overall, the function provides a more efficient way to perform modular exponentiation."
openssl-101u,O2,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_x86_gcc_O2_extraction/asn1_bio_callback_ctrl@081e50a0.c,"The `asn1_bio_callback_ctrl` function takes three parameters: `param_1`, `param_2`, and `param_3`. The first parameter is a memory address that contains a pointer to a `BIO` structure. The function checks if the pointer is not null and calls the `BIO_callback_ctrl` function with the `BIO` pointer, `param_2`, and `param_3`. If the pointer is null, the function returns 0. This function provides a callback control function for ASN1 BIOs."
openssl-101u,O2,x86,asn1_bio_ctrl,./data/decomp/openssl-101u_x86_gcc_O2_extraction/asn1_bio_ctrl@081e5160.c,"The function takes in a bio_st structure pointer, an integer parameter, a long parameter, and an integer pointer. It checks if the pointer to the bio_st structure is null and returns 0 if it is. If the integer parameter is 0x97, it sets two values in the bio_st structure based on the integer pointer parameter and returns 1. If the integer parameter is less than 0x98, it checks if the parameter is 0x95. If it is, it sets two values in the bio_st structure based on the integer pointer parameter and returns 1. If the parameter is greater than 0x95, it retrieves two values from the bio_st structure and sets them in the integer pointer parameter before returning 1. If the parameter is 0xb, it checks if the next_bio field in the bio_st structure is null and returns 0 if it is. It then checks the value of the first integer in the bio_st structure."
openssl-101u,O2,x86,asn1_bio_free,./data/decomp/openssl-101u_x86_gcc_O2_extraction/asn1_bio_free@081e50c0.c,"The function takes an integer parameter and accesses a structure containing a pointer to a memory location. If the pointer is not null, it checks if another pointer located at an offset of 4 bytes from the first pointer is also not null. If it is not null, it frees the memory pointed to by that pointer and then frees the memory pointed to by the original pointer. It sets several fields of the structure to null and returns 1. If the original pointer is null, the function returns 0."
openssl-101u,O2,x86,asn1_bio_write,./data/decomp/openssl-101u_x86_gcc_O2_extraction/asn1_bio_write@081e5460.c,"The function takes a BIO object, a pointer to data, and a length as input parameters. It checks if the input parameters are valid and if the next BIO object is set. If not, it returns an error code. It then checks the state of the BIO object and performs the necessary actions based on that state. The state can be one of five possible values, which are represented by the values of the `uVar4` variable. The possible states are: 0, 1, 2, 3, and 4. If the state is 0, it transitions to state 1 and calculates the size of the ASN.1 object header. It then checks if the buffer size is sufficient to hold the header and the remaining data. If not, it returns an error code."
openssl-101u,O2,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BIO_asn1_get_suffix@081e5870.c,"The function `BIO_asn1_get_suffix` takes a `BIO` object `b` and two pointers to `undefined1` variables `psuffix` and `psuffix_free` and returns an integer value. It initializes a local variable `local_10` and calls the `BIO_ctrl` function with arguments `b`, `0x98`, `0`, and the address of the `local_18` variable. If the return value of `BIO_ctrl` is greater than 0, the function sets the value of `psuffix` to the value of `local_18` and sets the value of `psuffix_free` to`."
openssl-101u,O2,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BIO_asn1_set_prefix@081e5770.c,"The function takes a BIO object (b) and two pointers (prefix and prefix_free) and sets the prefix for the ASN.1 encoding in the BIO object by calling the BIO_ctrl function with the control command 0x95 and passing in a pointer to the prefix pointer. It returns the result of the BIO_ctrl call, but if there is a stack check failure, the function does not return."
openssl-101u,O2,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_get0_nist_prime_224@081e58e0.c,"The function returns a pointer to a BIGNUM structure that contains a pre-defined prime number used in the NIST P-224 elliptic curve cryptography algorithm. The value is stored in a static array named ""_bignum_nist_p_224""."
openssl-101u,O2,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_get0_nist_prime_384@081e5900.c,"The function returns a pointer to a BIGNUM object that contains the NIST prime number for the P-384 elliptic curve. The prime number is stored in memory as a constant array of bytes accessed through a global variable named ""_bignum_nist_p_384"". The function has no parameters and may not modify any of its arguments. The calling convention is unknown."
openssl-101u,O2,x86,BN_GF2m_add,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_add@081dfc60.c,"The function BN_GF2m_add adds two binary polynomials represented as BIGNUMs (large integers) in the field GF(2^m) and stores the result in the first BIGNUM parameter. The function takes three parameters: the first parameter is a pointer to the BIGNUM where the result will be stored, and the second and third parameters are pointers to the two BIGNUMs to be added. The function determines which of the two input BIGNUMs has the larger number of words and expands the first BIGNUM parameter to that size if necessary using the bn_expand2 function. It then XORs the words of the two input BIGNUMs together, starting from the least significant word, and stores the result in the first BIGNUM parameter. If the resulting number has any leading zero words, they are removed by adjusting the top field of the BIGNUM parameter. The function returns 1 if."
openssl-101u,O2,x86,BN_GF2m_mod,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod@081dfe00.c,"The function BN_GF2m_mod takes in two BIGNUM pointers and an integer pointer, and returns an undefined value. It checks if the second parameter has a non-zero value in the second element of the integer pointer. If it does not, an error message is printed and the function returns 0. If the second parameter has a non-zero value in the second element of the integer pointer, the function proceeds to calculate the indices of the non-zero bits in the second parameter and stores them in an array called local_38. If the first element of local_38 is 0, then the first parameter is set to 0 and the function returns 1. Otherwise, if the first parameter is not equal to the second parameter, the function checks if the first parameter has enough memory allocated to hold the values of the second parameter. If it does not, the function expands the memory allocated to the first parameter. The function then calls the BN_GF."
openssl-101u,O2,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_arr@081dfd60.c,"The function takes in three parameters: two BIGNUM pointers (param_1 and param_2) and an integer pointer (param_3). It returns an undefined value. It first checks if the integer pointed to by param_3 is 0. If it is, it sets the value of param_1 to 0 using the BN_set_word function and returns 1. If param_3 is not 0, the function checks if param_1 and param_2 are the same. If they are not, it expands the size of param_1 to match the size of param_2 using the bn_expand2 function. If bn_expand2 returns null, the function returns 0. The function then copies the values of param_2 into param_1, and sets the top value of param_1 to the top value of param_2. Finally, the function calls the BN_GF2m_mod_arr_part_0 function and returns its value."
openssl-101u,O2,x86,BN_GF2m_mod_div,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_div@081e1700.c,"The function BN_GF2m_mod_div() takes in five parameters: three undefined 4-byte values, a BIGNUM pointer, and a BN_CTX pointer. It returns an unsigned integer. The function starts by calling BN_CTX_start() to initialize the BN_CTX object. It then calls BN_GF2m_mod_inv() to calculate the inverse of param_4 modulo param_3 and stores the result in a BIGNUM object pointed to by pBVar2. If pBVar2 is null or if the inverse calculation fails, the function sets uVar7 to 0 and jumps to a label called LAB_081e1744. If the inverse calculation succeeds, the function calculates the number of bits in param_4 and adds 1 to get the size of an array it needs to allocate. It then allocates this array using CRYPTO_malloc() and stores a pointer to it in ptr. If the allocation fails, the function sets uVar7 to 0 and jumps."
openssl-101u,O2,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_div_arr@081e18b0.c,"The function BN_GF2m_mod_div_arr takes in four parameters: param_1, param_2, param_3, and param_4, as well as a BN_CTX object param_5. It initializes a BIGNUM object a to 0 and sets certain bits based on the values in param_4. It then initializes another BIGNUM object pBVar3 and computes its inverse mod param_3 using BN_GF2m_mod_inv. Next, the function allocates memory for a buffer ptr and calculates the indices of the set bits in a, storing them in ptr. Using BN_GF2m_mod_mul_arr, the function multiplies param_1 and param_2 with pBVar3 and the set bits in a (stored in ptr) to compute the result of the division. The function returns 1 if the division was successful, and 0 otherwise."
openssl-101u,O2,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_mul@081e0dc0.c,"The OpenSSL library function BN_GF2m_mod_mul performs modular multiplication in a binary field GF(2^m). It takes five arguments, including a pointer to a BIGNUM structure. The function calculates the number of bits in the input BIGNUM, loops through the words in the BIGNUM, and checks each bit in the word. If the input BIGNUM is zero, an error is generated. Otherwise, the function calls the BN_GF2m_mod_mul_arr function with allocated memory as an argument. Finally, the memory is freed, and the function returns the result of the BN_GF2m_mod_mul_arr function."
openssl-101u,O2,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_mul_arr@081e0190.c,"The first function, BN_GF2m_mod_mul_arr, is used in OpenSSL's implementation of elliptic curve cryptography over binary fields. It performs multiplication of two binary polynomials represented as arrays of integers in GF(2^m) field and reduces the result modulo a given irreducible polynomial. The function takes five parameters: a pointer to a BIGNUM struct where the result of the multiplication will be stored, pointers to arrays of integers representing the two binary polynomials to be multiplied, a pointer to an integer representing the degree of the irreducible polynomial used for reduction, and a pointer to a BN_CTX struct used for temporary variables during the computation. 

The second function takes in three arguments: a pointer to an input buffer, a pointer to an output buffer, and a pointer to an array of integers. It then performs a series of bitwise operations on the input buffer using the array of integers as a lookup table, and stores the result in the output buffer.

The third function takes in five parameters: a BIGNUM pointer, two arrays of BIGNUMs, a pointer to an integer, and a BN_CTX pointer. It returns a boolean value. The function initializes some local variables and sets up the BN_CTX. It then checks if the fourth parameter is zero, and if so, sets the first parameter to zero and returns true. If the fourth parameter is not zero, the function checks if the first parameter needs to be expanded to fit the size of a second BIGNUM pointer. If it does, the function expands the first parameter. The function then enters a loop that iterates over the elements."
openssl-101u,O2,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_sqr@081e0f10.c,"The BN_GF2m_mod_sqr function in OpenSSL library performs squaring operations on binary polynomials over the Galois field GF(2^m). It takes four parameters of type undefined4 and BIGNUM. The function calculates the number of bits in the input polynomial and allocates memory for an array. If the input polynomial is not zero, the function stores the positions of the non-zero coefficients in the allocated array and sets the last element of the array to 0xffffffff. The function then checks if the size of the array is less than or equal to the calculated size and calls another function if it is."
openssl-101u,O2,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_sqrt@081e1eb0.c,"The function BN_GF2m_mod_sqrt() computes the square root of a binary polynomial in GF(2^m) using the Berlekamp algorithm. It takes four input parameters: a BIGNUM pointer param_1 to hold the result, an integer param_2 specifying the degree of the polynomial, a BIGNUM pointer param_3 representing the binary polynomial, and a BN_CTX pointer param_4 for temporary storage. The function first calculates the number of bits in the polynomial and allocates memory for an array of integers to hold the exponents of the nonzero coefficients. It then loops through the coefficients of the polynomial, adding the exponent of each nonzero coefficient to the array. If the array is not empty, the function sets the most significant bit of a new BIGNUM to 1 and performs a modular exponentiation using BN_GF2m_mod_exp_arr() to compute the square root. The resulting BIGNUM is stored in param_1. If the array is empty or..."
openssl-101u,O2,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_GF2m_mod_sqr_arr@081dff80.c,"The function BN_GF2m_mod_sqr_arr takes four parameters: a BIGNUM pointer, two integer pointers, and a BN_CTX pointer. It returns a boolean value. The function first starts a BN_CTX context and gets a BIGNUM pointer from it. If the BIGNUM pointer is NULL, the function returns false. Then, the function checks if the size of the BIGNUM is less than twice the size of the second integer parameter. If it is, the function expands the BIGNUM to twice the size of the second integer parameter. Next, the function iterates through the integers pointed to by the second integer parameter and squares each one using a lookup table called SQR_tb. The resulting values are stored in the BIGNUM pointer. The function then sets the top value of the BIGNUM pointer to twice the size of the second integer parameter and removes any leading zero words. If the third integer parameter is zero, the function sets the first parameter to zero."
openssl-101u,O2,x86,BN_kronecker,./data/decomp/openssl-101u_x86_gcc_O2_extraction/BN_kronecker@081deef0.c,"The function BN_kronecker(a,b,ctx) computes the Kronecker symbol of two BIGNUMs a and b using the binary algorithm. It initializes two BIGNUMs a_00 and a_01 as copies of a and b, respectively, using the BN_copy function. It checks for any errors in the initialization and returns -2 if an error occurs. Next, it checks if either a or b is zero or one, and returns the appropriate value of the Kronecker symbol. If not, it performs some bit manipulations to compute the Kronecker symbol using the binary algorithm. Specifically, it finds the highest bit set in b using BN_is_bit_set and BN_rshift, and shifts b to the right by that amount. It also computes the value of the Kronecker symbol for the lowest bit of a using a lookup table, and sets a flag local_24 accordingly. It then iteratively performs the binary algorithm, shifting a."
openssl-101u,O2,x86,by_dir_entry_free,./data/decomp/openssl-101u_x86_gcc_O2_extraction/by_dir_entry_free@08166860.c,"The function takes a double pointer as input (param_1), which is used to store information about a directory entry. If the pointer is not null, the function first frees the memory pointed to by the pointer using CRYPTO_free(). The function then checks if the third element of the pointer (param_1[2]) is not null. If it is not null, it frees the memory pointed to by the third element using sk_pop_free() function with a custom free function by_dir_hash_free(). This function is used to free any memory allocated to the hash table used by the directory entry. Finally, the function frees the memory used by the pointer itself using CRYPTO_free() and returns."
openssl-101u,O2,x86,cswift_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O2_extraction/cswift_rand_bytes@0819edc0.c,"The function `cswift_rand_bytes` generates a specified number of random bytes using the CryptoSwift cryptographic library. It takes as input a pointer to a buffer where the random bytes will be stored and the number of bytes to generate. The function acquires an access context using the `CSwift_AcquireAccContext` function and generates the random bytes in chunks of 1024 bytes or less using the `CSwift_SimpleRequest` function. If the requested number of bytes is less than 1024, the function generates the remaining bytes in a single chunk. Once the random bytes have been generated, the function copies them into the buffer specified by the input parameter. If the requested number of bytes is not a multiple of 4, the function handles the remaining bytes separately. If any errors occur during the random byte generation process, the function sets a global error code and returns 0. Otherwise, it returns 1 to indicate success."
openssl-101u,O2,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_x86_gcc_O2_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9f40.c,"The function takes in three parameters: a pointer to a pointer of an ASN1_VALUE, a double pointer to an unsigned character, and a long integer. It calls the ASN1_item_d2i function with the parameters passed in, along with an ASN1_ITEM structure pointer of type GOST_CLIENT_KEY_EXCHANGE_PARAMS_it, to decode the data from the unsigned character buffer and store it in the ASN1_VALUE structure pointed to by the first parameter. This function is used to decode GOST client key exchange parameters from a binary format into an ASN.1 structure. It returns nothing."
openssl-101u,O2,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_x86_gcc_O2_extraction/d2i_GOST_KEY_PARAMS@081d9e40.c,"The function deserializes an ASN.1 encoded data stream into a C data structure (GOST_KEY_PARAMS) using the ASN1_item_d2i() function. It takes in a pointer to an ASN1_VALUE, a pointer to an unsigned character buffer, and a long integer as parameters, and returns nothing. The deserialized data is stored in the GOST_KEY_PARAMS structure pointed to by the ASN1_VALUE pointer."
openssl-101u,O2,x86,decode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O2_extraction/decode_gost_algor_params@081d79d0.c,"The function decodes parameters for a GOST algorithm from an EVP_PKEY and X509_ALGOR. It extracts algorithm parameters from X509_ALGOR and converts the ASN1_OBJECT representation of the parameters into a GOST_KEY_PARAMS using d2i_GOST_KEY_PARAMS. If successful, it sets the EVP_PKEY type to the corresponding GOST algorithm type using EVP_PKEY_set_type. If the algorithm is GOST R 34.10-2001, it creates a new EC_KEY structure and fills it with the parameters using fill_GOST2001_params. If the algorithm is GOST R 34.10-94, it creates..."
openssl-101u,O2,x86,DES_xcbc_encrypt,./data/decomp/openssl-101u_x86_gcc_O2_extraction/DES_xcbc_encrypt@081de220.c,"The functions `DES_xcbc_encrypt` and the function implementing CBC mode encryption using the DES algorithm both take in plaintext, its length, a key, and an initialization vector (IV). They both process the input data in blocks of 8 bytes, XORing each block with the previous ciphertext block (or IV for the first block), and then applying the encryption algorithm to produce the ciphertext block. The resulting ciphertext is written to an output buffer. Both functions update the IV to be the last block of ciphertext produced and then return. The main difference is that `DES_xcbc_encrypt` is an implementation of the DES-XCBC encryption algorithm and takes two additional constants as input."
openssl-101u,O2,x86,dgram_ctrl,./data/decomp/openssl-101u_x86_gcc_O2_extraction/dgram_ctrl@0811e8c0.c,"The functions `dgram_ctrl` and `-` both take in multiple parameters and perform different actions based on the values of some of those parameters. `dgram_ctrl` uses a switch statement to determine what action to take, while `-` uses if statements. Both functions also perform error checking and return -1 if any errors occur."
openssl-101u,O2,x86,dlfcn_bind_func,./data/decomp/openssl-101u_x86_gcc_O2_extraction/dlfcn_bind_func@081e4600.c,"The function takes two parameters, param_1 and param_2. It checks if either of them are equal to 0, and if so, sets the variable line to 0x109 and iVar1 to 0x43. If not, it gets the number of elements in the stack pointed to by the value at (param_1 + 4) and stores it in iVar1. If iVar1 is less than 1, it sets line to 0x10d and iVar1 to 0x69. If not, it gets the value at the top of the stack and stores it in pvVar2. If pvVar2 is not equal to 0x0, it calls dlsym with the arguments pvVar2 and param_2 and stores the result in iVar1. If iVar1 is equal to 0, it calls ERR_put_error with the arguments 0x25, 100, 0x6a, ""dso""."
openssl-101u,O2,x86,dlfcn_bind_var,./data/decomp/openssl-101u_x86_gcc_O2_extraction/dlfcn_bind_var@081e4700.c,"The ""dlfcn_bind_var"" function takes two parameters, ""param_1"" and ""param_2"", and binds a variable to a dynamic library symbol using the dlfcn interface. It checks if either parameter is zero and generates an error and returns 0 if so. If both parameters are non-zero, it retrieves the number of elements in a stack pointed to by ""param_1"". If the number of elements is less than 1, an error is generated and the function returns 0. If the number of elements in the stack is greater than or equal to 1, it retrieves the value of the last element and attempts to bind the variable pointed to by ""param_2"" to the dynamic library symbol using the dlsym function. If the binding is successful, it returns the result of the dlsym."
openssl-101u,O2,x86,dlfcn_globallookup,./data/decomp/openssl-101u_x86_gcc_O2_extraction/dlfcn_globallookup@081e4320.c,"The function takes in a single parameter of type undefined4 and returns an undefined4 value. It first calls the dlopen function with a NULL argument and the flag 1, which means the library will be loaded in a way that symbols defined by this library will be made available for symbol resolution of subsequently loaded libraries. The return value of dlopen is stored in the integer variable iVar1. If dlopen fails (returns 0), the function returns 0. If dlopen succeeds, the function calls dlsym with the handle returned by dlopen and the parameter passed in to the function. The return value of dlsym is stored in the variable uVar2. Finally, the function calls dlclose with the handle returned by dlopen. The purpose of the function is to look up a symbol by name in the global symbol table and return its address."
openssl-101u,O2,x86,doapr_outch.constprop.0,./data/decomp/openssl-101u_x86_gcc_O2_extraction/doapr_outch.constprop.0@0811a260.c,"The function `doapr_outch_constprop_0` takes in four arguments: two pointers to pointers, and two pointers to unsigned integers. It returns an unsigned integer. The function first checks if the second argument is NULL or if the value at the third argument is not equal to the value at the fourth argument. If either of these conditions is true, it jumps to a label `LAB_0811a278` and checks if the value at the fourth argument is greater than the value at the third argument. If it is, the function returns 1. Otherwise, it checks if the value at the first argument is not NULL. If it is, it returns 0. If it is not NULL, it jumps to another label `LAB_0811a286`. If the second argument is not NULL and the value at the third argument is equal to the value at the fourth argument, the function checks if the value at the third argument is greater than 0x7ffffbff."
openssl-101u,O2,x86,dtls1_link_min_mtu,./data/decomp/openssl-101u_x86_gcc_O2_extraction/dtls1_link_min_mtu@080bb4c0.c,"The function returns a constant value of 0x100, which is the minimum acceptable MTU size for a DTLS link."
openssl-101u,O2,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_mont_field_encode@081e2b20.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The integer parameter is used to access a BN_MONT_CTX pointer stored at a specific offset within a larger data structure. The function first checks if the BN_MONT_CTX pointer is not NULL. If it is not NULL, it uses the BN_mod_mul_montgomery function to encode the second BIGNUM parameter using the Montgomery representation defined by the BN_MONT_CTX pointer. The result is stored in the first BIGNUM parameter. If the BN_MONT_CTX pointer is NULL, the function generates an error message using the ERR_put_error function and returns 0."
openssl-101u,O2,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_mont_field_sqr@081e2ac0.c,"The function takes in four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. It first checks if the BN_MONT_CTX pointer at offset 0xa0 of the integer parameter is not null. If it is not null, it performs a modular multiplication of the second and third parameters using the BN_mod_mul_montgomery function and the BN_MONT_CTX pointer, and returns the result. If the BN_MONT_CTX pointer is null, it adds an error to the error queue using the ERR_put_error function and returns 0."
openssl-101u,O2,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_mont_group_init@081e26d0.c,"The function `ec_GFp_mont_group_init` initializes a Montgomery curve group in the context pointed to by `param_1`. It first calls the `ec_GFp_simple_group_init` function to initialize the underlying simple curve group. Then, it sets two additional fields in the context to zero: `*(undefined4 *)(param_1 + 0xa0)` and `*(undefined4 *)(param_1 + 0xa4)`. These fields are likely used for Montgomery-specific operations. Finally, the function returns."
openssl-101u,O2,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_nist_field_mul@081e2e50.c,"The function is a multiplication operation for elliptic curve cryptography over a finite field. It takes in four parameters: an integer representing the curve parameter, and three BIGNUMs representing the values to be multiplied. It also takes in a BN_CTX pointer for memory allocation. The function first checks if all the parameters are valid, and if not, it logs an error. If a valid BN_CTX pointer is not provided, it creates a new one. It then performs the multiplication operation using BN_mul() and stores the result in the first BIGNUM parameter. Finally, it performs a modular reduction using a code pointer obtained from the curve parameter and returns the result as a boolean value indicating success or failure. If a new BN_CTX was created, it is freed before the function returns."
openssl-101u,O2,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_nist_group_copy@081e2c50.c,"The function `ec_GFp_nist_group_copy` copies a 4-byte integer from `param_2` to `param_1` at offset 0xa8, and then copies the rest of the data structure using `ec_GFp_simple_group_copy()`. It does not return any value."
openssl-101u,O2,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_nist_group_set_curve@081e2c70.c,"The function `ec_GFp_nist_group_set_curve` takes in five parameters: an integer `param_1`, a pointer to a `BIGNUM` object `param_2`, two `undefined4` values `param_3` and `param_4`, and a pointer to a `BN_CTX` object `param_5`. If `param_5` is null, it creates a new `BN_CTX` object and starts it. It then gets a `BIGNUM` object from the context and sets `pBVar1` to the NIST prime 192-bit value. It compares `pBVar1` with `param_2` using `BN_ucmp` and if they are equal, it sets a function pointer in `param_1 + 0xa8` to `BN_nist_mod_192` and calls `ec_GFp_simple_group_set_curve` with the parameters `param`."
openssl-101u,O2,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e77c0.c,"The function takes in 6 parameters: an integer pointer, an integer, and 4 BIGNUM pointers. It returns a boolean value. The function checks if a certain value in the memory pointed to by the integer pointer is equal to zero. If it is, then it checks if the BIGNUM pointers param_3, param_4, and param_5 are not null, and if they are not null, it copies the values from memory into the BIGNUM pointers and returns true. If param_5 is null, it simply returns true. If the value in memory pointed to by the integer pointer is not zero, then it creates a BN_CTX object if one was not provided as the 6th parameter. It then checks if the BIGNUM pointers param_3, param_4, and param_5 are not null, and if they are not null, it calls a function pointer stored in memory to compute the values and store them in the BIGNUM."
openssl-101u,O2,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_group_check_discriminant@081e7990.c,"The function checks the validity of the discriminant of an elliptic curve group defined by parameters in `param_1`, using the formula `disc = -16(4a^3 + 27b^2)`. It initializes a `BN_CTX` context for intermediate calculations, retrieves the `a` and `a_00` parameters from `param_1`, and checks if `a` is zero. If `a` is zero, it checks if `a_00` is non-null. If the discriminant is zero, the curve is singular and not suitable for cryptographic use."
openssl-101u,O2,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_group_clear_finish@081e7420.c,"The function `ec_GFp_simple_group_clear_finish` takes an integer parameter `param_1`, which is likely a pointer to a data structure representing an elliptic curve group. The function then clears and frees three big numbers (BIGNUMs) associated with the group using the `BN_clear_free` function. These big numbers are located at offsets `0x48`, `0x74`, and `0x88` from the start of the data structure. The function then returns."
openssl-101u,O2,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_group_copy@081e8570.c,"The function ec_GFp_simple_group_copy takes two parameters, param_1 and param_2, and copies BIGNUM values from param_2 to param_1 at offsets 0x48, 0x74, and 0x88. If successful, it also copies the value at offset 0x9c from param_2 to param_1 and returns 1. If any copy operation fails, it returns 0."
openssl-101u,O2,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_group_get_degree@081e7490.c,"The function takes an integer parameter, likely a pointer to a structure representing an elliptic curve group, and calculates the degree of the group by calling the BN_num_bits() function on a BIGNUM structure located at offset 0x48 from the beginning of the group structure. The degree of the group is then returned."
openssl-101u,O2,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_group_set_curve@081e8660.c,"The `ec_GFp_simple_group_set_curve` function sets the parameters of an elliptic curve group over a prime field. It takes in four pointers to various BIGNUM values representing the parameters of the curve, as well as a BN_CTX pointer for temporary storage during computation. The function checks that the prime modulus is valid and creates a new BN_CTX object if one is not provided. It then computes the curve parameters and returns 1 if successful."
openssl-101u,O2,x86,ec_GFp_simple_invert,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_invert@081e9390.c,"The function takes an EC_GROUP object and an EC_POINT object as input. It checks if the point is at infinity using EC_POINT_is_at_infinity function. If the point is not at infinity and the y-coordinate of the point is not zero, it calculates the inverse of the point using BN_usub function. The function returns 1 if the point is at infinity or if the y-coordinate is zero. Otherwise, it returns the result of the BN_usub function."
openssl-101u,O2,x86,EC_GFp_simple_method,./data/decomp/openssl-101u_x86_gcc_O2_extraction/EC_GFp_simple_method@081e9ed0.c,The EC_GFp_simple_method() function returns a pointer to an EC_METHOD structure in OpenSSL's elliptic curve cryptography library. It does not take any parameters and its calling convention is unknown. The specific implementation of the structure is not shown in the provided code.
openssl-101u,O2,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_point_copy@081e85f0.c,"The function ""ec_GFp_simple_point_copy"" is part of a larger program related to elliptic curve cryptography. It takes in two integer parameters. The function creates a pointer to a BIGNUM structure and uses the BN_copy function to copy the contents of three BIGNUM structures located at specific memory addresses from the second parameter to corresponding memory addresses in the first parameter. The function checks if the pointer to the copied BIGNUM structure is not null."
openssl-101u,O2,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_point_finish@081e73f0.c,"The function takes an integer parameter representing a point on an elliptic curve and frees three BIGNUM objects (representing the x, y, and z coordinates of the point) using the BN_free function from the OpenSSL library. It then returns, serving as a cleanup function for freeing memory associated with a point on an elliptic curve."
openssl-101u,O2,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7c00.c,"The function computes the affine coordinates of an EC point given an EC group and an optional BN_CTX object. It first checks if the point is at infinity and returns an error if it is. It then initializes a BN_CTX object if one was not provided and uses it to allocate temporary storage. The function checks if the group has a precomputed table of inverses and uses it to compute the inverse of the x-coordinate of the point. Otherwise, it uses BN_mod_inverse. The function then computes the y-coordinate of the point using the formula y^2 = x^3 + ax + b, where a and b are coefficients of the curve. If a y-coordinate output parameter was provided, it sets it to the computed value. If a y-coordinate was computed, it optionally computes the x-coordinate using the formula x =."
openssl-101u,O2,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O2_extraction/ec_GFp_simple_point_set_affine_coordinates@081e88d0.c,"The function takes an elliptic curve group, an elliptic curve point, two big integers representing the affine coordinates of the point, and a BN_CTX object. If both affine coordinates are not null pointers, the function sets the point's J-projective coordinates using EC_POINT_set_Jprojective_coordinates_GFp and returns the result. If either affine coordinate is a null pointer, the function sets an error using ERR_put_error and returns 0."
openssl-101u,O2,x86,encode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O2_extraction/encode_gost_algor_params@081d8c50.c,"The function `encode_gost_algor_params` takes an EVP_PKEY pointer as input and returns an ASN1_STRING pointer as output. It encodes the parameters of a GOST algorithm, based on the input key. The function creates a new ASN1_STRING object and a GOST_KEY_PARAMS object using the `ASN1_STRING_new()` and `GOST_KEY_PARAMS_new()` functions, respectively. If either of these objects are NULL, it sets error codes and returns NULL. It determines the type of the input key (either EC or GOST) and retrieves the corresponding curve name or parameter set. It then creates ASN1_OBJECTs for the curve name and the GOST parameter set and assigns them to the GOST_KEY_PARAMS object. It serializes the GOST_KEY_PARAMS object using the `i2d_GOST_KEY_PARAMS()` function and stores the resulting data in the ASN1_STRING object. It sets the type of the ASN1_STRING object to 0."
openssl-101u,O2,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_x86_gcc_O2_extraction/general_allocate_boolean.constprop.5@08187cc0.c,"The function `general_allocate_boolean_constprop_5` takes in several parameters including two strings, `param_1` and `param_2`, and some integers. It first checks if `param_1` is NULL and returns an error if it is. If `param_1` is not NULL, the function checks if `param_2` is also not NULL. If `param_2` is not NULL, the function loops through each character in `param_1` and checks if it exists in `param_2`. If a character in `param_1` does not exist in `param_2`, an error is returned. If both `param_1` and `param_2` are valid, the function checks if `param_2_00` is not equal to 0 and `param_5` is not equal to 0. If both conditions are true, the function allocates memory for an integer array of size."
openssl-101u,O2,x86,get_gost_engine_param,./data/decomp/openssl-101u_x86_gcc_O2_extraction/get_gost_engine_param@081db600.c,"The function takes an integer parameter called ""param_1"". If the parameter is not equal to 0, the function returns a null pointer. If the global variable ""gost_params"" is null, the function tries to retrieve the value of the environment variable ""CRYPT_PARAMS"" using the getenv() function. If the environment variable is not set or its value is null, the function returns a null pointer. Otherwise, the function allocates memory using the BUF_strdup() function to copy the value of the environment variable into the ""gost_params"" global variable and returns a pointer to it."
openssl-101u,O2,x86,gost2001_param_encode,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost2001_param_encode@081d7f80.c,"The function extracts the elliptic curve parameters from an EVP_PKEY object assumed to be an elliptic curve key. It obtains the curve name as a NID using the EC_GROUP_get_curve_name() function, converts it to an ASN1_OBJECT using the OBJ_nid2obj() function, serializes it into a byte array using i2d_ASN1_OBJECT() function, and stores the result in param_2. The resulting byte array can be used to represent the elliptic curve parameters in various contexts."
openssl-101u,O2,x86,gost_cipher_cleanup,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost_cipher_cleanup@081da1a0.c,"The function takes an integer parameter (param_1) and performs the following operations: It calls the gost_destroy function with an argument, which is the value of the expression `*(int *)(param_1 + 0x60) + 0xc`. It sets the value of the memory location at an offset of 0x54 from the parameter address to zero. It returns the value 1. The purpose of this function is to clean up the resources used by the GOST cipher. It destroys the cipher context by calling the gost_destroy function and sets the memory location to zero to ensure that it is not used again."
openssl-101u,O2,x86,gost_cipher_ctl,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost_cipher_ctl@081da6f0.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. 

If `param_2` is equal to 6, the function generates random bytes and stores them in the memory location pointed to by `param_4`. If the random bytes are successfully generated, the function returns 1. Otherwise, it calls the `ERR_GOST_error` function with error code 0x6f and 0x7b, and returns -1.

If `param_2` is equal to 7, the function checks if `param_4` is not equal to null. If it is not null, the function stores the value 0x32a in the memory location pointed to by `param_4` and returns 1. Otherwise, it returns 0.

If `param_2` is neither 6 nor 7, the function calls the `ERR_G`"
openssl-101u,O2,x86,gost_cipher_do_cnt,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost_cipher_do_cnt@081da310.c,"The function takes in four parameters - an integer, two byte pointers, and an unsigned integer. It returns an undefined value. The function first checks if the value at the address (param_1 + 0x50) is zero. If it is, it sets the local variable ""local_20"" to 8 and ""uVar4"" to 0. Otherwise, if the value at the address is less than 8 and the input parameter ""param_4"" is not zero, it enters a loop where it XORs the values at the addresses (param_1 + 0x30 + uVar2) and ""param_3"" and stores the result in ""param_2"". It then increments ""uVar2"" and ""uVar4"" and continues the loop until ""uVar2"" is greater than or equal to 8 or ""uVar4"" is greater than or equal to ""param_4"". If ""uVar2"" is greater than or equal to 8, it sets ""local_20"" to 0."
openssl-101u,O2,x86,gost_cipher_init,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost_cipher_init@081db320.c,"The function initializes the GOST cipher algorithm in OpenSSL by taking in an EVP_CIPHER_CTX structure, an integer parameter, and a void pointer parameter. It checks if the app_data field of the EVP_CIPHER_CTX structure is NULL and retrieves the GOST engine parameters to select the appropriate GOST cipher algorithm from the gost_cipher_list. If the engine parameters are not available, it defaults to the first algorithm in the list. It then initializes the cipher_data field of the EVP_CIPHER_CTX structure with the selected algorithm and its parameters. If the integer parameter is non-zero, it sets the key for the GOST cipher algorithm. If the void pointer parameter is not NULL, it copies the initialization vector (IV) from it to the EVP_CIPHER_CTX structure's oiv field and then copies the IV from the oiv field to the EVP_CIPHER_CTX structure's iv field. Finally, the function returns."
openssl-101u,O2,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O2_extraction/GOST_CIPHER_PARAMS_new@081d9f00.c,The function creates a new instance of the GOST_CIPHER_PARAMS structure using the ASN1_item_new function and casts the GOST_CIPHER_PARAMS_it pointer to an ASN1_ITEM pointer before passing it to the function. It returns without any value.
openssl-101u,O2,x86,gost_imit_final,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost_imit_final@081dafc0.c,"The function takes an integer and an undefined value as parameters. It checks if the GOST cryptographic algorithm has been initialized for MAC generation by checking a flag in the data structure. If the flag is set, it checks if the message length is a multiple of 8 bytes and pads it with zeros if necessary. If key meshing is enabled and the message length is exactly 1024 bits, key meshing is performed on the message. The MAC is computed using the MAC block function and stored in a buffer in the data structure. Finally, the MAC is copied to the output buffer and the function returns a value of 1. If the flag is not set, an error is thrown and the function returns."
openssl-101u,O2,x86,gost_imit_init_cpa,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost_imit_init_cpa@081da680.c,"The function `gost_imit_init_cpa` takes an integer parameter `param_1`. It retrieves the value stored at the memory address `param_1 + 0xc` and assigns it to the integer variable `iVar1`. It sets the values of six memory addresses that are offset from `iVar1` by certain amounts, which correspond to variables used in the GOST 28147-89 cipher algorithm. Specifically, it sets the values of the memory addresses at `iVar1 + 0x1020`, `iVar1 + 0x1024`, `iVar1 + 0x1028`, `iVar1 + 0x102c`, `iVar1 + 0x1030`, and `iVar1 + 0x1038` to 0, 0, 0, 0, 0, and 0, respectively."
openssl-101u,O2,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O2_extraction/GOST_KEY_PARAMS_new@081d9e80.c,The function creates a new instance of the GOST_KEY_PARAMS structure using ASN1_item_new() and returns the instance.
openssl-101u,O2,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_x86_gcc_O2_extraction/GOST_KEY_TRANSPORT_free@081d9d20.c,The function frees the memory allocated to an ASN1_VALUE pointer using the ASN1_item_free function and returns after doing so. It takes in a pointer to an ASN1_ITEM structure for the GOST_KEY_TRANSPORT type as its second parameter.
openssl-101u,O2,x86,gost_param_free,./data/decomp/openssl-101u_x86_gcc_O2_extraction/gost_param_free@081db560.c,"The `gost_param_free` function frees memory allocated for the `gost_params` variable using `CRYPTO_free` if the variable is not a null pointer, and sets `gost_params` to null after freeing."
openssl-101u,O2,x86,hash_step,./data/decomp/openssl-101u_x86_gcc_O2_extraction/hash_step@081db6d0.c,"1. The function takes in three parameters: a 32-bit integer, and two pointers to 32-bit integers. It performs XOR encryption using the first parameter as the key and the values pointed to by the two pointers as the input. It then performs a series of operations on the input and output buffers, updating the values pointed to by the second pointer with the results of the operations.

2. The function takes in three parameters: a pointer to a 256-bit key, a pointer to a 256-bit initialization vector (IV), and a pointer to an array of data to be encrypted. It performs a series of memory moves and XOR operations on local variables using the key, IV, and input data array, and then returns the encrypted data.

3. The function takes in two parameters - a pointer to an array of integers and the length of the array. It loops through the array, performing calculations on each element and updating the array with the values of local variables. It checks if the length of the array matches a variable called iVar10 and returns 1 if it completes successfully. If the length does not match, the function terminates the program with an error."
openssl-101u,O2,x86,hwcrhk_init,./data/decomp/openssl-101u_x86_gcc_O2_extraction/hwcrhk_init@081a16a0.c,"The function initializes the nFast HWCryptoHook library by loading the library and binding its functions. It sets up mutex callbacks if they are not disabled and a handle index for RSA keys if it has not already been set up. If the initialization is successful, it returns 1, otherwise it returns 0 and sets an error code and frees the library."
openssl-101u,O2,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_x86_gcc_O2_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9de0.c,"The function takes two parameters, param_1 and param_2. param_1 is a pointer to an ASN1_VALUE structure that contains information about a GOST key agreement. param_2 is a pointer to a pointer to an unsigned character (uchar). The function calls the ASN1_item_i2d function to convert the GOST key agreement information in param_1 into a DER-encoded format and store it in the memory pointed to by param_2. Finally, the function returns without any value."
openssl-101u,O2,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_x86_gcc_O2_extraction/i2d_GOST_KEY_TRANSPORT@081d9ce0.c,"The function takes in two parameters: param_1, a pointer to an ASN1_VALUE data structure, and param_2, a pointer to a pointer to a uchar data type. It uses the ASN1_item_i2d() function to convert the ASN1_VALUE structure pointed to by param_1 into a binary format and store the result in the memory location pointed to by param_2. The third parameter passed to ASN1_item_i2d() is a pointer to an ASN1_ITEM structure that describes the format of the ASN1_VALUE structure being converted. The function returns without any value."
openssl-101u,O2,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101u_x86_gcc_O2_extraction/load_pkcs12.constprop.4@0807a4c0.c,"The function takes in several parameters, including two BIO objects, a string, a function pointer, and two pointers to EVP_PKEY and X509 objects. It loads a PKCS12 object from the second BIO object parameter using the d2i_PKCS12_bio function. If the loading fails, it sets the return value to 0 and prints an error message. If the loading is successful, it verifies the MAC of the PKCS12 object. If the verification fails, it either tries again with a password provided by the password_callback function pointer (if it is not NULL), or sets the return value to 0 and prints an error message. If the password callback function returns an error, it also sets the return value to 0 and prints an error message. If the MAC verification is successful, it parses the PKCS12 object using the provided password (or an empty string if no password was needed) and sets the EVP_PKEY and X509 pointers to the parsed objects."
openssl-101u,O2,x86,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_x86_gcc_O2_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@080f1a40.c,"The function takes in a BIGNUM pointer, an integer, a uint pointer, another integer, and another integer. It first checks if the number of digits in the BIGNUM is less than the second integer. If it is, it expands the BIGNUM to have enough digits. Next, the function checks if the second integer is less than 4. If it is, it copies the uints from the uint pointer to the BIGNUM's digit array. If the second integer is greater than or equal to 4, the function performs a more complex operation involving bitwise operations and shifting to copy the uints to the BIGNUM's digit array. Finally, the function trims the BIGNUM's digit array by removing any trailing zeros and updates the BIGNUM's ""top"" field to reflect the new number of digits. The function returns 1 if successful and 0 otherwise."
openssl-101u,O2,x86,padlock_init,./data/decomp/openssl-101u_x86_gcc_O2_extraction/padlock_init@081a8550.c,"The function checks if padlock_use_rng or padlock_use_ace variables are non-zero and returns true if either is true, indicating successful initialization. If both are zero, the function returns false, indicating initialization failure."
openssl-101u,O2,x86,padlock_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O2_extraction/padlock_rand_bytes@081a7660.c,"The `padlock_rand_bytes` function generates random bytes and stores them in an array. It takes a pointer to an array of `undefined` type and an integer `param_2` as parameters, and returns an `undefined4` type variable. 

If `param_2` is less than 8, the function generates random bytes using the `xstore_available` function and stores them in the array pointed to by `param_1`. It continues this loop until it has generated `param_2` random bytes.

If `param_2` is not less than 8, the function first checks if it can write directly to the array pointed to by `param_1` using the `xstore_available` function. If it can, then it enters a loop where it generates random bytes in chunks of 8 bytes and stores them in the array pointed to by `param_1`. It continues this loop until it has generated at least `param_2` random bytes."
openssl-101u,O2,x86,param_copy_gost94,./data/decomp/openssl-101u_x86_gcc_O2_extraction/param_copy_gost94@081d82c0.c,"The function takes two EVP_PKEY pointers as input parameters, representing cryptographic parameters in OpenSSL, and returns a void pointer. It extracts the DSA key from the first EVP_PKEY parameter and the public key from the second EVP_PKEY parameter. It checks if the base id of the two parameters is the same and raises an error and returns NULL if they are not. If the public key is NULL, it raises an error and returns NULL. If the DSA key is NULL, it creates a new DSA key and assigns it to the first EVP_PKEY parameter. It copies the three BIGNUM parameters from the public key into the corresponding fields of the DSA key and frees any existing BIGNUM before copying the new BIGNUM."
openssl-101u,O2,x86,param_print_gost01,./data/decomp/openssl-101u_x86_gcc_O2_extraction/param_print_gost01@081d86e0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer and returns an integer value. It extracts the EC_KEY object and the EC_GROUP object from the EVP_PKEY object. It gets the curve name associated with the EC_GROUP object and stores it in an integer variable. It indents the BIO object using the third parameter integer value and stores the result in an integer variable. If the indentation is successful, it retrieves the string representation of the curve name using the OBJ_nid2ln() function and stores it in a character pointer. Finally, it prints the parameter set information to the BIO object using the retrieved curve name and returns 1 if the indentation was successful, otherwise it returns 0."
openssl-101u,O2,x86,param_print_gost94,./data/decomp/openssl-101u_x86_gcc_O2_extraction/param_print_gost94@081d8750.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer as parameters. It retrieves the public key from the EVP_PKEY object and compares it to the integers in an array pointed to by a global variable. If a match is found, it sets a variable to the value of the current integer in the array and prints the corresponding parameter set name with an indented output."
openssl-101u,O2,x86,pkey_ctrl_gost,./data/decomp/openssl-101u_x86_gcc_O2_extraction/pkey_ctrl_gost@081d90e0.c,"The function `pkey_ctrl_gost` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. The first parameter `param_1` is a pointer to an EVP_PKEY structure, which is a public key algorithm type. The second parameter `param_2` is an integer that determines the action to be taken. Depending on the value of `param_2`, the function performs different operations. The third parameter `param_3` is an integer value that is used in some of the operations. The fourth parameter `param_4` is a pointer to a PKCS7_SIGNER_INFO structure, which is used in some of the operations. The function starts with a switch statement that checks the value of `param_2`. If `param_2` is not one of the expected values, the function returns an error code. If `param_2` is 1, the function gets the algorithm."
openssl-101u,O2,x86,pkey_free_gost94,./data/decomp/openssl-101u_x86_gcc_O2_extraction/pkey_free_gost94@081d86c0.c,The function frees memory occupied by a DSA structure if the value stored at the memory location `param_1 + 0x14` is not NULL. It is likely used to free resources allocated for a GOST 94 public key.
openssl-101u,O2,x86,priv_encode_gost,./data/decomp/openssl-101u_x86_gcc_O2_extraction/priv_encode_gost@081d9420.c,"The function takes in two parameters: a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure. It returns an integer as a status code. It gets the ID of the algorithm used in the EVP_PKEY structure and converts it to an ASN1_OBJECT structure. It calls a function called encode_gost_algor_params() to encode the GOST algorithm parameters. The resulting encoded parameters are stored in a void pointer called pval. If the EVP_PKEY structure contains an EC private key, it gets the private key value as a BIGNUM structure using EC_KEY_get0_private_key(). If the EVP_PKEY structure contains a GOST private key, it gets the private key value as a BIGNUM structure from the EVP_PKEY structure directly. It then converts the private key value to an ASN1_INTEGER structure using BN_to_ASN1_INTEGER(). Finally, it sets the values of the PKCS8_PRIV_KEY_INFO structure using PKCS8_p."
openssl-101u,O2,x86,pub_encode_gost94,./data/decomp/openssl-101u_x86_gcc_O2_extraction/pub_encode_gost94@081d92d0.c,"The function takes in a pointer to an X509_PUBKEY structure and a pointer to an EVP_PKEY structure, and returns an integer value. It first gets the EVP_PKEY structure's base ID and converts it to an ASN1_OBJECT structure. It checks if the save_parameters flag is set in the EVP_PKEY structure and encodes the GOST algorithm parameters if it is. The encoded parameters are stored in pval. Next, it gets the number of bits in the public key and calculates the number of bytes needed to store the key. It converts the public key from a BIGNUM structure to a byte array and reverses the byte order. It then creates an ASN1_OCTET_STRING structure from the byte array and encodes it into a byte array using the i2d_ASN1_OCTET_STRING function. The encoded byte array and other parameters are used to set the X509_PUBKEY structure's parameters."
openssl-101u,O2,x86,pub_print_gost94,./data/decomp/openssl-101u_x86_gcc_O2_extraction/pub_print_gost94@081d8840.c,"This function retrieves and prints the public key and parameter set used for the key, compares it to the global parameter set, retrieves the corresponding NID, and prints the parameter set using the retrieved NID and OBJ_nid2ln function. It returns 1."
openssl-101u,O2,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O2_extraction/RSA_padding_add_PKCS1_PSS@081e3950.c,"The first function adds PKCS1 PSS padding to a message hash using RSA encryption. It takes in the RSA key, message hash, hash function used, and salt length. It initializes an EVP_MD_CTX object and applies PKCS1 MGF1 to the salt, XORs the result with the padded message hash, sets padding bytes, and returns the result.

The second function is named ""check_password"" and takes a password pointer and an integer length. It checks if the password pointer or length are NULL and returns -1 if so. It checks if the password length is >= 8 characters and returns -2 if not. If the password length is >= 8, it checks if the first character is an uppercase letter and returns -3 if not. It checks if the last character is a digit and returns -4 if not. Finally, it checks if the password contains the string ""password"" and returns -5 if so. If none of the above conditions are met, it returns a value."
openssl-101u,O2,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O2_extraction/RSA_verify_PKCS1_PSS@081e3030.c,"The function RSA_verify_PKCS1_PSS verifies a signature using the RSA-PSS algorithm. It initializes an EVP_MD_CTX structure, checks the signature length and RSA modulus size, and performs PSS verification. It generates a mask using PKCS1_MGF1, XORs it with the signature, and checks if the resulting value meets certain conditions. If the conditions are met, the function computes the hash of the message and compares it to the hash value in the signature."
openssl-101u,O2,x86,sha_block_data_order,./data/decomp/openssl-101u_x86_gcc_O2_extraction/sha_block_data_order@081dcdc0.c,"These functions all implement various versions of the SHA-1 hashing algorithm, which takes input data and produces a fixed-size output hash value. The algorithm operates on blocks of data, typically 512 bits in size, and uses a series of logical and arithmetic operations to process each block and update a set of registers or variables. The specific operations and implementation details vary between the functions, but all ultimately produce a 160-bit hash value as output. One function also includes a check on a local variable before executing its code, but its purpose and context are unclear without more information."
openssl-101u,O2,x86,SHA_Final,./data/decomp/openssl-101u_x86_gcc_O2_extraction/SHA_Final@081de090.c,"The SHA_Final function is the final step of the SHA-1 hashing algorithm. It takes in the message digest (md) and the SHA_CTX structure (c) as inputs. First, it retrieves the number of bytes processed so far (c->num) and the data buffer (c->data) from the SHA_CTX structure. It then appends a single bit (0x80) to the data buffer at the current position (c->num) and increments the number of bytes processed by one. If the number of bytes processed is less than 56, it pads the remaining bytes with zeros until it reaches 56 bytes. If the number of bytes processed is greater than or equal to 56, it pads the remaining bytes with zeros until it reaches 64 bytes and processes the data buffer using the sha_block_data_order function. Next, it appends the total number of bits processed to the end of the data buffer in big-endian format. It then processes the final block."
openssl-101u,O2,x86,srp_verify_server_param,./data/decomp/openssl-101u_x86_gcc_O2_extraction/srp_verify_server_param@080cee70.c,"The function `srp_verify_server_param` takes an integer `param_1` and a pointer to a 4-byte value `param_2`. It compares two BIGNUM values and sets `param_2` to `0x2f` and returns 0 if certain conditions are met. Otherwise, it checks the number of bits in the second BIGNUM value and sets the value accordingly."
openssl-101u,O2,x86,SSLv23_method,./data/decomp/openssl-101u_x86_gcc_O2_extraction/SSLv23_method@080a84e0.c,"The function returns a pointer to a SSL_METHOD object that represents the SSLv23 protocol method. The value is retrieved from the memory location of the SSLv23_method_data_15764 variable. The warning message cautions that the function may have been compiled with a non-standard calling convention, which could result in issues if called from code that expects a different convention."
openssl-101u,O2,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_x86_gcc_O2_extraction/SSL_SESSION_free.part.2@080c3230.c,"The function frees memory allocated for an SSL session by calling CRYPTO_free_ex_data to free associated data, using OPENSSL_cleanse to clear sensitive data, and checking for and freeing a certificate chain, peer certificate, session tickets, session ID, and session ticket key name. It takes a pointer to the session as its parameter."
openssl-101u,O2,x86,start_hash,./data/decomp/openssl-101u_x86_gcc_O2_extraction/start_hash@081dc670.c,"The function takes a pointer to an array of 32-bit integers as input. If the value of the third element of the array is not zero, the function initializes various elements of the array to zero. Specifically, it sets the first, second, fourth, fifth, and thirteenth elements and all subsequent elements of the array to zero, up to the nearest multiple of 4 bytes. The function returns 1 if it performs the initialization, and 0 otherwise."
openssl-101u,O2,x86,surewarehk_finish,./data/decomp/openssl-101u_x86_gcc_O2_extraction/surewarehk_finish@081a36a0.c,"The function checks if surewarehk_dso is null and sets variables if it is. If not null, it calls p_surewarehk_Finish and sets uVar2 to 1. It frees surewarehk_dso and sets error code variables if there was an error. It also frees logstream if not null. Finally, it resets all function pointers to null and returns uVar2."
openssl-101u,O2,x86,sv_body,./data/decomp/openssl-101u_x86_gcc_O2_extraction/sv_body@08068440.c,"The function `sv_body` handles SSL connections between the server and client, taking in three parameters: an integer `param_1`, an integer `param_2` representing the file descriptor of the socket connection, and a pointer to a character array `param_3` representing the session ID context. It allocates a buffer of size 0x4000 using `CRYPTO_malloc`, sets non-blocking I/O if enabled, creates a new SSL object using the SSL context `ctx`, and sets various SSL options based on global variables. It then reads and writes data using SSL_read and SSL_write functions, checks for various client commands, handles errors, and prints messages to the console using BIO_printf. 

The function `init_ssl_connection` is a decompiled version of a function that handles SSL connections, taking in a socket file descriptor and an SSL context as parameters. It sets up a BIO object to read from the socket and a buffer to store incoming data, associates the BIO object with the SSL context using SSL_set_bio, performs the SSL handshake using SSL_accept, reads and writes data using SSL_read and raw_write_stdout, checks for pending data, handles errors, shuts down the SSL connection, and cleans up allocated memory before returning a status code."
openssl-101u,O2,x86,TLSv1_method,./data/decomp/openssl-101u_x86_gcc_O2_extraction/TLSv1_method@080aa220.c,"The function returns a pointer to an SSL_METHOD structure for the TLSv1 protocol. The implementation of this structure is stored in TLSv1_method_data_15770. A warning message indicates uncertainty in parameter passing to other functions, but this does not impact the function's functionality."
openssl-101u,O2,x86,__libc_csu_init,./data/decomp/openssl-101u_x86_gcc_O2_extraction/__libc_csu_init@081ea170.c,"The function __libc_csu_init initializes the C runtime environment by calling the _init function to set up the program's environment, loading shared libraries, and initializing the dynamic linker. It then loops through an array of function pointers called __frame_dummy_init_array_entry and calls each function with three parameters. The loop continues until all functions in the array have been called, and the function returns. These functions are typically used to initialize global variables or perform other setup tasks at program startup."
openssl-101u,O2,x86,__udivdi3,./data/decomp/openssl-101u_x86_gcc_O2_extraction/__udivdi3@081e9ee0.c,"The function takes in four unsigned integer parameters: param_1, param_2, param_3, and param_4. It returns an unsigned 64-bit integer value. The function first checks if param_4 is equal to 0. If so, it performs a division operation of the 64-bit integer formed by concatenating param_2 and param_1 with param_3, and returns the result as a 32-bit integer. If param_4 is not equal to 0, the function calculates the highest bit position of param_4 that is set to 1 and stores it in uVar6. It then shifts param_4 and param_3 by the difference between 31 and uVar6 and stores the result in uVar1 and uVar2, respectively. The function then performs a division operation of the 64-bit integer formed by concatenating the shifted param_2 and param_1 with uVar2, and the shifted param_4."
openssl-101u,O3,x86,aep_mod_exp.part.0,./data/decomp/openssl-101u_x86_gcc_O3_extraction/aep_mod_exp.part.0@0819cda0.c,"The function `aep_mod_exp_part_0` is a wrapper that utilizes a hardware-accelerated modular exponentiation function `p_AEP_ModExp`. It takes four `BIGNUM` parameters and a `BN_CTX` context parameter as input. The function first obtains a connection to the accelerator via `aep_get_connection`. If successful, it calls `p_AEP_ModExp` with the input parameters. If the hardware computation is successful, it updates a connection table and returns 1. If the computation fails, it logs an error and falls back to the software implementation `BN_mod_exp`. The function uses `CRYPTO_lock` to synchronize access to the connection table and hardware accelerator, and logs errors via OpenSSL's `ERR_put_error` function."
openssl-101u,O3,x86,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_x86_gcc_O3_extraction/asn1_bio_callback_ctrl@081e50a0.c,"The function is a callback function for the ASN1 BIO library that takes three parameters: two integers and a function pointer. It checks if the pointer stored at offset 0x24 in the first integer is null and returns 0 if it is. Otherwise, it calls the BIO_callback_ctrl function with the same parameters."
openssl-101u,O3,x86,asn1_bio_ctrl,./data/decomp/openssl-101u_x86_gcc_O3_extraction/asn1_bio_ctrl@081e5160.c,"The function performs various control operations on a BIO object based on input parameters. It sets integer values in the BIO object if the parameter is 0x97 or 0x95, retrieves values if the parameter is less than 0x95, and sets a value if the parameter is greater than 0x98. If the parameter is 0xb, it calls the next BIO object in the chain and performs a write operation. If successful, it sets the state of the BIO object to 6. If the next BIO object does not have a method or control function, an error is returned. Otherwise, the control function of the next BIO object is called and its output is returned."
openssl-101u,O3,x86,asn1_bio_free,./data/decomp/openssl-101u_x86_gcc_O3_extraction/asn1_bio_free@081e50c0.c,"The function `asn1_bio_free` frees memory associated with a BIO structure. It takes an integer parameter `param_1`, likely a pointer to a BIO structure. The function retrieves a pointer `ptr` from the `param_1` structure at an offset of 0x20. If `ptr` is not NULL, the function checks if the pointer stored at an offset of 4 bytes from `ptr` is also not NULL. If it is not NULL, the function frees the memory pointed to by that pointer using `CRYPTO_free`. The function then frees the memory pointed to by `ptr` using `CRYPTO_free`. Finally, the function resets some fields in the `param_1` structure to zero and returns 1. If `ptr` was initially NULL, the function simply returns 0."
openssl-101u,O3,x86,asn1_bio_write,./data/decomp/openssl-101u_x86_gcc_O3_extraction/asn1_bio_write@081e5460.c,"The function `asn1_bio_write` writes data to a BIO object in ASN.1 format. It uses a state machine with five states to track the progress of the write operation. The function first checks if the input parameters are valid and then proceeds to write the data. If the input parameters are not valid, the function returns an error. The final state calls a callback function if one is provided."
openssl-101u,O3,x86,BIO_asn1_get_suffix,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BIO_asn1_get_suffix@081e5870.c,"This function takes a BIO object 'b' and two pointers to undefined1 types 'psuffix' and 'psuffix_free' as input parameters. It gets the suffix data of the ASN.1 object in the BIO object 'b' using the BIO_ctrl function with the control command '0x98' and passing a null pointer as the third parameter. If the length of the suffix data obtained is greater than zero, it assigns the pointer to the suffix data to the 'psuffix' pointer and the pointer to the memory allocated for the suffix data to the 'psuffix_free' pointer. It returns the length of the suffix data obtained. If the function encounters a stack corruption or stack smashing, it will call the __stack_chk_fail() function and terminate the program."
openssl-101u,O3,x86,BIO_asn1_set_prefix,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BIO_asn1_set_prefix@081e5770.c,"The function BIO_asn1_set_prefix sets the prefix string for a BIO object using the control command 0x95 and a prefix string pointer. It takes in a BIO object pointer, a pointer to a prefix string, and a pointer to a function that frees the prefix string. The function returns the result of the BIO_ctrl call, but if there is a stack check failure, it does not return."
openssl-101u,O3,x86,BN_get0_nist_prime_224,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_get0_nist_prime_224@081e58e0.c,"The `BN_get0_nist_prime_224()` function returns a pointer to a `BIGNUM` object that represents a specific prime number used in cryptography. The value of the `BIGNUM` object is stored in a static memory location named `_bignum_nist_p_224`. The function does not take any parameters and does not modify any data. The warning message indicates that the calling convention used by the function is not known to the decompiler, but this does not affect the functionality of the function."
openssl-101u,O3,x86,BN_get0_nist_prime_384,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_get0_nist_prime_384@081e5900.c,The function returns a pointer to a BIGNUM structure containing a NIST prime number with 384 bits. The prime number is stored in a static array of bytes called _bignum_nist_p_384. No arguments are taken and the calling convention is unspecified.
openssl-101u,O3,x86,BN_GF2m_add,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_add@081dfc60.c,"The function takes in three parameters: a BIGNUM structure (which represents a large integer), and two integer arrays. The function adds the two integers represented by the integer arrays and stores the result in the BIGNUM structure. The function first checks which of the two integer arrays is larger and assigns them to variables accordingly. It then checks if the BIGNUM structure has enough memory allocated to hold the result. If not, it expands the memory allocation. The function then performs the addition operation by XORing the integers in the two arrays and storing the result in the BIGNUM structure. If one of the arrays is shorter than the other, the remaining integers in the larger array are copied to the BIGNUM structure. Finally, the function removes any leading zero integers in the BIGNUM structure and returns 1 to indicate success."
openssl-101u,O3,x86,BN_GF2m_mod,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod@081dfe00.c,"The function BN_GF2m_mod takes two BIGNUM pointers as inputs, param_1 and param_2, and an integer array pointer param_3. It returns an undefined 4-byte value. The function first checks if the second element of param_3 is equal to 0. If it is, it sets an error message and returns 0. Next, it calculates the indexes of the non-zero bits in param_2 and stores them in the local array local_38. If there are more than 6 non-zero bits, it sets an error message and returns 0. If the first element of local_38 is 0, it sets param_1 to 0 and returns 1. Otherwise, it checks if param_1 is equal to param_2. If they are not equal, it checks if param_1's dmax is less than param_2's top. If it is, it expands param_1's size using bn_expand2."
openssl-101u,O3,x86,BN_GF2m_mod_arr,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_arr@081dfd60.c,"The function takes in three parameters: two BIGNUM pointers (param_1 and param_2) and an integer pointer (param_3). It returns an undefined value. The function first checks if the value pointed to by param_3 is zero. If it is, it sets the value of param_1 to zero using the BN_set_word function and returns 1. If the value pointed to by param_3 is not zero, the function checks if param_1 and param_2 are equal. If they are not equal, it expands the size of param_1 to match the size of param_2 using the bn_expand2 function. If bn_expand2 returns null, the function returns 0. If param_1 and param_2 are not equal and the expansion of param_1 is successful, the function copies the values of param_2 into param_1 using a loop that iterates through the number of words in param_2. It then sets the."
openssl-101u,O3,x86,BN_GF2m_mod_div,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_div@081e1700.c,"The function BN_GF2m_mod_div() takes in five parameters: three undefined 4-byte values, a BIGNUM pointer param_4, and a BN_CTX pointer param_5. It first calls BN_CTX_start() to initialize the BN_CTX object. It then calls BN_GF2m_mod_inv() to calculate the inverse of param_4 modulo param_3 and stores the result in a newly created BIGNUM object pBVar2. If pBVar2 is null or the inverse calculation fails, the function returns 0 and exits. Next, the function calculates the number of bits in param_4 and allocates memory for an array of integers of size (number of bits + 1) * 4. If the memory allocation fails, the function returns 0 and exits. The function then extracts the words of param_4 and stores the positions of the non-zero bits in the allocated array. If the extracted words are all zero, the function sets."
openssl-101u,O3,x86,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_div_arr@081e18b0.c,"This function takes in two undefined 4-byte values, an integer pointer, and a BN_CTX pointer. It initializes a BIGNUM variable ""a"" to 0 and sets bits in ""a"" based on the values in the integer pointer ""param_4"". It then initializes another BIGNUM variable ""pBVar3"" and computes the inverse of ""a"" modulo ""param_3"" using BN_GF2m_mod_inv(). The function allocates memory for an array of 4-byte integers based on the number of bits in ""a"" and fills this array with the positions of the set bits in ""a"". The function then calls BN_GF2m_mod_mul_arr() with the two undefined 4-byte values and ""pBVar3"" and the array of set bit positions. Finally, the function frees the allocated memory and returns a uint indicating success (1) or failure (0)."
openssl-101u,O3,x86,BN_GF2m_mod_mul,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_mul@081e0dc0.c,"The function BN_GF2m_mod_mul performs a modular multiplication operation on two BIGNUM values in GF(2^m) finite field. It takes five parameters, including three integers and two BIGNUM pointers. The function calculates the number of bits in the first BIGNUM value and allocates memory for an array of integers with a size of (bits + 1) * 4 bytes. It then checks if the top value of the first BIGNUM is not zero and proceeds to iterate over the words of the BIGNUM in reverse order, storing the indices of the set bits in the allocated array. The function checks if the allocated array has a size greater than or equal to the calculated number of bits, and if so, it calls the BN_GF2m_mod_mul_arr function with the allocated array as a parameter. If not, the function returns an error. Finally, the function frees the allocated memory."
openssl-101u,O3,x86,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_mul_arr@081e0190.c,"The first function, BN_GF2m_mod_mul_arr(), performs multiplication of two arrays of integers in GF(2^m) field. It takes five arguments and uses a precomputed table of squares in GF(2^m) field if the input arrays are the same. The function returns a boolean value indicating whether the multiplication was successful or not.

The second function takes in three parameters and performs a series of operations on the input buffer to generate the output buffer. It initializes several variables and arrays, enters a loop that iterates over the input buffer in chunks of 8 bytes, performs a series of bitwise operations on the current chunk of the input buffer to generate two 32-bit values, and enters a nested loop that iterates over the local_40 array. The function updates the values of local_160 and local_15c based on the bitwise operations.

The third function is a decompiled version of a function in OpenSSL library that performs modular multiplication of two binary polynomials in GF(2^m) field. It takes five parameters and initializes some local variables, checks if the input parameters are valid, and checks if one of the input polynomials is zero and sets the result to zero if that is the case."
openssl-101u,O3,x86,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_sqr@081e0f10.c,"The function BN_GF2m_mod_sqr() performs a modular squaring operation on a BIGNUM object in GF(2^m) field. It calculates the number of bits in the input BIGNUM object, extracts the non-zero bits, and checks if there are any non-zero bits. If there are, it performs the modular squaring operation using BN_GF2m_mod_sqr_arr() and returns the result. It frees the allocated memory and sets an error code if there was an error during execution."
openssl-101u,O3,x86,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_sqrt@081e1eb0.c,"The function BN_GF2m_mod_sqrt computes the square root of a given BIGNUM (param_3) in the finite field GF(2^m) using the irreducible polynomial specified by param_2. The result is stored in param_1. The function first allocates an array of integers to store the positions of the set bits in the binary representation of param_3. It then checks if param_3 is zero and returns 1 with param_1 set to 0 if so. Otherwise, it computes the positions of the set bits in param_3 and stores them in the array. If the array is not empty, the function sets a bit in a new BIGNUM (a) at the highest position in the array and computes the modular exponentiation of a using the irreducible polynomial specified by param_2. The result is stored in param_1. Finally, the function frees the memory allocated for the array and returns the result of the computation. If."
openssl-101u,O3,x86,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_GF2m_mod_sqr_arr@081dff80.c,"The function BN_GF2m_mod_sqr_arr in OpenSSL library performs binary field arithmetic. It takes four parameters - a BIGNUM pointer, two integer pointers, and a BN_CTX pointer. The function initializes the BN_CTX object, retrieves a BIGNUM object from it, and checks the size of the input array. It then expands the BIGNUM object if necessary and performs a squaring operation on the input array using a precomputed table. The result is stored in the BIGNUM object and the top field is set to reflect the actual number of words used to represent the result. The function returns false if the BIGNUM object is not retrieved successfully."
openssl-101u,O3,x86,BN_kronecker,./data/decomp/openssl-101u_x86_gcc_O3_extraction/BN_kronecker@081deef0.c,"The BN_kronecker function computes the Kronecker symbol of two BIGNUM pointers using an algorithm from the Handbook of Applied Cryptography. It initializes two BIGNUM pointers using BN_CTX_get and copies the input values into them using BN_copy. If either pointer is NULL, it returns -2. It then checks if either pointer is zero or odd and shifts one pointer right until it becomes even, keeping track of the number of shifts."
openssl-101u,O3,x86,by_dir_entry_free,./data/decomp/openssl-101u_x86_gcc_O3_extraction/by_dir_entry_free@08166860.c,"The function takes a pointer to a pointer to an unspecified type as its input parameter. It first checks if the value at the memory location pointed to by the input parameter is not equal to NULL. If it is not NULL, it frees the memory at that location using the CRYPTO_free function. Next, it checks if the third element of the array pointed to by the input parameter (which is assumed to be a stack) is not equal to NULL. If it is not NULL, it frees the memory allocated to the stack using the sk_pop_free function and passing in a function called by_dir_hash_free as a parameter. Finally, it frees the memory allocated to the entire array using the CRYPTO_free function and returns."
openssl-101u,O3,x86,cswift_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O3_extraction/cswift_rand_bytes@0819edc0.c,"The `cswift_rand_bytes` function generates random bytes using the CryptoSwift library. It acquires an access context using the `CSwift_AcquireAccContext` function and generates random bytes in blocks of 1024 bytes using the `CSwift_SimpleRequest` function until the requested number of bytes is generated. The generated random bytes are then copied to the buffer pointed to by the first argument. If the requested number of bytes is not a multiple of 4, the function handles the remaining bytes separately. If any error occurs during the generation of random bytes, the function sets an error code using the `ERR_put_error` function and returns 0. Otherwise, it returns 1."
openssl-101u,O3,x86,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_x86_gcc_O3_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@081d9f40.c,"The function decodes data into an ASN1_VALUE structure using the ASN1_item_d2i function, taking in a double pointer to the ASN1_VALUE, a pointer to an unsigned character, and a long integer. The decoded value is stored in the memory location pointed to by the first parameter, and the function returns without any value."
openssl-101u,O3,x86,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_x86_gcc_O3_extraction/d2i_GOST_KEY_PARAMS@081d9e40.c,"The function d2i_GOST_KEY_PARAMS deserializes a uchar object into an ASN1_VALUE object using the ASN.1 schema defined in GOST_KEY_PARAMS_it. It takes three arguments: a pointer to an ASN1_VALUE object, a pointer to a uchar object, and a long integer, and returns void. The function calls the ASN1_item_d2i function with the appropriate arguments to perform the deserialization."
openssl-101u,O3,x86,decode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O3_extraction/decode_gost_algor_params@081d79d0.c,"The function extracts algorithm parameters from X509_ALGOR and determines the algorithm type by converting ASN1_OBJECT to NID. If the algorithm is GOST R 34.10-2001, it creates an EC_KEY object and fills it with GOST2001 parameters using fill_GOST2001_params. If the algorithm is GOST R 34.10-94, it creates a DSA object and fills it with GOST94 parameters using fill_GOST94_params. If the algorithm is not recognized, an error is thrown. It returns 1 if EVP_PKEY type is successfully set, otherwise 0."
openssl-101u,O3,x86,DES_xcbc_encrypt,./data/decomp/openssl-101u_x86_gcc_O3_extraction/DES_xcbc_encrypt@081de220.c,"The functions `DES_xcbc_encrypt` and `perform_des_encryption` both perform encryption using the DES algorithm with an input byte array, an output byte array, a key, and an initialization vector. `DES_xcbc_encrypt` also takes in input and output words, a length value, and an encryption flag. Both functions process the input byte array in blocks of 8 bytes each, XORing each block with the previous block or the IV, depending on whether it is the first block or not. They also perform DES encryption on the XORed block using the given key and update the IV to be the last encrypted block. If the length of the input buffer is not a multiple of 8, both functions pad the input buffer with zeros to make it a multiple of 8. The only difference is that `DES_xcbc_encrypt` has additional logic to handle encryption and decryption based on the encryption flag."
openssl-101u,O3,x86,dgram_ctrl,./data/decomp/openssl-101u_x86_gcc_O3_extraction/dgram_ctrl@0811e8c0.c,The two functions take in four parameters and perform different actions based on the value of the second parameter. The first function returns a size_t value and either returns the value stored in a memory location or sets the value stored in a memory location and returns 1. The second function sets the size of a buffer and either copies the contents of a source buffer to a destination buffer or checks the contents of the source buffer and sets the size of the buffer accordingly.
openssl-101u,O3,x86,dlfcn_bind_func,./data/decomp/openssl-101u_x86_gcc_O3_extraction/dlfcn_bind_func@081e4600.c,"The function takes two integer parameters, param_1 and param_2. It checks if either of the parameters are equal to zero, and if so, it sets the variable ""line"" to 0x109 and the variable ""iVar1"" to 0x43. If both parameters are non-zero, it retrieves the number of elements in a stack stored at the memory address param_1+4 and stores it in the variable ""iVar1"". If the number of elements is less than 1, it sets the variable ""line"" to 0x10d and the variable ""iVar1"" to 0x69. If the number of elements in the stack is greater than or equal to 1, it retrieves the last element in the stack and stores it in the variable ""pvVar2"". It then calls the dlsym function with ""pvVar2"" and ""param_2"" as its parameters. If dlsym returns a non-zero value,"
openssl-101u,O3,x86,dlfcn_bind_var,./data/decomp/openssl-101u_x86_gcc_O3_extraction/dlfcn_bind_var@081e4700.c,"The function takes in two parameters, param_1 and param_2. If either parameter is 0, the function sets the line variable to 0xeb and returns 0x43. If there are less than 1 element in the stack pointed to by the value in param_1 + 4, the function sets the line variable to 0xef and returns 0x69. If there is at least one element, the function retrieves the last element from the stack and calls dlsym with that element and param_2 as arguments. If dlsym returns 0, the function sets an error message and returns 0. Otherwise, it returns the value returned by dlsym."
openssl-101u,O3,x86,dlfcn_globallookup,./data/decomp/openssl-101u_x86_gcc_O3_extraction/dlfcn_globallookup@081e4320.c,"The function uses the dlfcn library to dynamically load a shared library at runtime and look up a symbol within it. It takes a parameter of type undefined4, likely a symbol name or identifier. It first calls dlopen with a null pointer and a flag of 1 to open the current executable's symbol table and search for the given symbol. If dlopen returns 0, indicating an error, the function returns 0. Otherwise, it calls dlsym with the handle returned by dlopen and the symbol name parameter. If dlsym returns a non-null pointer, indicating success, the function returns that pointer. Finally, it calls dlclose to close the handle to the shared library."
openssl-101u,O3,x86,doapr_outch.constprop.0,./data/decomp/openssl-101u_x86_gcc_O3_extraction/doapr_outch.constprop.0@0811a260.c,"The function `doapr_outch_constprop_0` takes four parameters: two void pointer pointers `param_1_00` and `param_2`, and two unsigned integer pointers `param_3` and `param_1`. It checks if `param_2` is NULL or if the value pointed to by `param_3` is not equal to the value pointed to by `param_1`. If either of these conditions is true, the function jumps to `LAB_0811a278`. Otherwise, it continues with the next instruction. If `param_2` is NULL or the values of `param_3` and `param_1` are not equal, the function checks if the value pointed to by `param_3` is greater than `param_1`. If it is, the function returns 1. Otherwise, it assigns the value pointed to by `param_1_00` to a void pointer `pvVar1`."
openssl-101u,O3,x86,dtls1_link_min_mtu,./data/decomp/openssl-101u_x86_gcc_O3_extraction/dtls1_link_min_mtu@080bb4c0.c,"The function dtls1_link_min_mtu returns the hexadecimal value 0x100, which is equivalent to 256 in decimal. The purpose or meaning of this value is unknown without additional information."
openssl-101u,O3,x86,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_mont_field_encode@081e2b20.c,"The function takes four parameters: an integer, a BIGNUM pointer, another BIGNUM pointer, and a BN_CTX pointer. The integer parameter is used to access a BN_MONT_CTX structure. The function first checks if the BN_MONT_CTX pointer is not null. If it is not null, it uses the BN_mod_mul_montgomery function to perform a modular multiplication of the second and third parameters using the BN_MONT_CTX structure and stores the result in the first parameter. The function then returns the result of this operation. If the BN_MONT_CTX pointer is null, the function adds an error message to the error queue using the ERR_put_error function and returns 0."
openssl-101u,O3,x86,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_mont_field_sqr@081e2ac0.c,"The function takes four arguments: an integer, a pointer to a BIGNUM structure (param_2), a pointer to another BIGNUM structure (param_3), and a pointer to a BN_CTX structure (param_4). It checks if the BN_MONT_CTX pointer stored at offset 0xa0 of the integer argument is not null. If it is not null, it uses BN_mod_mul_montgomery to compute the square of param_3 modulo the value stored in the BN_MONT_CTX pointer, and stores the result in param_2. If the BN_MONT_CTX pointer is null, the function generates an error using ERR_put_error and returns 0."
openssl-101u,O3,x86,ec_GFp_mont_group_init,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_mont_group_init@081e26d0.c,"The `ec_GFp_mont_group_init` function initializes a Montgomery elliptic curve group by calling the `ec_GFp_simple_group_init` function to initialize a simple elliptic curve group. It sets two variables to zero, likely used to store additional parameters specific to the Montgomery curve, and returns."
openssl-101u,O3,x86,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_nist_field_mul@081e2e50.c,"The function takes four parameters: an integer, two BIGNUM pointers, and a BN_CTX pointer. It returns a boolean value. It first checks if any of the input parameters are null and adds an error message to the error queue if so. If the BN_CTX pointer is null, it creates a new BN_CTX object and uses it to multiply the two BIGNUMs pointed to by param_3 and param_4, storing the result in param_2. It then uses a function pointer stored at offset 0xa8 in the object pointed to by param_1 to perform a modular reduction of the result using a modulus stored at offset 0x48 in the same object. The function returns true if both operations succeed, false otherwise. If the BN_CTX pointer is not null, the function uses it to multiply the two BIGNUMs pointed to by param_3 and param_4, storing the result in param_2."
openssl-101u,O3,x86,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_nist_group_copy@081e2c50.c,The function takes two integer parameters representing elliptic curve group structures. It copies a specific field from the second instance to the first and then calls another function to copy the remaining fields. The function returns after completing these operations.
openssl-101u,O3,x86,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_nist_group_set_curve@081e2c70.c,"The function `ec_GFp_nist_group_set_curve` sets the curve parameters for a NIST elliptic curve over a finite field. It takes as input the curve parameters, including the prime modulus, and a BN_CTX object for temporary storage. If the BN_CTX object is not provided, it creates a new one. The function checks if the prime modulus matches one of the pre-defined NIST primes (192, 224, 256, 384, or 521 bits). If it does, it sets the appropriate modular reduction function and calls `ec_GFp_simple_group_set_curve` to set the curve parameters. If the prime modulus does not match any of the pre-defined primes, it returns an error. After setting the curve parameters, the function frees the BN_CTX object if it created one, and returns the result of `ec_GFp_simple_group_set_curve`."
openssl-101u,O3,x86,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@081e77c0.c,"The function takes in six parameters: an integer pointer, an integer, and four BIGNUM pointers. It returns a boolean value. 

The function checks if a certain value in the memory location pointed to by the first parameter is equal to zero. If it is, it checks if the second and third parameters are null or if they can be copied to the fourth and fifth parameters respectively using the BN_copy function. If the fourth parameter is not null, it copies the value from the memory location pointed to by the sixth parameter to the fourth parameter using the BN_copy function. It then returns true. 

If the value in the memory location pointed to by the first parameter is not zero, the function creates a new BN_CTX object if the sixth parameter is not null or assigns it to a new BN_CTX object. It then checks if the second and third parameters are null or if they can be assigned to the fourth and fifth parameters respectively using a function pointer located in the memory location pointed to by the first parameter."
openssl-101u,O3,x86,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_group_check_discriminant@081e7990.c,"The function `ec_GFp_simple_group_check_discriminant` checks if the discriminant of an elliptic curve over a prime field is a square. It takes two parameters: `param_1` is a pointer to an array of integers representing the elliptic curve parameters, and `param_2` is a pointer to a BN_CTX structure used for temporary storage during the computation. If `param_2` is NULL, the function creates a new BN_CTX structure. It then allocates five BIGNUM variables for temporary storage. If `a` and `a_00` are not computed, the function calls a function pointer in `param_1` to compute them."
openssl-101u,O3,x86,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_group_clear_finish@081e7420.c,"The `ec_GFp_simple_group_clear_finish` function takes an integer parameter `param_1`, likely a pointer to an elliptic curve group data structure. It calls `BN_clear_free` on three BIGNUM pointers, which are offsets from `param_1` by 0x48, 0x74, and 0x88 bytes, respectively. This frees the memory allocated for the BIGNUMs and sets their values to zero. The function then returns."
openssl-101u,O3,x86,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_group_copy@081e8570.c,"The function copies three BIGNUM structures and an undefined 4-byte value from one EC_GFp_simple_group structure to another. It copies the BIGNUMs at offsets 0x48, 0x74, and 0x88. If any BN_copy calls fail, the function returns 0; otherwise, it returns 1."
openssl-101u,O3,x86,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_group_get_degree@081e7490.c,"The function takes an integer parameter that is a pointer to an elliptic curve group structure and calculates the degree of the group. It does this by calling the OpenSSL function BN_num_bits() on a BIGNUM structure within the group structure. The degree of the group is the number of bits in the order of the group, which is stored in the BIGNUM structure. The function does not return the degree value but simply calculates it and does nothing with it."
openssl-101u,O3,x86,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_group_set_curve@081e8660.c,"The function ec_GFp_simple_group_set_curve sets the curve parameters for an elliptic curve group over a prime field. The function takes as input four BIGNUMs (large integers) representing the prime field modulus, the curve parameters a and b, and a BN_CTX (Big Number context) structure for temporary storage of intermediate results. The function returns an integer value indicating success or failure. The function first checks if the input prime field modulus is valid (i.e., greater than 2 and odd). If the modulus is invalid, the function returns failure. If a BN_CTX structure is not provided, the function creates a new one and initializes it. It then copies the prime field modulus into a temporary BIGNUM r and sets the sign of the curve parameter a to non-negative. The function then computes the remainder of the curve parameter b modulo the prime field modulus using BN_nnmod and stores the result in the curve parameter b. If the remainder computation fails, the function returns failure."
openssl-101u,O3,x86,ec_GFp_simple_invert,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_invert@081e9390.c,"The function checks if the input EC_POINT is at infinity or not using EC_POINT_is_at_infinity function. If the point is not at infinity and its Y-coordinate is not zero, it calculates the inverse of the point using BN_usub function. If the point is at infinity or its Y-coordinate is zero, it returns 1 (indicating failure)."
openssl-101u,O3,x86,EC_GFp_simple_method,./data/decomp/openssl-101u_x86_gcc_O3_extraction/EC_GFp_simple_method@081e9ed0.c,"The function returns a pointer to an unspecified EC_METHOD structure, which is stored in the variable ""ret_6816"". The calling convention is unknown, but the parameters passed to the function are stored in a locked storage location."
openssl-101u,O3,x86,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_point_copy@081e85f0.c,"This function takes in two integer parameters and uses the BN_copy function to copy BIGNUM values from the second parameter to the first parameter for three different offsets. If all three copies are successful, it sets the value at offset 0x40 in the first parameter to the value at offset 0x40 in the second parameter and returns 1. If any of the copies fail, it returns 0."
openssl-101u,O3,x86,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_point_finish@081e73f0.c,"The function `ec_GFp_simple_point_finish` takes an integer parameter `param_1`, which is likely a pointer to a structure representing an elliptic curve point. It frees three big number (BIGNUM) objects that are stored within the structure at specific offsets: one at offset +4, one at offset +0x18, and one at offset +0x2c. These BIGNUM objects likely represent the x-coordinate, y-coordinate, and z-coordinate of the point in a projective coordinate system. The purpose of freeing these BIGNUM objects is to release the memory that was allocated for them during the creation or manipulation of the elliptic curve point, preventing memory leaks and ensuring efficient memory usage. The function then simply returns without any further actions."
openssl-101u,O3,x86,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_point_get_affine_coordinates@081e7c00.c,"The function takes an integer pointer, an EC_POINT structure pointer, two BIGNUM pointers, and a BN_CTX pointer as input and returns a boolean value. It checks if the EC_POINT is at infinity and returns false with an error message if it is. It creates a new BN_CTX and allocates four BIGNUM variables from it if no BN_CTX pointer is provided. It checks if the EC_GROUP has a point multiplication function and computes the x-coordinate of the point and its square using it. It returns false if the multiplication fails. If the multiplication succeeds, it computes the inverse of the x-coordinate modulo the group order, and uses it to compute the y-coordinate and its product with the x-coordinate. It returns false if any of these computations fail. If all computations succeed, it copies the x and y coordinates to the provided BIGNUM pointers."
openssl-101u,O3,x86,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_x86_gcc_O3_extraction/ec_GFp_simple_point_set_affine_coordinates@081e88d0.c,"The function takes an elliptic curve group, an elliptic curve point, two big integers representing the affine coordinates of the point, and a BN_CTX structure. If the affine coordinates are not null pointers, the function sets the point's J-projective coordinates using the affine coordinates and a newly created BIGNUM with value 1, and returns the result. If the affine coordinates are null pointers, the function generates an error and returns 0."
openssl-101u,O3,x86,encode_gost_algor_params,./data/decomp/openssl-101u_x86_gcc_O3_extraction/encode_gost_algor_params@081d8c50.c,"The function takes an EVP_PKEY pointer as input and returns an ASN1_STRING pointer as output. It encodes the GOST algorithm parameters based on the type of the input key. If the input key is an EC key, it gets the curve name and encodes it along with the GOST OID (0x336) into the ASN1_STRING. If the input key is a R3410 key, it compares the key parameters with the predefined R3410 parameter sets and encodes the matching parameter set OID along with the GOST OID into the ASN1_STRING. If the encoding is successful, the function sets the type of the ASN1_STRING to 0x10 and returns it. If the encoding fails, it returns NULL. The function also frees any allocated memory before returning."
openssl-101u,O3,x86,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_x86_gcc_O3_extraction/general_allocate_boolean.constprop.5@08187cc0.c,"The function ""general_allocate_boolean_constprop_5"" takes in two character pointers (param_1 and param_2), an integer (param_3), and three more integers (param_4, param_5, and param_1_00). It checks if param_1 is NULL and returns -1 if so. If param_2 is not NULL, it loops through each character in param_1 and checks if it exists in param_2. If a character in param_1 is not found in param_2, it returns -1. If param_2 is found in param_1, the function checks if param_2_00 is equal to 0. If so, it returns -1. If not, it allocates memory for an integer pointer named ""ptr"" using CRYPTO_malloc."
openssl-101u,O3,x86,get_gost_engine_param,./data/decomp/openssl-101u_x86_gcc_O3_extraction/get_gost_engine_param@081db600.c,"The function takes an integer parameter named ""param_1"". If the parameter is not equal to zero, the function returns a null pointer. Otherwise, the function checks if the global variable ""gost_params"" is null. If it is, the function attempts to retrieve the value of the environment variable ""CRYPT_PARAMS"" using the getenv() function. If the environment variable is not set, the function returns a null pointer. Otherwise, the function allocates memory for a copy of the environment variable value using the BUF_strdup() function and assigns the copy to the ""gost_params"" variable. Finally, the function returns the value of the ""gost_params"" variable."
openssl-101u,O3,x86,gost2001_param_encode,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost2001_param_encode@081d7f80.c,The function extracts the EC_GROUP object from an EVP_PKEY object that contains an EC_KEY object. It then retrieves the curve name using EC_GROUP_get_curve_name() and converts it to an ASN1_OBJECT using OBJ_nid2obj(). The resulting ASN1_OBJECT is encoded into binary format using i2d_ASN1_OBJECT() and stored in the param_2 pointer for use in cryptographic operations.
openssl-101u,O3,x86,gost_cipher_cleanup,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost_cipher_cleanup@081da1a0.c,The function takes an integer parameter and destroys a GOST cipher context by calling the `gost_destroy` function with an argument that is a pointer to the context. It then sets a value at a specific address to zero and returns 1. The purpose of setting the value to zero is unclear.
openssl-101u,O3,x86,gost_cipher_ctl,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost_cipher_ctl@081da6f0.c,"The function takes four parameters: two integers, an undefined value, and a pointer to an undefined value. If the second parameter is equal to 6, it generates random bytes and stores them in the memory pointed to by the fourth parameter. If the generation is successful, it returns 1. If the second parameter is equal to 7, it sets the value pointed to by the fourth parameter to 0x32a and returns 1. If the second parameter is anything else, it logs an error and returns -1."
openssl-101u,O3,x86,gost_cipher_do_cnt,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost_cipher_do_cnt@081da310.c,"The `gost_cipher_do_cnt` function is a component of the GOST block cipher algorithm used to encrypt/decrypt data in CTR mode. It takes four arguments: a pointer to the GOST context structure, input and output data buffers, and the length of the input data. The function XORs any pending data with the first byte(s) of the input data and writes the result to the output buffer. If the pending data is insufficient, the function returns. Otherwise, a new block of counter values is generated."
openssl-101u,O3,x86,gost_cipher_init,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost_cipher_init@081db320.c,"The function `gost_cipher_init` initializes the GOST cipher context `param_1` with the specified key size `param_2` and initialization vector `param_3`. It checks if the context's `app_data` field is null and retrieves the GOST engine parameter from the system. It determines the GOST cipher to use and initializes the `cipher_data` field of the context with the cipher's OID, a null initialization vector, and the cipher's key size. It also initializes the GOST engine with the cipher's OID. If no parameter is found, it defaults to the first cipher in the `gost_cipher_list`. If a parameter is found, it converts it to an object identifier (OID) using `OBJ_txt2nid` and searches the `gost_cipher_list` for a matching OID. If no matching OID is found, an error is returned."
openssl-101u,O3,x86,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O3_extraction/GOST_CIPHER_PARAMS_new@081d9f00.c,The function creates a new instance of GOST_CIPHER_PARAMS using ASN1_item_new and returns it.
openssl-101u,O3,x86,gost_imit_final,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost_imit_final@081dafc0.c,"The function `gost_imit_final` takes two parameters, an integer `param_1` and an undefined integer `param_2`. It retrieves two integer values from memory (`iVar1` and `iVar2`) based on the value of `param_1`. If `iVar2` is 0, it calls `ERR_GOST_error` and jumps to the end of the function. Otherwise, it checks if another integer value in memory (`*(int *)(iVar1 + 0x1030)`) is 0. If it is, it checks if another integer value in memory (`*(int *)(iVar1 + 0x1038)`) is not 0. If it is not 0, it creates two local undefined integers (`local_28` and `local_24`) and calls the function `gost_imit_update` with `param_1` and the addresses of these local integers, and then jumps to `LAB_081db05`."
openssl-101u,O3,x86,gost_imit_init_cpa,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost_imit_init_cpa@081da680.c,The function initializes variables at different memory offsets to zero and sets one variable to 1 using an integer parameter. It then calls another function with two parameters and returns 1.
openssl-101u,O3,x86,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_x86_gcc_O3_extraction/GOST_KEY_PARAMS_new@081d9e80.c,The function creates a new instance of the GOST_KEY_PARAMS data structure using the ASN1_item_new() function from the OpenSSL library. It does not take any arguments and simply returns after creating the instance.
openssl-101u,O3,x86,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_x86_gcc_O3_extraction/GOST_KEY_TRANSPORT_free@081d9d20.c,The function GOST_KEY_TRANSPORT_free() frees the memory allocated to an ASN1_VALUE pointer using the ASN1_item_free() function. The function uses the GOST_KEY_TRANSPORT_it ASN1_ITEM structure and returns without any value.
openssl-101u,O3,x86,gost_param_free,./data/decomp/openssl-101u_x86_gcc_O3_extraction/gost_param_free@081db560.c,"The ""gost_param_free"" function frees the memory allocated for the ""gost_params"" variable using the ""CRYPTO_free"" function. If ""gost_params"" is not equal to null (0x0), then it is freed and set to null. The function does not return anything."
openssl-101u,O3,x86,hash_step,./data/decomp/openssl-101u_x86_gcc_O3_extraction/hash_step@081db6d0.c,"The first function takes in a 32-bit integer, two pointers to 32-bit unsigned integers, and performs bitwise operations and XORs on local variables before calling the `gost_enc_with_key` function.

The second function takes in three pointers to 256-bit blocks of data, performs a series of bitwise operations, and calls the GOST encryption function twice before performing more bitwise operations.

The third function takes in a 32-byte key, plaintext block, and buffer, performs bitwise operations, calls the `gost_enc_with_key` function, and performs XOR operations in a specific order before setting the encrypted block.

The fourth function takes in an integer array and value, adds the value to each element in the array, tracks the minimum and maximum values, and sets values in the array before returning 1 or triggering a stack check failure."
openssl-101u,O3,x86,hwcrhk_init,./data/decomp/openssl-101u_x86_gcc_O3_extraction/hwcrhk_init@081a16a0.c,"This function initializes the hardware crypto hook library by loading and binding its functions. It checks if mutex callbacks are enabled and sets the appropriate function pointers if necessary. It returns 1 if successful and 0 if not, setting an error code if necessary. If the library was loaded, it frees it before returning."
openssl-101u,O3,x86,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_x86_gcc_O3_extraction/i2d_GOST_KEY_AGREEMENT_INFO@081d9de0.c,The function encodes an ASN1_VALUE structure into a DER format using an ASN1_ITEM structure of type GOST_KEY_AGREEMENT_INFO and stores the encoded data in a uchar array pointed to by a double pointer. It takes in two parameters: a pointer to the ASN1_VALUE structure and a double pointer to the uchar array. The function does not return any value.
openssl-101u,O3,x86,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_x86_gcc_O3_extraction/i2d_GOST_KEY_TRANSPORT@081d9ce0.c,"The function converts an ASN1_VALUE structure into a binary format using the ASN1_item_i2d() function, with the ASN1_ITEM structure GOST_KEY_TRANSPORT_it. It takes two parameters: param_1, a pointer to the ASN1_VALUE structure, and param_2, a pointer to a pointer to an unsigned char buffer. The function returns without any value."
openssl-101u,O3,x86,load_pkcs12.constprop.4,./data/decomp/openssl-101u_x86_gcc_O3_extraction/load_pkcs12.constprop.4@0807a4c0.c,"The `load_pkcs12_constprop_4` function loads a PKCS12 file from two BIO objects, a string, a function pointer, and two pointers to EVP_PKEY and X509 structs. It verifies the MAC of the PKCS12 file using an empty password, and if it fails, it tries to obtain a password using the function pointer `param_1`. If the password callback fails, the function returns 0. If the password is obtained successfully, it verifies the MAC again using the obtained password. If the MAC verification is successful, the function continues. If it fails, the function returns 0."
openssl-101u,O3,x86,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_x86_gcc_O3_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@080f1a40.c,"The function takes in a BIGNUM pointer, an integer, a uint pointer, another integer, and another integer as parameters. It first checks if the size of the BIGNUM is less than the second integer and expands it if necessary. It then performs a bitwise copy operation from the uint pointer to the BIGNUM data field based on the values of the input integers. If the second integer is less than 4, the function copies the uint values directly to the BIGNUM data field. If the second integer is greater than or equal to 4, the function performs a more complex bitwise copy operation based on the value of the second integer. The function returns 1 if the operation is successful and 0 otherwise."
openssl-101u,O3,x86,padlock_init,./data/decomp/openssl-101u_x86_gcc_O3_extraction/padlock_init@081a8550.c,"The ""padlock_init"" function checks if either ""padlock_use_rng"" or ""padlock_use_ace"" is not equal to zero and returns true if initialization was successful, otherwise false."
openssl-101u,O3,x86,padlock_rand_bytes,./data/decomp/openssl-101u_x86_gcc_O3_extraction/padlock_rand_bytes@081a7660.c,"The function named ""padlock_rand_bytes"" generates a specified number of random bytes and returns an undefined 4-byte value. It takes in a pointer to an array of undefined bytes and an integer indicating the number of bytes to generate. If the requested number of bytes is less than 8, it generates one byte at a time using the xstore_available function. If the requested number of bytes is greater than or equal to 8, it generates 8 bytes at a time using the same function. The xstore_available function checks if the CPU supports the Padlock feature and if the random number generator is available before generating a random byte and storing it in the output array. The loop continues until the requested number of bytes is generated or the xstore_available function fails to generate a random number."
openssl-101u,O3,x86,param_copy_gost94,./data/decomp/openssl-101u_x86_gcc_O3_extraction/param_copy_gost94@081d82c0.c,The function takes two EVP_PKEY pointers representing GOST 94 parameter sets as input. It extracts BIGNUM values from the second parameter and copies them into the first parameter's DSA structure. An error is thrown if the two parameters have different base IDs. The function returns a void pointer indicating success or failure.
openssl-101u,O3,x86,param_print_gost01,./data/decomp/openssl-101u_x86_gcc_O3_extraction/param_print_gost01@081d86e0.c,"The function takes in a BIO object, an EVP_PKEY object, and an integer value, extracts the EC_KEY and EC_GROUP objects from the EVP_PKEY object, gets the curve name of the EC_GROUP object, prints it to the BIO object with an indentation level specified by the integer parameter, and returns 1 if the printing is successful, otherwise it returns 0. This function is used to print the parameters of a GOST curve used in cryptography."
openssl-101u,O3,x86,param_print_gost94,./data/decomp/openssl-101u_x86_gcc_O3_extraction/param_print_gost94@081d8750.c,"The function takes a BIO object, an EVP_PKEY object, and an integer as parameters. It retrieves the public key from the EVP_PKEY object and creates a new BIGNUM object. It checks if the R3410_paramset variable contains any data and loops through the data to compare each value to the public key. If a match is found, it sets the iVar2 variable to the corresponding integer value from the R3410_paramset variable and frees the BIGNUM object. If no match is found, iVar2 is set to 0 and the BIGNUM object is freed. The function then indents the BIO object by the specified integer value, prints out a message indicating the parameter set used based on the value of iVar2, and checks for stack corruption before returning 1."
openssl-101u,O3,x86,pkey_ctrl_gost,./data/decomp/openssl-101u_x86_gcc_O3_extraction/pkey_ctrl_gost@081d90e0.c,"The function `pkey_ctrl_gost` takes four parameters: `param_1` of type `EVP_PKEY*`, `param_2` of type `int`, `param_3` of type `int`, and `param_4` of type `PKCS7_SIGNER_INFO*`. The function performs different actions based on the value of `param_2`. If `param_2` is not one of the expected values, the function returns an error code. If `param_2` is 1 and `param_3` is 0, the function extracts the algorithm parameters from `param_1` and sets them in `param_4`. If `param_2` is 2 and `param_3` is 0, the function encodes the GOST algorithm parameters and sets them in `param_4`. If `param_2` is 3, the function sets the version of the algorithm."
openssl-101u,O3,x86,pkey_free_gost94,./data/decomp/openssl-101u_x86_gcc_O3_extraction/pkey_free_gost94@081d86c0.c,"The function takes an integer parameter ""param_1"" and checks if the value stored at memory location (param_1+0x14) is not equal to null. If it is not null, it frees the memory allocated to the DSA structure stored at that location using the DSA_free() function. If the value stored at that location is null, the function returns without doing anything."
openssl-101u,O3,x86,priv_encode_gost,./data/decomp/openssl-101u_x86_gcc_O3_extraction/priv_encode_gost@081d9420.c,"The function takes in a PKCS8_PRIV_KEY_INFO structure and an EVP_PKEY structure as parameters. It retrieves the algorithm ID from the EVP_PKEY structure and creates an ASN1_OBJECT corresponding to that ID. It encodes the parameters for the GOST algorithm and stores the resulting byte array in a variable called pval. 

The function checks the algorithm ID again to determine whether the private key is an Elliptic Curve or a BIGNUM. If it is an Elliptic Curve, it retrieves the private key from the EC_KEY structure and converts it to a BIGNUM. If it is a BIGNUM, it retrieves the BIGNUM directly from the EVP_PKEY structure. 

The function converts the BIGNUM to an ASN1_INTEGER and stores the resulting byte array in a variable called local_24. Finally, the function calls PKCS8_pkey_set0 to set the values of the PKCS."
openssl-101u,O3,x86,pub_encode_gost94,./data/decomp/openssl-101u_x86_gcc_O3_extraction/pub_encode_gost94@081d92d0.c,"The function takes in two parameters, a pointer to an X509_PUBKEY structure and an EVP_PKEY structure. It gets the algorithm object from the EVP_PKEY structure and creates an ASN1_OBJECT structure from it. If the save_parameters flag is set, it calls the encode_gost_algor_params function to get the encoded algorithm parameters and sets a local variable. Next, it converts the public key into a binary format using BN_bn2bin function and creates an ASN1_OCTET_STRING structure from the binary data. The function then copies the binary data in reverse order, frees the buffer, encodes the ASN1_OCTET_STRING structure into a DER format, and stores it locally."
openssl-101u,O3,x86,pub_print_gost94,./data/decomp/openssl-101u_x86_gcc_O3_extraction/pub_print_gost94@081d8840.c,The function extracts a BIGNUM value from an EVP_PKEY object and prints it to a BIO object with indentation. It searches for a specific parameter set matching the one used in the EVP_PKEY object and prints the name of the set to the BIO object with indentation. It returns 1.
openssl-101u,O3,x86,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O3_extraction/RSA_padding_add_PKCS1_PSS@081e3950.c,"1. The function performs PKCS1 PSS padding on a message hash using an RSA key, a hash function, and a salt length as inputs. If the salt length is -2, it generates a random salt and performs MGF1 padding on it. If not, it pads the message hash with zeroes. It then calculates the hash of the padded message and the salt using the specified hash function, XORs the result with the padded salt, adds additional padding, and returns the padded message as a byte array.

2. The function checks if a pointer to a struct is null and returns an error code if it is. It then checks if an integer value is within a certain range and returns the value if it is. If either check fails, it calls the __stack_chk_fail function, which terminates the program."
openssl-101u,O3,x86,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_x86_gcc_O3_extraction/RSA_verify_PKCS1_PSS@081e3030.c,"The function RSA_verify_PKCS1_PSS is used to verify a signature using the RSA public key algorithm with the PKCS1 PSS padding scheme. It takes as input the RSA public key, the message hash, the hash algorithm used, the encoded signature, and the length of the signature. The function initializes an EVP_MD_CTX structure, retrieves the size of the hash algorithm, checks the validity of the signature length, calculates the number of bytes to be masked, and removes the first byte of the encoded signature if necessary. It also checks that the encoded signature is long enough to contain the hash and the salt, extracts the salt from the encoded signature using a mask generation function (MGF1), and checks that the leftmost bits of the first byte of the masked salt are zero and removes them if necessary. Finally, it checks that the second byte of the masked salt is equal to 0x01."
openssl-101u,O3,x86,sha_block_data_order,./data/decomp/openssl-101u_x86_gcc_O3_extraction/sha_block_data_order@081dcdc0.c,"These functions all implement the SHA-1 hashing algorithm to produce a 160-bit hash value from a message. The message is processed in 512-bit blocks using a series of bitwise, logical, and arithmetic operations. The specifics of the operations may vary slightly between the different functions, but they all aim to ensure the resulting hash value is unique and secure. One of the functions checks for a specific condition and terminates the program if it is not met."
openssl-101u,O3,x86,SHA_Final,./data/decomp/openssl-101u_x86_gcc_O3_extraction/SHA_Final@081de090.c,"The SHA_Final function is the final step in the SHA-1 hashing process. It takes in a pointer to an array of unsigned characters (md) and a pointer to a SHA_CTX structure (c) that contains the intermediate hash values and the input message. The function first retrieves the number of bytes in the message from the SHA_CTX structure and the data buffer containing the message. It then appends a single 1 bit to the end of the message and pads the message with zeros until it is a multiple of 512 bits (64 bytes) in length. If there is not enough space in the data buffer to append the padding, the function calls a helper function (sha_block_data_order) to process the current block and start a new one. Next, the function appends the length of the message (in bits) to the end of the padded message. This is done by storing the most significant 32 bits in the 15th word of the data buffer and the least significant 32 bits in the 16th word."
openssl-101u,O3,x86,srp_verify_server_param,./data/decomp/openssl-101u_x86_gcc_O3_extraction/srp_verify_server_param@080cee70.c,"The function takes in an integer and a pointer to an undefined 4-byte value. It performs a series of checks on the values stored at specific memory addresses based on the input parameter. If the checks pass, the function sets the value pointed to by the second parameter to a specific value and returns 0."
openssl-101u,O3,x86,SSLv23_method,./data/decomp/openssl-101u_x86_gcc_O3_extraction/SSLv23_method@080a84e0.c,The SSLv23_method() function returns a pointer to an SSL_METHOD structure containing information about the SSL/TLS protocol version and options for the connection. It retrieves this information from a data structure named SSLv23_method_data_15764 and does not require any parameters. The calling convention for this function is unknown.
openssl-101u,O3,x86,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_x86_gcc_O3_extraction/SSL_SESSION_free.part.2@080c3230.c,"The function `SSL_SESSION_free_part_2` frees the memory allocated for an SSL session object. It first frees any application-specific data associated with the object using `CRYPTO_free_ex_data`. It then overwrites sensitive data with zeros using `OPENSSL_cleanse`, and frees any certificates, private keys, and other data using various `CRYPTO_free` and `X509_free` functions. Finally, it overwrites the entire SSL session object with zeros before freeing the memory using `CRYPTO_free`."
openssl-101u,O3,x86,start_hash,./data/decomp/openssl-101u_x86_gcc_O3_extraction/start_hash@081dc670.c,"The function takes in a pointer to an array of 32-bit integers. It checks if the value at index 2 of the array is not equal to 0. If it is not 0, the function initializes the array by setting various elements to 0. Specifically, it sets index 4 and 11 to 0, and sets all the elements from index 5 to index 11 (inclusive) to 0. It also sets index 12 and 19 to 0, and sets all the elements from index 13 to index 19 (inclusive) to 0. Finally, it sets index 0, 1, and 3 to 0. If the value at index 2 is 0, the function returns 0, otherwise it returns 1."
openssl-101u,O3,x86,surewarehk_finish,./data/decomp/openssl-101u_x86_gcc_O3_extraction/surewarehk_finish@081a36a0.c,"This function checks if the surewarehk_dso variable is null. If it is null, it sets the SUREWARE_lib_error_code to the next error code in the library and sets the line and iVar1 variables accordingly. If it is not null, it calls the p_surewarehk_Finish function pointer and sets the uVar2 variable to 1. It then frees the surewarehk_dso variable and sets the SUREWARE_lib_error_code to the next error code in the library if there was an error in freeing the variable. It also frees the logstream variable if it is not null. Finally, it sets all function pointers to null and returns the uVar2 variable."
openssl-101u,O3,x86,sv_body,./data/decomp/openssl-101u_x86_gcc_O3_extraction/sv_body@08068440.c,"The first function sets up an SSL connection with a client and handles incoming data. It initializes the SSL library and creates a new SSL context, loads the specified certificate and private key files, sets up a TCP/IP socket and listens for incoming connections, accepts incoming connections and performs SSL handshake, reads data from the client and writes it to the server, reads data from the server and writes it to the client, handles various commands sent by the client, such as printing clear text, renegotiating SSL connection, and printing SSL statistics, handles errors, and closes connections when necessary.

The second function initializes various variables and sets up the SSL connection. It enters a loop that reads input from the client and processes it. Depending on the input, it may send data back to the client, print error messages, or close the connection. If the input is ""GET / HTTP/1.1\\r\\n"", the function sends an HTTP response back to the client. If the input is ""QUIT\\r\\n"", the function closes the connection. If there is no input pending, the function waits for more input using the SSL_read function. If there is pending input, it processes it immediately. If there is an error during the SSL_read function, the function prints an error message and closes the connection. Once the loop has finished, the function cleans up any resources and returns a status code indicating whether the connection was successful or not."
openssl-101u,O3,x86,TLSv1_method,./data/decomp/openssl-101u_x86_gcc_O3_extraction/TLSv1_method@080aa220.c,"The function returns a pointer to an SSL_METHOD object representing the TLSv1 protocol, implemented in the TLSv1_method_data_15770 variable. The calling convention and parameter storage are unknown and may have specific requirements."
openssl-101u,O3,x86,__libc_csu_init,./data/decomp/openssl-101u_x86_gcc_O3_extraction/__libc_csu_init@081ea170.c,"The function initializes the C runtime environment by calling the _init() function to initialize the dynamic linker and other runtime components. It then loops through an array of initialization functions for global and static objects and calls each of them with three parameters. Finally, the function returns once all initialization functions have been called."
openssl-101u,O3,x86,__udivdi3,./data/decomp/openssl-101u_x86_gcc_O3_extraction/__udivdi3@081e9ee0.c,"The function is a division operation for unsigned 64-bit integers. It takes four parameters, which are four 32-bit unsigned integers: param_1, param_2, param_3, and param_4. The function returns an unsigned 64-bit integer (ulonglong). 

The function first checks if param_4 is zero. If it is, it performs a simple division of param_1 and param_2 by param_3 and returns the quotient as an unsigned 64-bit integer. If param_4 is not zero, the function calculates the number of bits needed to represent param_4 and uses it to perform a long division of the 64-bit unsigned integer formed by concatenating param_2 and param_1 by the 32-bit unsigned integer formed by concatenating param_4 and param_3. 

The function uses bitwise operations to perform the division and checks for overflow conditions to ensure that the result is accurate. The function returns the quotient as an unsigned 64-bit integer."
openssl-101u,O0,mips,aep_mod_exp.part.0,./data/decomp/openssl-101u_mips_gcc_O0_extraction/aep_mod_exp.part.0@005ccd6c.c,These functions perform modular exponentiation using the AEP cryptographic library. The first function connects to a remote cryptographic device and updates a connection table. The second function implements the Diffie-Hellman key exchange algorithm. The third function checks the modulus and opens a connection to the AEP device to perform the modular exponentiation. The fourth function loads the AEP library and performs error checking before calling the AEP_ModExp function. All functions include error handling mechanisms.
openssl-101u,O0,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_mips_gcc_O0_extraction/asn1_bio_callback_ctrl@0062a2f0.c,"The function is a callback implementation for OpenSSL library that takes an integer parameter and returns an integer value. It checks if the value stored at the memory location is not equal to zero, and if it is not zero, it jumps to an address stored in a global variable and executes the code at that address as a function. If the value stored at the memory location is zero, the function returns zero."
openssl-101u,O0,mips,asn1_bio_ctrl,./data/decomp/openssl-101u_mips_gcc_O0_extraction/asn1_bio_ctrl@0062a3e4.c,"The function is an implementation of the BIO_ctrl function in OpenSSL's ASN.1 library. It takes four parameters: param_1 is a pointer to a BIO structure, param_2 is a control command, param_3 is a control argument, and param_4 is a pointer to a buffer for the control return value. The function first checks if the BIO structure has been initialized, and if not, returns 0. If the control command is 0x97, the function sets two values in the BIO structure (piVar3) based on the control argument and returns 1. If the control command is less than 0x98, the function handles a few specific control commands. If the command is 0x95, the function sets two other values in the BIO structure based on the control argument and returns 1. If the command is greater than 0x95, the function retrieves two values from the BIO structure and writes them to."
openssl-101u,O0,mips,asn1_bio_free,./data/decomp/openssl-101u_mips_gcc_O0_extraction/asn1_bio_free@0062a314.c,"The function takes an integer parameter `param_1`, likely a pointer to some data structure, retrieves an integer value from an offset of 0x20 from the data structure and stores it in the variable `iVar1`. If `iVar1` is not equal to zero, the function checks if the value stored at an offset of 4 from `iVar1` is not equal to zero. If it is not zero, the function calls a function pointer (`PTR_CRYPTO_free_006a6e88`) with the value at that offset. The function then calls the same function pointer with the value stored in `iVar1`, sets some values to zero at various offsets in the data structure and returns 1. If `iVar1` is equal to zero, the function simply returns 0. Overall, this function appears to be freeing memory allocated for some data structure."
openssl-101u,O0,mips,asn1_bio_write.part.1,./data/decomp/openssl-101u_mips_gcc_O0_extraction/asn1_bio_write.part.1@0062a7fc.c,"The function takes in three parameters: two integers and a pointer to a uint. It checks if the uint pointer is null, returning 0 if so. If the uint is less than 5, it enters a switch statement to handle different operations. If the uint is greater than or equal to 5, the function sets the second parameter to 0xf, clears the flags of the BIO, and returns 0. The function uses pointers and integer variables to keep track of progress and calls various OpenSSL functions."
openssl-101u,O0,mips,asn1_bio_write,./data/decomp/openssl-101u_mips_gcc_O0_extraction/asn1_bio_write@0062ab7c.c,"The function takes in three integer parameters: param_1, param_2, and param_3. It checks if param_2 is not equal to 0, param_3 is greater than -1, and the integer value stored at the memory location (param_1 + 0x24) is not equal to 0. If all these conditions are true, the function calls another function named ""asn1_bio_write_part_1"" and returns its result. Otherwise, it returns 0."
openssl-101u,O0,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BIO_asn1_get_suffix@0062ada0.c,"This function takes a BIO object pointer, a pointer to a suffix, and a pointer to a suffix free. It initializes a local variable to the current value of the stack check guard and calls the BIO_ctrl function with the arguments 0x98, 0, and a pointer to a local variable. If the return value is greater than 0, it sets the suffix and suffix free pointers to the values of the local variables. It checks if the value of the stack check guard is the same as the initial value. If it is, it returns the return value of the BIO_ctrl function. If it is not, it calls the stack check fail function. If it returns the value _bignum_nist_p_192, it means an error occurred during the function."
openssl-101u,O0,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BIO_asn1_set_prefix@0062ac2c.c,"The function BIO_asn1_set_prefix sets the ASN.1 prefix for a BIO object by calling the BIO_ctrl function with various parameters. It takes in a BIO object, a prefix string, and a function pointer to free the prefix string. The function handles memory allocation and deallocation for the prefix string and returns the result of the BIO_ctrl call. The ASN.1 prefix is set to a value stored in memory at the addresses DAT_00000095 and DAT_00000097, which are likely constants defined elsewhere in the code."
openssl-101u,O0,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_get0_nist_prime_224@0062ae4c.c,"The function returns a pointer to a BIGNUM structure containing a pre-defined NIST prime number with 224 bits. The prime number value is stored in the global variable _bignum_nist_p_224. The function does not take any parameters, and its parameter storage is locked and cannot be modified. The calling convention of the function is unknown."
openssl-101u,O0,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_get0_nist_prime_384@0062ae64.c,"The function returns a pointer to a BIGNUM structure that contains the value of a NIST prime number with 384 bits. The value of this prime number is stored in a global variable named ""_bignum_nist_p_384"". The purpose of this function is to provide a convenient way to access this prime number value for cryptographic operations. The warning message indicates that the calling convention used by this function is unknown, which may cause issues with the way parameters are stored in memory."
openssl-101u,O0,mips,BN_GF2m_add,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_add@00623a34.c,The function BN_GF2m_add performs addition of two binary polynomials represented by arrays of unsigned integers and stores the result in another array. It checks which array has a higher degree and expands the result array if necessary. The addition is performed by XOR-ing corresponding coefficients until all coefficients of the smaller polynomial have been processed.
openssl-101u,O0,mips,BN_GF2m_mod,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod@00623cb4.c,"The first function, BN_GF2m_mod, takes four arguments: an integer pointer, a second integer pointer, a pointer to an array of integer pointers, and a character pointer. It returns an unsigned integer. The function checks if the second argument is NULL and returns 0 if it is. If the first element of the array pointed to by the third argument is NULL, it sets the first argument to 1 and returns 1. Otherwise, it calls BN_GF2m_mod_arr_part_0 and stores the result in uVar6. If the second argument is not NULL, the function checks if the first argument is equal to the second argument. If it is not, it expands the first argument if necessary and copies the content of the second argument to the first argument. It then sets the second element of the second argument to the size of the second.

The second function takes in four parameters: two pointers to BIGNUM objects, a pointer to a GF2m polynomial, and a pointer to a BN_CTX object. It returns a boolean value indicating whether the first BIGNUM object is a quadratic residue modulo the GF2m polynomial. The function initializes a pointer to a BIGNUM object and sets its value to 0. It then checks if the second BIGNUM object is equal to 0 or 1. If it is, the function sets the first BIGNUM object to 0 and returns true. If the second BIGNUM object is not equal to 0 or 1, the function checks if the first BIGNUM object is equal to the second BIGNUM object. If it is not, the function expands the size of the first BIGNUM object if necessary and copies the contents of the second BIGNUM object into it."
openssl-101u,O0,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_arr@00623bc0.c,"The function BN_GF2m_mod_arr takes four parameters, the first three of which are pointers to integers. The function returns an unsigned integer. The function first checks if the third parameter is equal to zero. If so, it sets the first parameter to zero and returns 1. If the third parameter is not zero, the function checks if the first parameter is equal to the second parameter. If not, it expands the first parameter to have enough space to hold the second parameter. The function then calls the function BN_GF2m_mod_arr_part_0, passing in the first and third parameters. The function returns the value returned by BN_GF2m_mod_arr_part_0."
openssl-101u,O0,mips,BN_GF2m_mod_div,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_div@006258c4.c,"The function BN_GF2m_mod_div takes in five parameters, likely integers, a pointer to an integer, and a pointer to a BN_CTX structure. It starts the BN_CTX context, gets a new integer variable, calculates the inverse of param_3 modulo param_4 using BN_GF2m_mod_inv, and stores it in iVar1. If the function call returns 0, the function returns false."
openssl-101u,O0,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_div_arr@00625adc.c,"The function BN_GF2m_mod_div_arr takes in five parameters: param_1, param_2, param_3, param_4, and param_5. param_1 and param_2 are arrays of integers representing binary polynomials in GF(2^m). param_3 is an integer representing a binary polynomial in GF(2^m). param_4 is an array of integers representing a binary polynomial in GF(2^m) that is used as the divisor. param_5 is a BN_CTX object used for memory management. The function initializes a new BN_CTX object using the PTR_BN_CTX_start_006a8528 and PTR_BN_CTX_get_006a852c functions. If the initialization fails, the function returns false. The function then creates a new binary polynomial using the values in param_4, which is used as the divisor. It calculates the inverse of this polynomial using the BN_GF2m_mod."
openssl-101u,O0,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_mul@00624cdc.c,"The function BN_GF2m_mod_mul is a wrapper function that calculates the number of bits in the input parameter and allocates memory for an array of integers based on that number of bits. It then extracts the significant bits from the input parameter and stores their positions in the allocated array. If the input parameter is zero, the function returns zero. Otherwise, it calls the BN_GF2m_mod_mul_arr function with the extracted positions and other input parameters. If the number of significant bits extracted is greater than the allocated array size, an error is reported using the ERR_put_error function. Finally, the allocated memory is freed and the function returns the result of the BN_GF2m_mod_mul_arr function."
openssl-101u,O0,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_mul_arr@00624144.c,"1. The function BN_GF2m_mod_mul_arr performs a multiplication of two binary polynomials represented as arrays of uints in GF(2^m) field. It takes four uint pointers as input, representing the two polynomials to be multiplied and the result of the multiplication. The function also takes an additional parameter, which is a BN_CTX struct. If the second input parameter is equal to the third input parameter, then the function computes the square of the polynomial represented by the second input parameter. Otherwise, the function computes the product of the two polynomials represented by the second and third input parameters. If the result parameter is not large enough to hold the result of the multiplication, the function expands it using the bn_expand2 function. The function then performs the multiplication using the SQR_tb table, which contains precomputed squares of all possible 4-bit patterns. The multiplication is performed using a standard binary multiplication algorithm. Finally, the function reduces the result modulo the irreducible polynomial represented by the field.

2. The function takes in several arguments, including two uint32_t values (uVar3 and uVar6), a pointer to an array of uint32_t values (puVar7), and a pointer to an array of pointers to uint32_t values (ppuVar14). It also initializes several local variables, including an array of uint32_t values (local_4c) and several uint32_t variables (uVar8, uVar18, uVar23, iVar21, uVar12, uVar19, uVar24, uVar9, uVar25). The function then performs a series of bitwise operations and XOR operations using the input values and the local variables to calculate a final uint32_t value (uVar9). It also updates the local variables and performs additional bitwise operations to calculate two more uint32_t values (uVar24 and uVar19). Finally, the function XORs the two input values with the calculated uint32_t values (uVar'.

3. The function is an implementation of modular reduction in binary fields. It takes four parameters: a pointer to a BIGNUM structure (param_1), a pointer to a BIGNUM structure representing the irreducible polynomial (param_2), a pointer to a BIGNUM structure representing the input value to be reduced (param_4), and a pointer to a BN_CTX structure (param_5). The function first checks if the input value is zero or"
openssl-101u,O0,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_sqr@00624ed0.c,"The function BN_GF2m_mod_sqr calculates the square of a binary polynomial in GF(2^m) field. It takes four parameters: an undefined parameter, an undefined parameter, a pointer to an array of integers representing the binary polynomial, and an undefined parameter. The function allocates memory for a new array to store the result and returns 0 if the memory allocation fails. If the binary polynomial is equal to 0, the function sets the result to 0 and returns. Otherwise, the function loops through each word in the binary polynomial and checks each bit, adding the corresponding power of x to the result array. The function then calculates the length of the result array and calls the BN_GF2m_mod_sqr_arr function to calculate the square of the binary polynomial. If the length of the result array is greater than the maximum allowed length, the function does not return a value."
openssl-101u,O0,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_sqrt@006262f8.c,"The function takes four parameters: two integers, a pointer to an array of integers, and another integer. It calculates the number of bits in the input array, adds 1 to that value, and then allocates memory for a new array of integers with that size. It extracts the indices of the set bits in the input array and stores them in the new array of integers. The function then uses the new array to perform a modular exponentiation operation and stores the result in the output integer. If any errors occur during the execution of the function, an error message is printed. The function frees the memory allocated for the new array and returns the output integer. If the second element of the input array is 0, it sets the output integer to 0 and returns. If the new array is empty, it sets the output integer to 1 and returns."
openssl-101u,O0,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_GF2m_mod_sqr_arr@00623ea0.c,"The function BN_GF2m_mod_sqr_arr takes in four parameters: a pointer to a pointer to an array of unsigned integers (param_1), a pointer to an array of integers (param_2), a pointer to an integer (param_3), and an undefined value (param_4). The function initializes a BN_CTX object, performs a squaring operation on the array of integers, and stores the result in the output array. The function also checks if the pointer to the BN_CTX object is null and returns false if it is."
openssl-101u,O0,mips,BN_kronecker,./data/decomp/openssl-101u_mips_gcc_O0_extraction/BN_kronecker@00622900.c,"The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs a and b using a binary algorithm. The Kronecker symbol is a generalization of the Legendre symbol and is defined as follows: If b is even, return 0. If a == 0, return 0. If a == 1, return 1. If a < 0, calculate (-1)^((b-1)/2) and multiply it by the Kronecker symbol of -a and b. If a > 1 and a is odd, use the binary algorithm to calculate the Kronecker symbol. The binary algorithm works as follows: Find the largest power of 2 that divides b (i.e., find the exponent of the largest power of 2 that is a factor of b). Divide b by 2 raised to that power, and multiply a by the same power of 2. If the exponent."
openssl-101u,O0,mips,by_dir_entry_free,./data/decomp/openssl-101u_mips_gcc_O0_extraction/by_dir_entry_free@00584cb0.c,"The `by_dir_entry_free` function frees the memory allocated to a given pointer. If the value pointed to by the pointer is not equal to zero, it calls the `CRYPTO_free` function. It also checks the value at index 2 of the pointer and calls the `sk_pop_free` function if it is not zero, passing a function pointer as the second argument. Finally, it calls the `CRYPTO_free` function again with the pointer as the argument."
openssl-101u,O0,mips,cswift_rand_bytes,./data/decomp/openssl-101u_mips_gcc_O0_extraction/cswift_rand_bytes@005cfaa0.c,"The first function implements a random number generator using the CSWIFT cryptographic library, and also includes a Diffie-Hellman key exchange implementation. It dynamically loads the CryptoSwift library and retrieves necessary function pointers. It also performs modular exponentiation operations and RSA encryption.

The second function is a decompiled version of a C code that uses the CSWIFT library to perform cryptographic operations. It sets error codes and prints error messages to the console.

The third function is a decompiled version of a function in the CryptoSwift library that performs modular exponentiation operations.

The fourth function performs RSA encryption operations using the CryptoSwift library.

The fifth function performs various cryptographic operations and checks for errors.

The sixth function is a wrapper for calling the CryptoSwift library to perform cryptographic operations. It sets up data structures and checks for errors.

The seventh function generates a signature for a message using a private key and the CSWIFT library.

The eighth function performs a DSA signature verification using the CryptoSwift library.

The ninth function is a wrapper around the CryptoSwift hardware engine, providing a high-level interface for using the engine to perform cryptographic operations.

The last function initializes the CSWIFT library and sets up the engine for the library, loading error strings and adding the engine to the library."
openssl-101u,O0,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_mips_gcc_O0_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061c2f0.c,"The function calls an unknown function through a function pointer located at 0x006a8674. The pointer is believed to point to a function that can deserialize an ASN.1 structure that represents GOST client key exchange parameters. The deserialized data is not utilized in this function, and there is no return value."
openssl-101u,O0,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_mips_gcc_O0_extraction/d2i_GOST_KEY_PARAMS@0061c230.c,"The function calls an indirect jump to a code pointer that likely converts an ASN.1 encoded GOST key parameters structure to an internal representation. However, the exact function being called cannot be determined due to the complexity of the code. The function returns without any further processing."
openssl-101u,O0,mips,decode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O0_extraction/decode_gost_algor_params@00618f2c.c,"The function `decode_gost_algor_params` takes in two arguments, `param_1` and `param_2`, both of type `undefined4`. The function first initializes some variables and calls the `X509_ALGOR_get0` function to get the algorithm parameters from `param_2`. If the size of the parameters is not 16 bytes, an error is thrown and the function returns 0. If the parameters are of the correct size, the function calls `d2i_GOST_KEY_PARAMS` to decode the parameters and store them in `puStack_68`. If this operation fails, an error is thrown and the function returns 0. If the parameters are successfully decoded, the function calls `EVP_PKEY_set_type` to set the type of the key to either `NID_id_GostR3410_2001` or `NID_id_GostR3410_94`. If this operation fails, an error is thrown and...

The function is a part of a program that deals with elliptic curve cryptography using the GOST algorithm. It takes an EVP_PKEY structure as input and extracts the public key from it. It then sets the affine coordinates of the EC_POINT structure using the extracted public key. If successful, it sets the public key of the EC_KEY structure using the EC_POINT structure. The function also performs error checking and returns appropriate error messages if something goes wrong. It checks if the input EVP_PKEY structure is valid and if the extracted public key is valid. It also checks if the EC_KEY structure is valid and if the base IDs of the input EVP_PKEY and EC_KEY structures match. If any of these checks fail, an error message is returned. The function then computes the public key using the extracted private key if it exists, or sets the public key to 1 if it doesn't. Finally, it returns a success or failure status."
openssl-101u,O0,mips,DES_xcbc_encrypt,./data/decomp/openssl-101u_mips_gcc_O0_extraction/DES_xcbc_encrypt@00621820.c,"The first four function summaries describe different encryption algorithms. The first function performs DES encryption using the XCBC mode of operation, the second function performs AES encryption using the CBC mode of operation, the third function also performs AES encryption but does not specify the mode of operation, and the fourth function performs Blowfish encryption/decryption in OFB mode.

The fifth function summary describes a function that performs the OFB mode of operation for block ciphers, taking in a block cipher context, an initialization vector, input and output data, and the length of the data.

The sixth function summary describes a function that takes in several input parameters, initializes variables, performs operations such as bitwise shifts and XOR operations, loops through a block of memory, checks for a certain integer value, and calls cryptographic functions before returning."
openssl-101u,O0,mips,dgram_ctrl,./data/decomp/openssl-101u_mips_gcc_O0_extraction/dgram_ctrl@00529e10.c,"The first function, `dgram_ctrl`, takes in four parameters and returns an undefined4 value. It initializes several variables and performs various actions based on a switch statement that takes in a command.

The second function is a decompiled version of the OpenSSL library function `BIO_write`. It takes in several parameters, including a BIO object, a buffer to write to the BIO object, the length of the buffer, and a pointer to a variable that will hold the number of bytes written. The function checks if the BIO object is null, and if so, returns an error. It then checks if the BIO object is of type ""memory"" and writes the buffer to the memory buffer of the BIO object. If the BIO object is not of type ""memory"", the function checks if the BIO object has a write function and calls that function to write the buffer to the BIO object. The function also handles several special cases, such as if the BIO object is of type ""socket"" or ""file""."
openssl-101u,O0,mips,dlfcn_bind_func,./data/decomp/openssl-101u_mips_gcc_O0_extraction/dlfcn_bind_func@0062947c.c,"The function takes in two integer parameters, param_1 and param_2. If either parameter is equal to 0, it sets two variables uVar2 and uVar3 to 0x43 and 0x109 respectively. If both parameters are non-zero, it calls a function located at PTR_sk_num_006a6e2c with the value located at the memory address (param_1 + 4) as its parameter. It stores the result in iVar1. If iVar1 is less than 1, it sets uVar2 to 0x69 and uVar3 to 0x10d. If iVar1 is greater than or equal to 1, it retrieves the value located at the memory address (param_1 + 4) and calls a function located at PTR_sk_num_006a6e2c with this value as its parameter. It stores the result in iVar1. It then retrieves the value."
openssl-101u,O0,mips,dlfcn_bind_var,./data/decomp/openssl-101u_mips_gcc_O0_extraction/dlfcn_bind_var@006295f0.c,"The function dlfcn_bind_var takes two parameters, param_1 and param_2. If either parameter is equal to zero, it sets two variables to specific values. Otherwise, it calls a function with the value stored at param_1 + 4 as its parameter. If the returned value is less than 1, it sets the variables to different values. Otherwise, it retrieves the top element of a stack and checks if it is not equal to zero. If it is not zero, it calls another function."
openssl-101u,O0,mips,dlfcn_globallookup,./data/decomp/openssl-101u_mips_gcc_O0_extraction/dlfcn_globallookup@00629030.c,"The function uses dynamic loading of shared libraries to look up a symbol with the given name. It opens the default shared library search path and returns a handle to the loaded library. If the library cannot be opened, it returns 0. If the library is successfully opened, the function then looks up the symbol with the given name in the loaded library using dlsym. If the symbol is found, it returns the address of the symbol. Finally, it closes the loaded library using dlclose and returns the address of the symbol to the caller."
openssl-101u,O0,mips,doapr_outch.constprop.0,./data/decomp/openssl-101u_mips_gcc_O0_extraction/doapr_outch.constprop.0@00524768.c,"The function takes four parameters: two integer pointers, and two uint pointers. It first assigns the values of the uint pointers to local variables uVar1 and uVar3. If the second integer pointer (param_2) is not null and uVar1 is equal to uVar3, it checks if uVar3 is less than or equal to 0x7ffffbff. If it is, the function returns 0. If uVar3 is less than or equal to 0x7ffffbff, the function assigns the value of param_2 to a local variable iVar2, adds 0x400 to uVar3 and assigns it to uVar1. If iVar2 is equal to 0, the function calls the malloc function with uVar1 as the size and ""b_print.c"" and 0x2f3 as the file and line number. If the malloc function returns 0, the function returns 0."
openssl-101u,O0,mips,dtls1_link_min_mtu,./data/decomp/openssl-101u_mips_gcc_O0_extraction/dtls1_link_min_mtu@004a4df8.c,"The function returns a constant value of 256 in decimal or 0x100 in hexadecimal, which is likely the minimum MTU size for a DTLS link."
openssl-101u,O0,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_mont_field_encode@0062730c.c,"The function takes in an integer and three undefined values as parameters. It accesses a specific memory location using the integer and checks if the value stored there is zero or not. If it is not zero, the function calls a code snippet with the second, third, and fourth parameters as inputs, and returns the output of this code snippet. If the value is zero, the function generates an error message using another code snippet and returns zero."
openssl-101u,O0,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_mont_field_sqr@00627294.c,"The function checks if a certain value in the structure pointed to by `param_1` is not equal to zero. If it is not zero, the function calls another function at the address `PTR_BN_mod_mul_montgomery_006a8558` with the parameters `param_2`, `param_3`, `param_3`, the value at offset `0xa0` in the structure pointed to by `param_1`, and `param_4`. The result of this function call is returned. If the value at offset `0xa0` in the structure pointed to by `param_1` is zero, the function calls another function at the address `PTR_ERR_put_error_006a7f34` with the parameters `0x10`, `0x84`, `0x6f`, `""ecp_mont.c""`, and `0x10c`. This function call is an error message and the function returns 0."
openssl-101u,O0,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_mont_group_init@00626d80.c,"The function initializes a Montgomery elliptic curve group over a finite field of prime order by calling ec_GFp_simple_group_init() to initialize a simple elliptic curve group over the same field. It then sets two values to zero in the group structure, which likely represent parameters specific to the Montgomery curve form."
openssl-101u,O0,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_nist_field_mul@0062772c.c,"The function takes five integer parameters. If any of the first four parameters are equal to zero, it calls a function to put an error message and exits the function. 

If the fifth parameter is zero, the function creates a new BN_CTX object and multiplies the second and third parameters using the fourth parameter as the modulus. The result is stored in the BN_CTX object and then squared using the first parameter as the modulus. The BN_CTX object is then freed and the function returns a boolean indicating whether the operation was successful or not. 

If the fifth parameter is not zero, the function multiplies the second and third parameters using the fourth and fifth parameters as the modulus, respectively. The result is then squared using the first parameter as the modulus and the function returns a boolean indicating whether the operation was successful or not."
openssl-101u,O0,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_nist_group_copy@00627470.c,"The function ec_GFp_nist_group_copy copies the elliptic curve group parameters from param_2 to param_1 by first copying a 4-byte value from offset 0xa8 of param_2 to offset 0xa8 of param_1, then calling the function ec_GFp_simple_group_copy to copy the remaining group parameters from param_2 to param_1, and finally returning."
openssl-101u,O0,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_nist_group_set_curve@00627488.c,"The function `ec_GFp_nist_group_set_curve` takes in five parameters: `param_1`, `param_2`, `param_3`, `param_4`, and `param_5`. It initializes a new `BN_CTX` object using the function pointer `PTR_BN_CTX_new_006a794c` if `param_5` is equal to 0. If the initialization fails, the function returns 0. Otherwise, it starts the `BN_CTX` object using `PTR_BN_CTX_start_006a8528` and gets a `BIGNUM` object using `PTR_BN_CTX_get_006a852c`. If the `BIGNUM` object is NULL, the function returns 0. If `param_5` is not equal to 0, the function starts the `BN_CTX` object using `PTR_BN_CTX_start_006a8528` and gets a..."
openssl-101u,O0,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062d680.c,"The function `ec_GFp_simple_get_Jprojective_coordinates_GFp` takes six parameters, which are pointers to integers. It returns a boolean value indicating whether the operation was successful or not. The function first checks if a certain value in the structure pointed to by the first parameter is zero. If it is zero, it checks if the second, third, and fourth parameters are zero or not. If the third and fourth parameters are not zero, it copies their values to certain locations in memory. If the fifth parameter is not zero, it also copies its value to a certain location in memory. Finally, it returns `true`. If the value in the structure pointed to by the first parameter is not zero, the function creates a new `BN_CTX` object (a type of big number context) and assigns its pointer to the sixth parameter. If the sixth parameter is not zero, it proceeds to perform the same operations as before, but using functions pointed to by the structure pointed to by the."
openssl-101u,O0,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_group_check_discriminant@0062d86c.c,"The function `ec_GFp_simple_group_check_discriminant` checks if the discriminant of an elliptic curve group over a finite field is non-zero. It takes two parameters: an array `param_1` containing the parameters of the elliptic curve group, and an integer `param_2` which is used as a temporary variable. If `param_2` is zero, the function allocates memory for it using `PTR_BN_CTX_new_006a794c`, which is a function pointer. If the allocation fails, an error message is printed and the function returns `false`. The function then initializes several variables using `PTR_BN_CTX_start_006a8528` and `PTR_BN_CTX_get_006a852c`, which are also function pointers. These variables are used to perform arithmetic operations on the parameters of the elliptic curve group. If the parameter `param_1` has a non-zero discriminant, the function calculates the discriminant using."
openssl-101u,O0,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_group_clear_finish@0062d184.c,"The function clears and frees memory allocated for group parameters of an elliptic curve over a finite field. It takes an integer parameter and calls a function at the address stored in a global variable with the argument of the integer parameter plus a hexadecimal value. It also calls a function indirectly through a jump table with a similar argument. Finally, it returns from the function. The specific functions called are related to the OpenSSL library used in the implementation of the elliptic curve cryptography."
openssl-101u,O0,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_group_copy@0062e6d4.c,"The function copies the contents of one EC group to another by calling a function to copy the field parameter, then copying the second and third parameters in the same manner. It then copies the fourth parameter from the second group to the first group. If all copies are successful, the function returns 1, otherwise it returns 0."
openssl-101u,O0,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_group_get_degree@0062d234.c,"The function takes an integer parameter, adds 0x48 to it, and calls an indirect function through a function pointer (PTR_BN_num_bits_006a71f4) with the modified parameter value as an argument. The called function is likely to calculate the number of bits in a big integer, but its definition is not provided in the code snippet. The function returns without using the result of the function call."
openssl-101u,O0,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_group_set_curve@0062e814.c,"The function ec_GFp_simple_group_set_curve sets the curve parameters for an elliptic curve group over a prime field. It takes in the curve parameters including the prime field modulus, curve coefficients, and generator point, and returns a boolean indicating success. The function first validates the input parameters and initializes a BN_CTX structure for arithmetic operations. It then computes the modulus of the curve coefficients and generator point with respect to the modulus. If successful, it checks for a defined callback function."
openssl-101u,O0,mips,ec_GFp_simple_invert,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_invert@0062f784.c,"The function takes two parameters, param_1 and param_2. It first calls a function at address PTR_EC_POINT_is_at_infinity_006a864c to check if a point on an elliptic curve is at infinity. If the point is not at infinity and the second parameter (param_2) has a non-zero value at offset 0x1c, it then calls a function at address PTR_BN_usub_006a85b0 to subtract the value at offset 0x18 of param_2 from the value at offset 0x48 of param_1. If either of the conditions are not met, it returns 1. The function returns either the result of the subtraction or 1."
openssl-101u,O0,mips,EC_GFp_simple_method,./data/decomp/openssl-101u_mips_gcc_O0_extraction/EC_GFp_simple_method@0063055c.c,"The function returns a pointer to an EC_METHOD structure for elliptic curve arithmetic operations over prime numbers. The function's calling convention is unknown, and parameter storage is locked, making it potentially incompatible with some compilers or platforms."
openssl-101u,O0,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_point_copy@0062e774.c,"The function takes two integer parameters that are pointers to structures representing elliptic curve points. It copies the values of the second point to the first point, including the x-coordinate, y-coordinate, and the point's ""infinity"" flag. The function returns 1 if the copy was successful, and 0 otherwise. It uses the BN_copy function to copy the values of the points' coordinates."
openssl-101u,O0,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_point_finish@0062d130.c,"The function ec_GFp_simple_point_finish() frees the memory allocated for the x, y, and z-coordinates of an elliptic curve point and returns from the function."
openssl-101u,O0,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_point_get_affine_coordinates@0062db70.c,"The function takes five parameters: four integers and a pointer to an elliptic curve point. It returns a boolean value. The function checks if the input point is at infinity. If it is, the function returns false. If the fifth parameter is zero, the function creates a new BN_CTX (big number context) and sets it up. Otherwise, it uses the existing BN_CTX. The BN_CTX is used for temporary storage of big numbers during computations. If the input point has no pre-computed table (stored in the elliptic curve structure), the function computes the inverse of the y-coordinate of the point modulo the curve's order. It then computes the x-coordinate of the point using the inverse and the curve's equation. If the function is given valid output parameters for the x-coordinate and y-coordinate, it stores the computed values in them. If not, it returns false. If the input point has a pre-computed table, the function uses it to compute the x-coordinate of the point."
openssl-101u,O0,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O0_extraction/ec_GFp_simple_point_set_affine_coordinates@0062eb14.c,"The function takes in five parameters: param_1, param_2, param_3, param_4, and param_5. If param_3 and param_4 are not equal to zero, it calls two other functions to set the affine coordinates of a point on an elliptic curve. Specifically, it calls the BN_value_one function to obtain a value of 1, and then calls the EC_POINT_set_Jprojective_coordinates_GFp function to set the affine coordinates of the point using the parameters passed in. If either param_3 or param_4 is equal to zero, the function calls the put_error function to report an error and returns 0."
openssl-101u,O0,mips,encode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O0_extraction/encode_gost_algor_params@0061a624.c,"The following functions are described:

1. `encode_gost_algor_params`: Takes an integer pointer `param_1` as input and returns an integer pointer `piStack_a8`. It allocates memory for two integer pointers `piVar2` and `piStack_a4` using the `ASN1_STRING_new()` and `GOST_KEY_PARAMS_new()` functions respectively. If either of the allocations fails, the function calls `ERR_GOST_error()` and returns a null pointer. It determines the key type by calling `EVP_PKEY_base_id()` and checks if it is a GOST key or not. If it is a GOST key, it gets the curve name or parameter set depending on the type of GOST key. If it is not a GOST key, it sets the curve name to 0. The function then calls `i2d_GOST_KEY_PARAMS()` to encode the GOST key parameters into a byte string and stores the length of the byte.

2. Key generation algorithm for GOST keys: Takes in a pointer to an EVP_PKEY structure, which contains information about the type of key to be generated, and generates a new key of that type. It checks that the input EVP_PKEY structure is of type EVP_PKEY_GOST_R3410_2001, which is the only GOST key type currently supported. It then generates a new key pair using the GOST R 34.10-2001 algorithm, and sets the public and private key components of the EVP_PKEY structure to the corresponding values. If any errors occur during the key generation process, the function sets an error code and returns NULL. Otherwise, it returns a pointer to the generated key.

3. Decoding public keys for various key types: Takes in a pointer to a EVP_PKEY structure and a pointer to a char array. It checks the type of the EVP_PKEY and performs different actions based on the type. For RSA keys, it extracts the public key and encodes it using the ASN.1 DER format. For DSA keys, it extracts the public key and encodes it using the DSAParams structure defined in RFC 3279. For EC keys, it extracts the public key and encodes it using the ANSI X9.62 format. For GOST keys, it extracts the public key and encodes it using the GOST R 34.10-94 format. The encoded public key is then returned"
openssl-101u,O0,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_mips_gcc_O0_extraction/general_allocate_boolean.constprop.5@005b096c.c,"The function `general_allocate_boolean_constprop_5` takes in eight parameters: `param_1`, `param_2`, `param_3`, `param_4`, `param_5`, `param_6`, `param_7`, and `param_8`. If `param_4` is equal to `NULL`, the function sets `uVar5` to `0xc4`. Otherwise, it checks if `param_5` is not equal to zero and if the characters in `param_4` are valid according to a certain function (`PTR_strchr_006a9a28`). If the characters are not valid, the function sets `uVar5` to `0xc6`. If `param_2` is equal to zero, the function returns `-1`. Otherwise, if `param_8` is not equal to zero, the function allocates memory for an integer array of size `0x20` using the function `PTR`."
openssl-101u,O0,mips,get_gost_engine_param,./data/decomp/openssl-101u_mips_gcc_O0_extraction/get_gost_engine_param@0061e458.c,"The function takes an integer parameter and returns an integer value. If the parameter is equal to 0, it checks if a global variable called ""gost_params"" is equal to 0. If it is, it gets the value of an environment variable called ""CRYPT_PARAMS"" using a function called ""getenv"" and stores it in a local variable called ""iVar1"". If ""iVar1"" is not equal to 0, it duplicates the string using a function called ""BUF_strdup"" and assigns the result to ""gost_params"". Finally, the function returns the value of ""gost_params"". If the parameter is not equal to 0, the function returns 0."
openssl-101u,O0,mips,gost2001_param_encode,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost2001_param_encode@006196e8.c,"The function takes two parameters of type undefined4 and performs the following actions: declares a variable uVar1 of type undefined4, calls several functions located at different memory addresses with uVar1 as an argument, and stores the results in uVar1."
openssl-101u,O0,mips,gost_cipher_cleanup,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost_cipher_cleanup@0061c5f0.c,"The function takes an integer parameter to access a memory location, calls `gost_destroy()` with an argument from that location offset by 0xC to deallocate memory resources used by GOST cipher, sets the memory location to 0, and returns 1."
openssl-101u,O0,mips,gost_cipher_ctl,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost_cipher_ctl@0061ce84.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. 

If `param_2` is equal to 6, the function calls the `RAND_bytes` function to generate random bytes and stores them in the memory location pointed to by `param_4`. The size of the random bytes is determined by the value stored at `param_1 + 0x58`. If the `RAND_bytes` function returns a value less than 1, the function calls `ERR_GOST_error` and returns -1, otherwise it returns 1.

If `param_2` is equal to 7, the function checks if `param_4` is not equal to NULL. If it is not NULL, the function sets the value at the memory location pointed to by `param_4`."
openssl-101u,O0,mips,gost_cipher_do_cnt,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost_cipher_do_cnt@0061c7ec.c,"The function `gost_cipher_do_cnt` takes four parameters: an integer `param_1`, two byte pointers `param_2` and `param_3`, and an unsigned integer `param_4`. It checks the value of `uVar4` to determine the number of bytes of the counter that have already been processed. If `uVar4` is zero, it sets `uVar4` to 8 and `uVar3` to 0. Otherwise, it processes the remaining bytes of the counter by XORing them with the corresponding bytes of the input data (`param_3`) and storing the result in `param_2`. It then updates `uVar4` and `uVar`.

The function takes in four parameters: a pointer to a byte array (param_1), a byte array (param_2), an integer (param_3), and an integer (param_4). It returns an integer value. It initializes a local variable uVar3 to 4 and XORs the byte at offset 0x30 in param_1 with the byte at offset 0 in param_3 and stores the result in param_2[0]. If param_4 is less than or equal to uVar3 + 1, the function sets the value at offset 0x50 in param_1 to 1 and returns 1. If param_4 is greater than uVar3 + 1, the function XORs the byte at offset 0x31 in param_1 with the byte at offset 1 in param_3 and stores the result in param_2[1]. If param_4 is less than or equal to uVar3 + 1, the function sets the value at offset 0x50 in param_1 to 1 and returns 1."
openssl-101u,O0,mips,gost_cipher_init,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost_cipher_init@0061e0a8.c,"The `gost_cipher_init` function initializes the GOST cipher for encryption or decryption. It takes three parameters: `param_1` is a pointer to the `EVP_CIPHER_CTX` structure, `param_2` is a pointer to the encryption or decryption key, and `param_3` is a pointer to the initialization vector (IV). The function checks if the cipher has already been initialized by checking the value of a flag in the `EVP_CIPHER_CTX` structure. If the flag is not set, it proceeds to initialize the cipher. If no GOST engine parameter is specified, the function selects the default GOST cipher from a list of supported ciphers. If a GOST engine parameter is specified, the function uses it to select the appropriate cipher from the list. The function then sets the key and IV for the cipher using the `gost_key` and `memcpy` functions, respectively. Finally, the function returns a value of 1 to indicate success."
openssl-101u,O0,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O0_extraction/GOST_CIPHER_PARAMS_new@0061c2c0.c,The function creates a new instance of the GOST_CIPHER_PARAMS data structure using PTR_ASN1_item_new_006a8654. It casts the result to a code pointer and dereferences it to call the function. The function has no return value.
openssl-101u,O0,mips,gost_imit_final,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost_imit_final@0061de10.c,"The function takes in an integer and an undefined value. It initializes variables and retrieves values from the input integer. It checks if a certain value is equal to zero and throws an error if it is. If not, it checks another value and jumps to a specific location in the code if it is not zero. Otherwise, it enters a loop where it calls another function to get a MAC and sets a variable to 1. The function checks if a certain variable is equal to a guard value and exits if it is. Otherwise, it performs operations on the input integer, including calling a function to perform a MAC block operation, setting variables, and calling another function to perform key meshing if certain conditions are met. Finally, the function performs another operation."
openssl-101u,O0,mips,gost_imit_init_cpa,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost_imit_init_cpa@0061cdfc.c,"The function initializes the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A. It takes four parameters, but only uses the first one. It retrieves the integer value stored at offset 0xc in the first parameter and assigns it to the variable iVar2. Then, it sets several memory locations in iVar2 to 0, including offsets 0x1020 through 0x102f, 0x1030, and 0x1038. Finally, it calls the gost_init function with parameters iVar2, a pointer to the CryptoPro parameter set A, and the last two parameters from the original function call. The function returns 1 upon completion."
openssl-101u,O0,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O0_extraction/GOST_KEY_PARAMS_new@0061c260.c,The GOST_KEY_PARAMS_new function creates and returns a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new function.
openssl-101u,O0,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_mips_gcc_O0_extraction/GOST_KEY_TRANSPORT_free@0061c158.c,The function takes an undefined4 parameter and calls the ASN1_item_free function with the address stored in PTR_ASN1_item_free_006a8658 and a pointer to a GOST_KEY_TRANSPORT_it structure. Its purpose is to free memory allocated to a GOST_KEY_TRANSPORT structure.
openssl-101u,O0,mips,gost_param_free,./data/decomp/openssl-101u_mips_gcc_O0_extraction/gost_param_free@0061e380.c,"The ""gost_param_free"" function frees up memory allocated to the gost_params variable. If the variable is not equal to 0, it calls the ""PTR_CRYPTO_free_006a6e88"" function to free the memory and sets the gost_params variable to 0. The function then returns."
openssl-101u,O0,mips,hash_step,./data/decomp/openssl-101u_mips_gcc_O0_extraction/hash_step@0061e560.c,"The first function takes in a 32-bit integer and two pointers to arrays of 32-bit unsigned integers. It performs bitwise operations on the arrays, including XORing and shifting their elements, and calls another function, `gost_enc_with_key`, passing in the first parameter and the arrays as arguments. The purpose of the function is not clear without further context, but it appears to be some kind of hashing or encryption function.

The second function takes in two pointers to arrays of integers. It performs bitwise operations on the arrays and stores the results in local variables. It extracts specific bytes from the arrays using bitwise shifting and masking operations, combines these bytes into new integers using bitwise OR and AND operations, and performs more bitwise operations to obtain the final results. It XORs some of the local variables with values from the input arrays and stores the results in other local variables. Finally, the function assigns specific bytes of the local variables to a series of undefined variables, effectively obfuscating the results. The exact purpose of this function is difficult to determine without more context.

The third function takes in two pointers to input and output buffers. It performs a series of operations on the input buffer to encrypt it using the GOST algorithm and stores the result in the output buffer. It initializes several local variables and arrays and performs a series of bitwise operations on the input buffer, including shifting, XORing, and negating certain bytes. It also calls a function to perform the actual encryption using a key. After the encryption is complete, the function performs additional bitwise operations on the encrypted data and stores it in the output buffer. It appears to be a decompiled version of a GOST encryption function that takes in an input buffer, encrypts it using a key, and stores the result in an output buffer.

The fourth function is an implementation of the GOST encryption algorithm. It takes in three parameters: a pointer to the plaintext, a pointer to the key, and a pointer to the ciphertext buffer. The function initializes several local variables and performs some bitwise operations on them. It then calls a function to perform an initial encryption of the key. Next, the function enters a loop where it performs several rounds of encryption on the plaintext using the key. Each round involves XORing the plaintext with a portion of the key, performing some bitwise operations, and then XORing the result with the previous round's ciphertext. After the loop completes, the function XORs the final ciphertext with the initial plaintext to produce the encrypted message"
openssl-101u,O0,mips,hwcrhk_init,./data/decomp/openssl-101u_mips_gcc_O0_extraction/hwcrhk_init@005d44b4.c,"The `hwcrhk_init` function initializes the ""nfhwcrhk"" hardware cryptographic library. It loads the library if it has not already been loaded using `DSO_load` and binds various functions using `DSO_bind_func`. If successful, it sets global function pointers to these functions. If there are any errors, it sets an error code using `ERR_put_error`. The function also sets a global variable `hwcrhk_dso` to the loaded library, initializes a mutex if necessary, and returns a boolean indicating whether initialization was successful or not."
openssl-101u,O0,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_mips_gcc_O0_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061c1e8.c,"The function i2d_GOST_KEY_AGREEMENT_INFO converts a GOST_KEY_AGREEMENT_INFO structure into a DER-encoded format. It takes in two parameters, param_1 and param_2, both of type undefined4. The function calls a function pointer, which is pointing to the function PTR_ASN1_item_i2d_006a8678, responsible for the conversion using the GOST_KEY_AGREEMENT_INFO_it structure. The function then returns without any further processing."
openssl-101u,O0,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_mips_gcc_O0_extraction/i2d_GOST_KEY_TRANSPORT@0061c128.c,The function takes two parameters of type undefined4 and encodes the data in a specific format using a GOST_KEY_TRANSPORT_it structure. It is calling an indirect jump/call to a function stored in the global variable PTR_ASN1_item_i2d_006a8678 and passing the two parameters and a third parameter of type GOST_KEY_TRANSPORT_it. The encoded data is returned in the second parameter.
openssl-101u,O0,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101u_mips_gcc_O0_extraction/load_pkcs12.constprop.4@00459d08.c,"The function loads a PKCS12 file using d2i_PKCS12_bio and verifies the MAC using a password callback function. If the MAC verification fails, it prints an error message and returns 0. If the MAC verification succeeds, it parses the PKCS12 data using PKCS12_parse and frees the memory allocated for the PKCS12 data. The function includes error checking and stack protection code to prevent buffer overflows."
openssl-101u,O0,mips,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_mips_gcc_O0_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@004efe10.c,"The function takes in a BIGNUM pointer and several other parameters. It expands the BIGNUM pointer if necessary and performs a modular exponentiation operation using the other parameters. The result is stored in the BIGNUM pointer, which is then stripped of any leading zeros. The function returns 1 if successful and 0 if not."
openssl-101u,O0,mips,param_copy_gost94,./data/decomp/openssl-101u_mips_gcc_O0_extraction/param_copy_gost94@00619b84.c,"The function takes in two parameters of type undefined4 and returns an undefined4 value. It first gets the base ID and pointer to the EVP_PKEY structure for both parameters. If the base IDs are not the same, it throws an error and returns 0. If the second parameter's EVP_PKEY structure pointer is null, it throws an error and returns 0. Otherwise, it creates a new DSA structure and assigns the base ID of the second parameter's EVP_PKEY structure to it. If the first parameter's EVP_PKEY structure pointer is not null, it then copies the values of the three big numbers (BNs) from the first parameter's DSA structure to the second parameter's DSA structure using the BN_dup function. Finally, it computes the public key if necessary and returns 1."
openssl-101u,O0,mips,param_print_gost01,./data/decomp/openssl-101u_mips_gcc_O0_extraction/param_print_gost01@0061a0f8.c,"The function takes in three parameters: param_1, param_2, and param_3. It retrieves an EC key and its associated group using two functions, and gets the name of the curve used in the group using a third function. It then indents the output in a buffer using another function, prints the name of the curve using the retrieved value, and returns 1 if the indentation was successful, otherwise it returns 0. This function is used to print the parameter set (curve name) used in a given EC key."
openssl-101u,O0,mips,param_print_gost94,./data/decomp/openssl-101u_mips_gcc_O0_extraction/param_print_gost94@0061a1ac.c,These function summaries are all related to the GOST algorithm in OpenSSL. They involve generating and manipulating keys and parameters for encryption and decryption using the algorithm. The functions also include error handling and memory management code. Some of the functions print out information about the generated keys and parameters.
openssl-101u,O0,mips,pkey_ctrl_gost,./data/decomp/openssl-101u_mips_gcc_O0_extraction/pkey_ctrl_gost@0061acd8.c,"The first function, `pkey_ctrl_gost`, takes in four parameters and performs different actions based on the value of `param_2`.

The second function takes in several parameters and performs various operations on them. The purpose of the function is not clear without more context about the program it is a part of.

The third function takes a pointer to an EVP_PKEY object as input, extracts the public key and associated EC_GROUP object, computes the affine coordinates of the public key point, and prints them along with the name of the curve used in the EC_GROUP object. If any errors occur, it prints an error message and returns 0. Otherwise, it returns 1."
openssl-101u,O0,mips,pkey_free_gost94,./data/decomp/openssl-101u_mips_gcc_O0_extraction/pkey_free_gost94@0061a0d4.c,"The function takes an integer parameter assumed to be a pointer to a data structure related to a public key in the GOST94 algorithm. It checks if the data structure contains a non-null value at an offset of 0x14. If it does, the function jumps to an unknown function at the address pointed to by PTR_DSA_free_006a7530, which is assumed to be a function that frees memory related to the public key. If the value at the offset is null, the function simply returns without doing anything."
openssl-101u,O0,mips,priv_encode_gost,./data/decomp/openssl-101u_mips_gcc_O0_extraction/priv_encode_gost@0061b118.c,"The first function encodes a private key using the GOST algorithm. It takes in three parameters: `param_1`, `param_2`, and `param_3`. `param_1` is a pointer to a `PKCS8_PRIV_KEY_INFO` structure that will hold the encoded private key. `param_2` is a pointer to an `EVP_PKEY` structure that contains the private key to be encoded. `param_3` is a string that is used for indentation when printing debug information. The function first gets the ID of the algorithm used in the private key using `EVP_PKEY_base_id()`. It then uses `OBJ_nid2obj()` to get an `ASN1_OBJECT` structure that represents the algorithm. It then calls `encode_gost_algor_params()` to encode the algorithm parameters. If this function returns an error, the function returns 0. If the algorithm is GOST R 34.10-2001, the...

The second function is an implementation of the OpenSSL GOST engine's public key algorithm. It takes a pointer to an EVP_PKEY structure representing the public key, a BIO structure for output, and an integer for indentation level. The function first checks if the public key is of the correct type (EC key with GOST curve). If it is not, an error is thrown and the function returns 0. If the key is of the correct type, the function proceeds to extract the necessary parameters from the key (public key and curve parameters) using various OpenSSL functions. It then prints these parameters to the output BIO, along with the name of the curve being used. If any errors occur during the process, an error is thrown and the function returns 0. Otherwise, it returns 1 to indicate success."
openssl-101u,O0,mips,pub_encode_gost94,./data/decomp/openssl-101u_mips_gcc_O0_extraction/pub_encode_gost94@0061af08.c,"The first function `pub_encode_gost94` encodes a public key and its algorithm parameters using the OpenSSL library. It retrieves the algorithm identifier and parameters for the public key, encodes the algorithm parameters, calculates the size of the encoded public key, and encodes the public key. If there were any algorithm parameters, it also encodes them and appends them to the encoded public key. It returns the size of the encoded public key.

The second function is a C implementation of the OpenSSL command ""openssl pkey -text"". It takes an EVP_PKEY object as input and prints out information about its private and public keys, as well as the parameter set used. It checks if the EVP_PKEY object is valid and has a private key, retrieves the private key and prints it out. If it does not have a private key, it prints out ""<undefined>"". It also checks if the EVP_PKEY object is using the R3410 paramset, retrieves the public key and prints it out. If it is not using the R3410 paramset or the public key cannot be retrieved, it prints out ""<undefined>"". Finally, it prints out the parameter set used by the EVP_PKEY object, if it is using the R3410 paramset."
openssl-101u,O0,mips,pub_print_gost94,./data/decomp/openssl-101u_mips_gcc_O0_extraction/pub_print_gost94@0061a314.c,"The functions are all related to the GOST encryption algorithm and its implementation in OpenSSL. 

- The first function takes three parameters and returns an integer pointer. It retrieves the public key and encodes the parameter set and algorithm parameters before returning a pointer to the encoded algorithm parameters.
- The second function is part of a larger program that deals with encryption and decryption using the GOST algorithm. It takes several arguments and performs various operations on the input data, including encoding and decoding data, and allocating and freeing memory. 
- The third function generates a new GOST asymmetric key pair based on the parameters in an EVP_PKEY structure. It initializes variables and structures, checks for necessary parameters, generates the key pair, and encodes the public key.
- The fourth function encodes the private key of a GOST key pair in a format that can be written to a file or transmitted over a network. It checks for a valid key pair, encodes the algorithm parameters and private key, and formats and prints the encoded key to a BIO object for output.
- The fifth function prints information about a GOST R 34.10 public key to a BIO output. It checks for a valid EVP_PKEY structure, retrieves and prints the public key type and size, parameter set name, and public point x and y coordinates in hexadecimal format."
openssl-101u,O0,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O0_extraction/RSA_padding_add_PKCS1_PSS@006284c8.c,"The function RSA_padding_add_PKCS1_PSS adds padding to a message using the PKCS1 PSS scheme. It takes in the RSA key, message hash, hash function, and salt length. The function calculates the hash value size, checks validity, and generates a random salt of specified length. It then applies the PKCS1 MGF1 function to the salt to generate a mask, which is XORed with the hash value. The resulting masked hash value is concatenated with the salt and additional padding bytes to form the final padded message.

The second function takes in a message (EM), a local variable (local_4c), a pointer (pbVar10), a size (uVar3), and a hash value (Hash). It checks if a certain condition is met and performs several operations on the message EM if it is. It XORs certain bytes of the message with other bytes of the message and stores the result in a new buffer. The function then returns the length of the new buffer."
openssl-101u,O0,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O0_extraction/RSA_verify_PKCS1_PSS@00627a10.c,"The functions RSA_verify_PKCS1_PSS and RSA_padding_check_PKCS1_PSS_mgf1 are used to verify a signature using the RSA-PSS algorithm with PKCS1 padding. RSA_verify_PKCS1_PSS takes in a pointer to an RSA key, a message hash, an EVP_MD structure representing the hash function used, a signature, and the length of the signature. RSA_padding_check_PKCS1_PSS_mgf1 takes in several parameters, including the input message, its length, the RSA key, the hash function used, and the salt length. Both functions perform various checks, such as verifying the size of the RSA key and checking if the first byte of the signature is zero, before calculating the hash of the input message and generating a mask using the MGF1 function. Finally, both functions check if the decrypted message is properly padded and if the hash of the concatenated message and salt matches the hash value in the signature."
openssl-101u,O0,mips,sha_block_data_order,./data/decomp/openssl-101u_mips_gcc_O0_extraction/sha_block_data_order@00620130.c,"The functions all involve some form of cryptographic or hashing operation. They take in input parameters and perform a series of bitwise operations and arithmetic calculations on them to generate output values. Some of the functions implement the SHA-1 hash algorithm, which involves breaking the input message into blocks and performing operations on each block to generate a final hash value. Other functions involve manipulating input variables using XOR, addition, bit shifts, and multiplication by constants. The exact purpose and logic of each function may be difficult to determine without additional context."
openssl-101u,O0,mips,SHA_Final,./data/decomp/openssl-101u_mips_gcc_O0_extraction/SHA_Final@006215dc.c,"The SHA_Final function finalizes the SHA-1 hash computation and generates the final message digest. It adds a padding byte to the end of the data being hashed and fills the remaining block with zeros. If necessary, it adds a new block and adds the padding and zeros to it. The function then appends the length of the data being hashed (in bits) to the final block and processes it through the SHA-1 compression function. The resulting hash values are copied to the output buffer and the SHA_CTX structure is cleaned up. The function returns 1 to indicate successful completion."
openssl-101u,O0,mips,srp_verify_server_param,./data/decomp/openssl-101u_mips_gcc_O0_extraction/srp_verify_server_param@004bb9ec.c,"The function takes in an integer and a pointer to an undefined 4-byte value. It compares two values located at offsets 0x1ac and 0x1a8 from the integer parameter using a code pointer located at PTR_BN_ucmp_006a7fb4. If the result is greater than or equal to -1, or the second comparison between values located at offsets 0x1b4 and 0x1a8 from the integer parameter is greater than or equal to -1, or the integer value located at the address pointed to by the value located at offset 0x1b4 from the integer parameter is equal to 0, then the function sets the value pointed to by the second parameter to 0x2f and returns 0. If the above conditions are not met, the function calculates the number of bits of the value located at offset 0x1a8 from the integer parameter using a code."
openssl-101u,O0,mips,SSLv23_method,./data/decomp/openssl-101u_mips_gcc_O0_extraction/SSLv23_method@0048f230.c,"The SSLv23_method function returns a pointer to an SSL_METHOD structure, which is derived from the SSLv23_method_data_15784 variable. The contents of this variable are not visible in the code snippet."
openssl-101u,O0,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_mips_gcc_O0_extraction/SSL_SESSION_free.part.2@004ade34.c,"The function `SSL_SESSION_free_part_2` frees the memory allocated for an SSL session. It takes a pointer to the session as an argument (`param_1`) and uses `CRYPTO_free_ex_data` to free any extended data associated with the session. It then uses `OPENSSL_cleanse` to clear the memory at various offsets within the session to remove any sensitive information. The function checks various fields within the session to see if they are non-zero, and if they are, it calls other functions to free the memory associated with those fields, including a certificate chain (`ssl_sess_cert_free`) and an X509 certificate (`PTR_X509_free_006a6e90`)."
openssl-101u,O0,mips,start_hash,./data/decomp/openssl-101u_mips_gcc_O0_extraction/start_hash@0061f4c8.c,"The function takes a pointer to an array of four 32-bit integers as its parameter. If the third element of the array is not equal to zero, the function clears the next 32 bytes and the following 32 bytes using the memset function. It also sets the third element of the array to zero, and the first and second elements of the array to zero. Finally, it returns 1. If the third element of the array is zero, the function returns 0."
openssl-101u,O0,mips,surewarehk_finish,./data/decomp/openssl-101u_mips_gcc_O0_extraction/surewarehk_finish@005d5b74.c,"The surewarehk_finish() function releases resources associated with SureWare cryptographic hardware. If surewarehk_dso is equal to 0, an error message is generated and the function returns 0. Otherwise, p_surewarehk_Finish() is called to release resources. If DSO_free() fails, an error message is generated and the function returns 0. Otherwise, the function returns 1. The function also frees the logstream variable and sets all SureWare function pointers to 0 to indicate successful unloading of the library."
openssl-101u,O0,mips,sv_body,./data/decomp/openssl-101u_mips_gcc_O0_extraction/sv_body@00443438.c,"These functions all handle SSL/TLS connections and/or HTTP requests. They initialize variables and structures related to SSL/TLS encryption, set various SSL/TLS options, and handle incoming data from clients. They can also handle SRP authentication and provide diagnostic and debugging information. Some of the functions are specific to the s_server command in OpenSSL, while others are part of a larger program that uses SSL/TLS encryption to establish secure communication between a client and a server. The functions can send responses to clients and handle various HTTP request methods."
openssl-101u,O0,mips,TLSv1_method,./data/decomp/openssl-101u_mips_gcc_O0_extraction/TLSv1_method@004913b0.c,"The TLSv1_method function returns a pointer to an SSL_METHOD structure representing the TLSv1 protocol. The SSL_METHOD structure is stored in the variable TLSv1_method_data_15790. The function does not take any parameters, and the visibility or accessibility of its parameters in the decompiled code is locked. The calling convention of the function is unknown."
openssl-101u,O0,mips,__do_global_ctors_aux,./data/decomp/openssl-101u_mips_gcc_O0_extraction/__do_global_ctors_aux@00630f10.c,"The function executes global constructors by initializing two pointers and entering a loop to execute each constructor function pointed to by the constructor list until it encounters a value of -1, indicating the end of the list. It then returns from the function."
openssl-101u,O0,mips,__libc_csu_init,./data/decomp/openssl-101u_mips_gcc_O0_extraction/__libc_csu_init@00630e60.c,"The function __libc_csu_init() initializes the C runtime environment by calling a function pointed to by PTR__init_006a9920, which sets up the environment for the C program to run. This includes initializing global variables, allocating memory, and initializing the stack. The function then returns."
openssl-101u,O0,mips,__start,./data/decomp/openssl-101u_mips_gcc_O0_extraction/__start@00421520.c,"The __start function initializes local variables and calls the __libc_start_main function with the main function pointer, a local variable with value 0, a stack pointer, and a pointer to the __libc_csu_init function. An infinite loop follows the call to __libc_start_main."
openssl-101u,O0,mips,__udivdi3,./data/decomp/openssl-101u_mips_gcc_O0_extraction/__udivdi3@00630570.c,"The functions both perform division on 64-bit operands using bit operations. The first function takes four arguments, checks for a zero divisor, and performs long division using partial quotients and remainders. The second function takes four parameters, performs bit operations to calculate a quotient, and checks for a trap function before calculating the product. Both functions return a 64-bit unsigned integer quotient."
openssl-101u,O1,mips,aep_mod_exp.part.0,./data/decomp/openssl-101u_mips_gcc_O1_extraction/aep_mod_exp.part.0@005ccd6c.c,"These are summaries of four different functions that perform modular exponentiation using specialized hardware or algorithms. They all take in the base, exponent, and modulus as input parameters and return the result of the modular exponentiation operation. They also include error handling mechanisms to identify and handle errors during the computation. The functions differ in the specific hardware or algorithm used, as well as the error codes and messages returned."
openssl-101u,O1,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_mips_gcc_O1_extraction/asn1_bio_callback_ctrl@0062a2f0.c,"The `asn1_bio_callback_ctrl` function takes an integer argument `param_1`. If the value stored at the memory address `param_1 + 0x24` is not equal to zero, it jumps to an unknown function using a jumptable and returns the value returned by that function. If the value stored at the memory address `param_1 + 0x24` is equal to zero, it simply returns zero."
openssl-101u,O1,mips,asn1_bio_ctrl,./data/decomp/openssl-101u_mips_gcc_O1_extraction/asn1_bio_ctrl@0062a3e4.c,"The `asn1_bio_ctrl` function takes four parameters (`param_1`, `param_2`, `param_3`, and `param_4`). It retrieves a pointer to a data structure from `param_1` and returns 0 if the pointer is null. If `param_2` is 0x97, the function sets two fields in the data structure to values from `param_4` and returns 1. If `param_2` is less than 0x98 or greater than or equal to 0x98, the function handles additional cases related to setting and getting fields in the data structure. If `param_2` is 0xb, the function checks whether a certain field in the data structure is set and returns a value accordingly."
openssl-101u,O1,mips,asn1_bio_free,./data/decomp/openssl-101u_mips_gcc_O1_extraction/asn1_bio_free@0062a314.c,"The function takes an integer parameter and checks if the value stored at an offset of 0x20 from that integer is not equal to zero. If it is not zero, the function checks if the value stored at an offset of 4 from the retrieved value is also not equal to zero. If it is not zero, the function calls a function pointer stored at the address PTR_CRYPTO_free_006a6e88. Then, the function calls the same function pointer with the retrieved value as an argument. Finally, the function sets the values stored at offsets 0xc, 0x20, and 0x14 of the integer parameter to zero and returns 1. If the retrieved value is equal to zero, the function returns 0."
openssl-101u,O1,mips,asn1_bio_write.part.1,./data/decomp/openssl-101u_mips_gcc_O1_extraction/asn1_bio_write.part.1@0062a7fc.c,"The function takes in three parameters: an integer, a second integer, and a pointer to an unsigned integer. It returns an integer. The function first initializes some local variables and checks if the pointer at offset 0x20 of the first parameter is NULL. If it is, the function returns 0. Otherwise, it checks if the second parameter is non-zero, the third parameter is positive, and the value at offset 0x24 of the first parameter is non-zero. If all conditions are true, the function calls itself recursively. If the pointer at offset 0x20 of the first parameter is not NULL, the function checks the value at the pointer's location. If the value is less than 5, the function enters a switch statement that performs different actions based on the value. The cases include: - If the value is 0 or 4, the function writes data to the BIO object and updates the pointer's value accordingly. - If the value is 1."
openssl-101u,O1,mips,asn1_bio_write,./data/decomp/openssl-101u_mips_gcc_O1_extraction/asn1_bio_write@0062ab7c.c,"The function takes in three integer parameters: param_1, param_2, and param_3. It checks if param_2 is not equal to zero, param_3 is greater than -1, and the value at the memory address (param_1 + 0x24) is not equal to zero. If all these conditions are met, it calls another function asn1_bio_write_part_1() and returns its result. Otherwise, it returns 0. The purpose and implementation of asn1_bio_write_part_1() function are not provided in the given code snippet."
openssl-101u,O1,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BIO_asn1_get_suffix@0062ada0.c,"The function ""BIO_asn1_get_suffix"" takes in a BIO object, a pointer to a suffix, and a pointer to a suffix free variable. It initializes a local variable ""local_14"" to the value of the stack guard variable ""PTR___stack_chk_guard_006a9ae8"". The function calls the ""BIO_ctrl"" function with arguments ""b"" (the BIO object), 0x98 (a control command), 0 (a numerical argument), and a pointer to a local variable ""local_1c"". This function call returns an integer value ""iVar2"". If ""iVar2"" is greater than 0, the function sets the value of the pointer ""psuffix"" to the value of ""local_1c"" and the value of the pointer ""psuffix_free"" to the value of ""local_18"". Finally, the function checks if ""local_14"" is equal."
openssl-101u,O1,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BIO_asn1_set_prefix@0062ac2c.c,"The function sets the prefix for a BIO object using the BIO_ctrl function by calling it four times with different parameters. It takes in a BIO object, a prefix string, and a function pointer for freeing the prefix string. If the prefix is successfully set, the function returns the value returned by the last call to BIO_ctrl. If an error occurs, the function calls the __stack_chk_fail function to handle the error."
openssl-101u,O1,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_get0_nist_prime_224@0062ae4c.c,"The function returns a pointer to a constant BIGNUM value representing the NIST prime number for the elliptic curve P-224. The value is stored in a global variable named _bignum_nist_p_224. The function is marked with a warning that the calling convention is unknown, but the parameter storage is locked, suggesting that it is likely used internally by other functions within the same codebase and not intended to be called directly by external code."
openssl-101u,O1,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_get0_nist_prime_384@0062ae64.c,"The function returns a pointer to a BIGNUM object representing a prime number used in NIST P-384 elliptic curve cryptography. The prime number is stored in a static memory location named ""_bignum_nist_p_384"". The parameter storage is locked, and the function uses an unknown calling convention. It cannot modify its arguments."
openssl-101u,O1,mips,BN_GF2m_add,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_add@00623a34.c,"The function BN_GF2m_add takes three pointers to arrays of unsigned integers (uint) and returns an integer value. It performs a bitwise XOR operation between the second and third parameters and stores the result in the first parameter. The function updates the length of the first parameter array to remove any leading zeros. It checks if the length of the first parameter array is sufficient to hold the result before performing the XOR operation. If not, it expands the array using the BN_expand2 function. The function swaps the second and third parameters if the length of the third parameter is less than the length of the second parameter."
openssl-101u,O1,mips,BN_GF2m_mod,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod@00623cb4.c,"The functions BN_GF2m_mod and BN_GF2m_mod_arr_part_0 both take in four parameters and involve checking if certain parameters are null or equal to certain values before performing calculations and returning a result. The first function also initializes some variables and calls the error function if necessary, while the second function initializes a variable and expands the first parameter if necessary."
openssl-101u,O1,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_arr@00623bc0.c,"The function BN_GF2m_mod_arr takes in four parameters: param_1, param_2, param_3, and param_4. If the value pointed to by param_3 is 0, it sets the value of param_1 to 0 and returns 1. If param_1 is not equal to param_2, it expands param_1 if its size is less than that of param_2. It then copies the values of param_2 to param_1 and sets the length of param_1 to that of param_2. The function then calls BN_GF2m_mod_arr_part_0 with param_1 and param_3 as arguments and returns its result."
openssl-101u,O1,mips,BN_GF2m_mod_div,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_div@006258c4.c,"The function BN_GF2m_mod_div() takes in five parameters: param_1, param_2, param_3, param_4, and param_5. It initializes a BN_CTX object using param_5, obtains a new BN object using BN_CTX_get(), and calculates the inverse of param_1 in the Galois field GF(2^m) using BN_GF2m_mod_inv(). It also allocates memory to store a new array of integers and checks if the second integer in param_4 is zero. If it is, the function sets the return value to false and puts an error message in the error queue using ERR_put_error()."
openssl-101u,O1,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_div_arr@00625adc.c,"The function BN_GF2m_mod_div_arr() takes five parameters, including a pointer to an array of integers. It initializes and obtains a pointer to a new BN_CTX structure, sets the first parameter to zero, and sets corresponding bits in the first parameter to 1 if the first element of the array is not equal to -1. It then computes the inverse of the third parameter modulo the second parameter using BN_GF2m_mod_inv(). If the function returns 0 or if the value returned by BN_CTX_get() is zero, the function returns 0."
openssl-101u,O1,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_mul@00624cdc.c,"The function BN_GF2m_mod_mul performs a multiplication operation on two elements in the Galois Field GF(2^m), where m is a positive integer. It takes five parameters: param_1, param_2, and param_3 are input parameters representing two elements in the field and the irreducible polynomial defining the field; param_4 is a pointer to an array representing one of the two elements in the field; and param_5 is an input parameter representing a context for the operation. The function first calculates the number of bits required to represent the input element param_4 and allocates memory for an array of integers to store the bit positions of the non-zero coefficients of the input element. It then converts the input element into the array of bit positions and calls the function BN_GF2m_mod_mul_arr to perform the multiplication operation on the two input elements. If the multiplication operation is successful, the function returns the result; otherwise, it reports an error and returns."
openssl-101u,O1,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_mul_arr@00624144.c,"The first function performs multiplication of two polynomials in GF(2^m) field. It expands the output polynomial to the appropriate size and performs the multiplication using a lookup table and XOR operations. It then reduces the result modulo the irreducible polynomial and returns 1 if the result is not zero.

The second function performs various bitwise operations on input variables and pointers using a lookup table to generate new values.

The third function initializes some local variables, expands param_1 to the size of param_3 if they are not equal, and performs some calculations on the elements of param_2 and param_4.

The fourth function checks for NULL parameters and returns an error if any are found. It allocates memory for an array of integers and initializes it to zero. It loops through each bit of the binary representation of param_3 and sets the corresponding element in the array based on the current bit position. It then checks if the number of non-zero elements in the array is less than or equal to a certain value and sets the next element in the array to -1."
openssl-101u,O1,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_sqr@00624ed0.c,"The function BN_GF2m_mod_sqr performs modular squaring in a binary field. It takes four parameters: param_1, param_2, param_3, and param_4. param_3 is an array of integers representing the binary polynomial to be squared. The function first calculates the number of bits in the polynomial and allocates memory for a new array to store the result. Next, the function checks if the polynomial is zero. If it is, the result is also zero. If not, the function iterates over the bits of the polynomial and checks which ones are set. It then stores the positions of the set bits in the new array. After the positions of the set bits are determined, the function calls the BN_GF2m_mod_sqr_arr function to perform the actual modular squaring. The result is then returned. If there is an error during the execution of the function, an error message is printed and the function returns 0."
openssl-101u,O1,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_sqrt@006262f8.c,"The function BN_GF2m_mod_sqrt takes four parameters: param_1, param_2, param_3, and param_4. The first parameter, param_1, is a pointer to a BIGNUM structure that will be used to store the result of the square root operation. The second parameter, param_2, is a pointer to a BIGNUM structure that represents the input value that we want to find the square root of. The third parameter, param_3, is a pointer to an array of integers that represents the irreducible polynomial used in the Galois field GF(2^m) arithmetic. The fourth parameter, param_4, is a pointer to a BN_CTX structure that is used for temporary BIGNUM storage. The function first calculates the number of bits in the input BIGNUM using the BN_num_bits function, and then allocates an array of integers with enough space to store the indices of all the non-zero bits."
openssl-101u,O1,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_GF2m_mod_sqr_arr@00623ea0.c,"The function BN_GF2m_mod_sqr_arr() takes four parameters - a pointer to a pointer to an array of unsigned integers (param_1), a pointer to an array of integers (param_2), a pointer to an integer (param_3), and an undefined value (param_4). It initializes a BN_CTX object using the parameter param_4, checks if the pointer to the array of unsigned integers is null, computes the square of the input array of integers (param_2) and stores the result in the output array (param_1), reduces the result modulo a polynomial represented by the input integer (param_3), and returns true if the reduction is successful, and false otherwise. Finally, the function cleans up the BN_CTX."
openssl-101u,O1,mips,BN_kronecker,./data/decomp/openssl-101u_mips_gcc_O1_extraction/BN_kronecker@00622900.c,"The function BN_kronecker(a, b, ctx) computes the Kronecker symbol of two BIGNUMs a and b, using the BN_CTX context ctx. The Kronecker symbol is a generalization of the Legendre symbol to non-prime modulus. It returns -2 if there is an error and the Kronecker symbol otherwise. The function first initializes the BN_CTX context and copies the values of a and b into two uint pointers ppuVar3 and ppuVar4, respectively. If there is an error copying b, the function returns -2. Then, it checks if b is even or if a and b have a common factor greater than 1. If either of these conditions is true, the Kronecker symbol is 0. If b is odd and a and b are relatively prime, it proceeds to compute the Kronecker symbol using the binary algorithm. The binary algorithm repeatedly divides a and b by 2 until a becomes 1."
openssl-101u,O1,mips,by_dir_entry_free,./data/decomp/openssl-101u_mips_gcc_O1_extraction/by_dir_entry_free@00584cb0.c,"The function takes a pointer to an integer array as a parameter. It checks if the first element of the array is not equal to 0 and frees the memory allocated to that element using a function at address PTR_CRYPTO_free_006a6e88. It also checks if the third element of the array is not equal to 0 and frees the memory allocated to that element using a function at address PTR_sk_pop_free_006a7058 with the function by_dir_hash_free as a parameter. Finally, it frees the memory allocated to the entire array using the function at address PTR_CRYPTO_free_006a6e88 and returns."
openssl-101u,O1,mips,cswift_rand_bytes,./data/decomp/openssl-101u_mips_gcc_O1_extraction/cswift_rand_bytes@005cfaa0.c,"1. `cswift_rand_bytes`: Generates random bytes using the CryptoSwift library and returns a pointer to an undefined 4-byte value. Acquires an access context using `CSwift_AcquireAccContext` and sets `CSWIFT_lib_error_code` if an error occurs.

2. Diffie-Hellman Key Exchange: Computes a shared secret using the CryptoSwift library. Acquires an access context and attaches the private key. Performs a loop that generates random numbers, performs modular exponentiation, and sends the result to the remote party. Receives data from the remote party, decrypts it using the private key, and returns the shared secret. Sets an error code if any errors occur.

3. Decompiled Cryptographic Library: Acquires an access context using `CSwift_AcquireAccContext` and checks for errors. Attaches key parameters and performs a modular exponentiation operation using `cswift_mod_exp_mont`. Returns the result of the operation if there are no errors, sets `CSWIFT_lib_error_code` and returns null if there are errors.

4. `cswift_rsa_mod_exp`: Performs RSA modular exponentiation using the CryptoSwift library. Checks for valid context and RSA public key. Acquires an access context and uses it to perform the operation. Sets `CSWIFT_lib_error_code` and returns null if any errors occur.

5. Cryptographic Operations Wrapper: Initializes the CryptoSwift library and sets up parameters for the specific operation. Calls the appropriate function from the library to perform the operation and checks for errors. Sets the global error code and prints an error message if an error occurs. Cleans up any allocated memory and returns.

6. DSA Signing Algorithm: Initializes a BN_CTX object and checks if it was successfully created. Acquires an access context from the CSWIFT library and checks if it was successfully acquired. Generates random values for k and r using the CSWIFT library and computes s. Releases the access context and frees the BN_CTX object before returning the computed signature.

7. Decompiled HSM Program: Verifies a digital signature using the DSA algorithm. Initializes variables and retrieves parameters from the HSM. Calculates the length of the input message and performs memory allocations. Performs the DSA signature verification using the retrieved parameters and the input message. Sets an error code and returns null if there are errors.

8. RSA Encryption Algorithm: Initializes the CryptoSwift engine and sets up RSA encryption parameters using"
openssl-101u,O1,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_mips_gcc_O1_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061c2f0.c,"The function calls an unknown function using a function pointer that points to an address in memory containing the address of the actual function to be executed. Its purpose is likely related to converting ASN.1 data to a GOST client key exchange parameter format, but more context is needed to determine its exact purpose."
openssl-101u,O1,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_mips_gcc_O1_extraction/d2i_GOST_KEY_PARAMS@0061c230.c,"The function calls an unknown function through an indirect jump, located at the address pointed to by the global variable PTR_ASN1_item_d2i_006a8674. It converts a GOST key parameters structure from its ASN.1 DER encoding to its internal representation, but its exact behavior cannot be determined without knowing the contents of the function being called."
openssl-101u,O1,mips,decode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O1_extraction/decode_gost_algor_params@00618f2c.c,"The function `decode_gost_algor_params` decodes GOST key parameters and sets the type of the EVP_PKEY to GOST using `EVP_PKEY_set_type`. If decoding or filling the parameters fails, it sets an error using `ERR_GOST_error` and returns 0. If the algorithm is not GOST, it sets an error and returns 0. It then calls `X509_PUBKEY_get0_param`. 

The function `X509_PUBKEY_get0_param` converts a GOST key to an EVP_PKEY structure. It checks if the key length is valid and if the key is not null. Then, it sets the public key of the EC_KEY object to the newly created EC_POINT object. If this operation fails, it raises an error and frees the allocated memory. Finally, it checks if the EVP_PKEY object has the same base ID as the input key. If not, it raises an error. If they have the same base ID, it creates a new EC_KEY object and assigns it to the EVP_PKEY object. It then sets the group of the EC_KEY object."
openssl-101u,O1,mips,DES_xcbc_encrypt,./data/decomp/openssl-101u_mips_gcc_O1_extraction/DES_xcbc_encrypt@00621820.c,"These are all descriptions of functions that perform encryption or decryption operations. 

- `DES_xcbc_encrypt` implements the XCBC mode of encryption using the DES algorithm. It takes a plaintext message, length, key schedule, initialization vector, and two constant blocks as input. It encrypts or decrypts the message and processes it in blocks of 8 bytes. 
- The Blowfish encryption algorithm function takes in a plaintext message and a key, and outputs the ciphertext. It uses the Blowfish key schedule to expand the key and modifies the plaintext message in rounds. It also uses an initialization vector to ensure different ciphertexts for the same plaintext and key. 
- The AES encryption algorithm function takes in a plaintext input, a key, and an initialization vector (IV), and produces a ciphertext output. It expands the key using a key schedule and performs 10 rounds of encryption on the input using the expanded key and the IV. 
- The Blowfish OFB (output feedback) encryption algorithm function takes in a key, an initialization vector (IV), and a plaintext input, and returns the corresponding ciphertext output. It XORs each byte of the plaintext with the corresponding byte from the output buffer and encrypts the result using the Blowfish algorithm. 
- The OFB (Output Feedback) mode of operation encryption function takes in a key, an initialization vector (IV), a plaintext message, and the length of the message. It generates a keystream using the key and IV and XORs it with the plaintext to produce the ciphertext. 
- The last function performs encryption or decryption using a key and a message. It XORs each byte of the message with a corresponding byte from a buffer generated using the key, and handles padding if necessary. It also performs additional operations on the result and uses a cryptographic library (BN_CTX) to perform mathematical operations on the data."
openssl-101u,O1,mips,dgram_ctrl,./data/decomp/openssl-101u_mips_gcc_O1_extraction/dgram_ctrl@00529e10.c,"The three functions take in multiple parameters and perform different actions based on the values of those parameters. 

The function `dgram_ctrl` initializes variables and pointers, enters a switch statement based on `param_2`, and retrieves or sets values in the `param_1` structure based on the value of `param_2`. It also retrieves a short value from `param_4` and jumps to a label based on the value of `param_2`.

The second function takes in a socket descriptor, a command, a buffer, and the size of the buffer. It performs different actions based on the command given, such as calling system calls or performing bitwise operations on the buffer. It returns a success or failure value based on the outcome of the operation.

The third function takes in a BIO object, a buffer, the size of the buffer, and a variable pointer. It checks the type of the BIO object and performs different actions based on the type, such as copying the buffer into the BIO object's internal buffer or sending the buffer over a socket or SSL connection. It returns the size of the buffer, the number of bytes written, or the number of bytes sent, depending on the type of the BIO object. If the BIO object is of any other type, the function returns an error."
openssl-101u,O1,mips,dlfcn_bind_func,./data/decomp/openssl-101u_mips_gcc_O1_extraction/dlfcn_bind_func@0062947c.c,"The function takes in two parameters, param_1 and param_2. It first checks if either parameter is equal to 0, and if so, it sets two variables, uVar2 and uVar3, to specific values (0x43 and 0x109). If neither parameter is equal to 0, the function calls a function at the memory address stored in PTR_sk_num_006a6e2c, passing in the value stored at param_1 + 4 as an argument. The result is stored in the variable iVar1. If iVar1 is less than 1, the function sets uVar2 and uVar3 to different values (0x69 and 0x10d). If iVar1 is greater than or equal to 1, the function retrieves a value from the memory address stored at param_1 + 4 and calls another function at the memory address stored in PTR_sk_value_006a6e24, passing in the retrieved value as an argument."
openssl-101u,O1,mips,dlfcn_bind_var,./data/decomp/openssl-101u_mips_gcc_O1_extraction/dlfcn_bind_var@006295f0.c,"The function takes in two integer parameters, param_1 and param_2. If either parameter is equal to 0, it sets two local variables, uVar2 and uVar3, to specific values. If both parameters are not equal to 0, the function calls a function at the address stored in PTR_sk_num_006a6e2c, passing in the value stored at memory location (param_1 + 4) as an argument. The result of this function call is stored in the local variable iVar1. If iVar1 is less than 1, uVar2 and uVar3 are set to different specific values. Otherwise, the function retrieves the value stored at memory location (param_1 + 4) again and calls the function at the address stored in PTR_sk_num_006a6e2c, passing in the retrieved value as an argument. The result of this second function call is stored in iVar."
openssl-101u,O1,mips,dlfcn_globallookup,./data/decomp/openssl-101u_mips_gcc_O1_extraction/dlfcn_globallookup@00629030.c,"The function takes in a single parameter, an undefined 4-byte value, and returns an undefined 4-byte value. It first calls the `dlopen` function using the address stored in `PTR_dlopen_006a9abc`. If `dlopen` succeeds, it then calls the `dlsym` function using the address stored in `PTR_dlsym_006a9a0c`. After `dlsym` returns (whether successful or not), the function calls the `dl`. If `dlopen` fails, the function returns 0. If `dlsym` fails, it returns 0."
openssl-101u,O1,mips,doapr_outch.constprop.0,./data/decomp/openssl-101u_mips_gcc_O1_extraction/doapr_outch.constprop.0@00524768.c,"The function takes four parameters: two pointers to integers (param_1 and param_2) and two pointers to unsigned integers (param_3 and param_4). It returns an undefined value. The function first assigns the values of param_3 and param_4 to variables uVar3 and uVar1, respectively. If param_2 is not null and uVar3 is equal to uVar1, the function sets uVar1 to uVar3 + 0x400. If uVar3 is greater than 0x7ffffbff, the function returns 0. Otherwise, the function checks the value of the integer pointed to by param_2. If it is 0, the function allocates a block of memory of size uVar1 using the function pointed to by PTR_CRYPTO_malloc_006a7008 and assigns the result to iVar2. If the allocation fails (iVar2 is 0), the function returns 0. Otherwise, the function copies."
openssl-101u,O1,mips,dtls1_link_min_mtu,./data/decomp/openssl-101u_mips_gcc_O1_extraction/dtls1_link_min_mtu@004a4df8.c,"The function returns a constant value of 256 in decimal or 0x100 in hexadecimal, which represents the minimum MTU size for a DTLS link."
openssl-101u,O1,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_mont_field_encode@0062730c.c,"The function takes four parameters: param_1, param_2, param_3, and param_4. param_1 is an integer used to access memory, while param_2 and param_3 are integers passed as arguments to a function at a specific memory location. param_4 is an integer used as an argument in the function called in the function. The function checks if a specific integer value (iVar1) located at an offset of 0xa0 from param_1 is not equal to zero. If iVar1 is not zero, the function calls another function located at a specific memory location with param_2, param_3, iVar1 + 4, iVar1, and param_4 as arguments and returns the result. If iVar1 is zero, the function calls another function located at a specific memory location with error codes and a file name and line number."
openssl-101u,O1,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_mont_field_sqr@00627294.c,"The function `ec_GFp_mont_field_sqr` takes four parameters and checks the value at memory location `param_1 + 0xa0`. If it is not zero, it calls another function with parameters and returns the result. If it is zero, it calls another function with different parameters."
openssl-101u,O1,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_mont_group_init@00626d80.c,"The function initializes a Montgomery curve group on an elliptic curve over a finite field by calling ec_GFp_simple_group_init() to initialize a simple elliptic curve group. It sets two variables to zero, likely for storing parameters specific to the Montgomery curve, before returning."
openssl-101u,O1,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_nist_field_mul@0062772c.c,"The function takes in five integer parameters and checks for zero values in the first four parameters. If any are zero, it calls an error message function and exits. If the fifth parameter is zero, it creates a new BN_CTX object and multiplies two of the parameters together using BN_mul. It then squares the result using a function pointer and returns a boolean value indicating success or failure. If the fifth parameter is not zero, it skips the BN_CTX object creation and simply multiplies and squares the parameters before returning a boolean value indicating success or failure."
openssl-101u,O1,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_nist_group_copy@00627470.c,"The function `ec_GFp_nist_group_copy` copies the `order` field from one `EC_GROUP` structure to another and then calls `ec_GFp_simple_group_copy` to copy the remaining fields. It takes in two parameters, `param_1` and `param_2`, which are pointers to `EC_GROUP` structures."
openssl-101u,O1,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_nist_group_set_curve@00627488.c,"The function `ec_GFp_nist_group_set_curve` takes in four parameters (`param_1`, `param_2`, `param_3`, `param_4`) and an optional fifth parameter (`param_5`). It checks if `param_5` is equal to 0 and allocates memory for a new `BN_CTX` object if necessary. The function then starts the `BN_CTX` object and gets a new `BIGNUM` object. If the `BIGNUM` object is not successfully allocated, the function frees the memory."
openssl-101u,O1,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062d680.c,"The function takes six parameters, five integers and a pointer to an elliptic curve structure. It returns a boolean value indicating whether or not it was able to successfully compute the J-projective coordinates of a point on the curve. If the curve structure has not been initialized, the function checks if the three integer parameters (representing x, y, and z coordinates of a point on the curve) are non-zero and copies them into the corresponding fields of the curve structure. If the fourth parameter (representing the J-projective coordinate of the point) is non-zero, it is also copied into the curve structure. If the curve structure has been initialized, the function first checks if the sixth parameter (a pointer to a BN_CTX structure) is non-zero. If it is null, the function creates a new BN_CTX structure and assigns its value to the sixth parameter. Next, the function calls the appropriate function pointer (stored in the curve structure) to compute the J-projective coordinates of the point on the curve."
openssl-101u,O1,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_group_check_discriminant@0062d86c.c,"The function takes in an integer array and an integer and returns a boolean value. It initializes a new BN_CTX object using a function pointer and assigns it to the second parameter if the second parameter is equal to 0. It calls BN_CTX_start() to allocate memory for several integer variables. If the value of iVar5 is not equal to 0, the function proceeds to calculate the discriminant of the elliptic curve represented by the integer array param_1. If the function pointer at offset 0x94 of the first element of param_1 is NULL, the function copies the values from the appropriate indices of param_1 into iVar1 and iVar2 using BN_copy(). If the copy operations succeed, the function proceeds."
openssl-101u,O1,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_group_clear_finish@0062d184.c,"The function frees memory allocated for variables within an elliptic curve group context, including the generator point `G`, the order `order`, and the cofactor `cofactor`. Function pointers are used to call memory clearing and freeing functions. The parameter `param_1` is an integer."
openssl-101u,O1,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_group_copy@0062e6d4.c,"The function copies data from one instance to another instance of a simple elliptic curve group in GF(p) used in cryptography. It takes two integer parameters representing the instances and copies three large integers and a single 4-byte integer from the second instance to the first instance. If the copy is successful, the function returns 1, otherwise it returns 0."
openssl-101u,O1,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_group_get_degree@0062d234.c,The function takes an integer parameter and adds 0x48 to it. It then calls a function through a pointer with the result of this addition as its argument. The called function is not shown in the decompiled code. The purpose of this function is to get the degree of a simple elliptic curve group over a finite field.
openssl-101u,O1,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_group_set_curve@0062e814.c,"The function ec_GFp_simple_group_set_curve sets the curve parameters for an elliptic curve group over a finite field GF(p). The function takes as input a pointer to an integer array param_1 containing the curve parameters, a pointer to a pointer param_2 to the prime p defining the field, and three additional parameters param_3, param_4, and param_5. The function first checks if the number of bits in the prime p is at least 3, if p is positive, and if p is odd. If any of these conditions are not met, an error is generated and the function returns 0. If param_5 is 0, the function creates a new BN_CTX object using the function PTR_BN_CTX_new_006a794c and initializes it using the function PTR_BN_CTX_start_006a8528. It then copies the prime p to the parameter array param_1 and sets the sign of the prime to be non-negative."
openssl-101u,O1,mips,ec_GFp_simple_invert,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_invert@0062f784.c,"The function takes two integer parameters and checks if a point on an elliptic curve is at infinity. If the point is not at infinity and a specific offset value is not zero, it performs a subtraction operation between two other offset values using a specific function. If either condition is not met, it returns 1. The overall purpose of the function is to invert a value on an elliptic curve."
openssl-101u,O1,mips,EC_GFp_simple_method,./data/decomp/openssl-101u_mips_gcc_O1_extraction/EC_GFp_simple_method@0063055c.c,"The function EC_GFp_simple_method returns a pointer to a structure of type EC_METHOD, with the specific structure being stored in the variable ret_6815. It is related to elliptic curve cryptography and may have been compiled with an unknown calling convention, which could cause issues when called from other parts of the code."
openssl-101u,O1,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_point_copy@0062e774.c,"This function copies the contents of one EC point to another. It takes two integer parameters, which are pointers to the two EC points. The function first copies the x-coordinate of the second point to the first point's x-coordinate and checks if the copy was successful. If it was, the function then copies the y-coordinate of the second point to the first point's y-coordinate and checks if the copy was successful. If that was also successful, the function then copies the z-coordinate of the second point to the first point's z-coordinate and checks if the copy was successful. If all three copies were successful, the function then copies the point type of the second point to the first."
openssl-101u,O1,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_point_finish@0062d130.c,The function ec_GFp_simple_point_finish takes an integer parameter and frees memory allocated to different parts of it using the function PTR_BN_free_006a701c.
openssl-101u,O1,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_point_get_affine_coordinates@0062db70.c,"The function takes five parameters, four integers and a pointer to a structure, and returns a boolean value indicating success or failure. It checks if the point is at infinity using a function pointer and returns false if it is. If the fifth parameter (a context variable) is not provided, the function creates a new one using a function pointer. If the context variable creation fails, the function returns false. The function then gets four integers from the context variable using function pointers and returns false if any of these integers is zero. If the point is not at infinity, the function checks if the point is a simple point and copies the first and second coordinates to the third and fourth parameters, respectively, if they are not null."
openssl-101u,O1,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O1_extraction/ec_GFp_simple_point_set_affine_coordinates@0062eb14.c,"The function takes in five parameters, two of which are pointers to EC_POINT objects. If the third and fourth parameters are non-zero, it calls two other functions to set the J-projective coordinates of the EC_POINT object specified by the first two parameters to the values specified by the third and fourth parameters. If either the third or fourth parameter is zero, it calls another function to put an error message and returns 0."
openssl-101u,O1,mips,encode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O1_extraction/encode_gost_algor_params@0061a624.c,"The functions are related to the GOST algorithm and involve encoding and key generation. 

- `encode_gost_algor_params`: encodes GOST algorithm parameters into a byte array by creating a `GOST_KEY_PARAMS` object, setting the appropriate parameters, and encoding it using `i2d_GOST_KEY_PARAMS`. It returns the byte array or NULL if an error occurs. 
- Key generation function: generates a random number, retrieves public and private keys, encodes the GOST algorithm parameters and keys using `encode_gost_algor_params`, and returns the generated keys and encoded parameters. 
- Key encoding function: encodes key parameters, creates a GOST algorithm identifier, uses it to create an EVP_PKEY object, encodes the private key, and returns the result. 
- GOST2001 key generation function: generates a public key from a private key by retrieving the group and public key, calculating the x and y coordinates of the public key, printing out the key information, and freeing the BN_CTX object. 
- `gost_ameth_new`: allocates memory for a new ""ASN1_METHOD"" structure, sets its fields, and sets it as the method for the GOST algorithm. It returns NULL if any errors occur."
openssl-101u,O1,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_mips_gcc_O1_extraction/general_allocate_boolean.constprop.5@005b096c.c,"The function takes in eight parameters: three integers, a character pointer, and four more integers. It first checks if the fourth parameter (a character pointer) is null. If it is, the function returns an error code. If the fourth parameter is not null, the function checks if the fifth parameter (an integer) is not zero. If it is zero, the function returns an error code. If the fifth parameter is not zero, the function checks each character in the string pointed to by the fourth parameter to see if it matches any of the characters in a certain set. If a character in the string does not match any of the characters in the set, the function returns an error code. If all of the above checks pass, the function allocates memory for an integer array of size 8 using the function PTR_CRYPTO_malloc_006a7008. If the allocation fails, the function returns an error code."
openssl-101u,O1,mips,get_gost_engine_param,./data/decomp/openssl-101u_mips_gcc_O1_extraction/get_gost_engine_param@0061e458.c,"This function takes an integer parameter and returns an integer value. If the parameter is 0, it checks if the global variable 'gost_params' is already set. If it is, the function returns the value of 'gost_params'. If 'gost_params' is not set, the function uses the getenv() function to get the value of the environment variable 'CRYPT_PARAMS'. If the value of 'CRYPT_PARAMS' is not null, the function copies the string to a new memory location using the strdup() function and sets 'gost_params' to the new memory location. Finally, the function returns the value of 'gost_params'. If the parameter is not 0, the function returns 0."
openssl-101u,O1,mips,gost2001_param_encode,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost2001_param_encode@006196e8.c,"The ""gost2001_param_encode"" function encodes a GOST 2001 parameter into an ASN.1 object using two parameters of type ""undefined4"". It retrieves a pointer to an EVP_PKEY object and an EC_KEY object associated with it using functions at memory addresses ""PTR_EVP_PKEY_get0_006a95d8"" and ""PTR_EC_KEY_get0_group_006a7690"" respectively. The function then retrieves the curve name associated with the EC_KEY object using the function at memory address ""PTR_EC_GROUP_get_curve_name_006a7f7c"" and an ASN.1 object identifier (OID) for the curve name using the function at memory address ""PTR_OBJ_nid2obj_006a7140""."
openssl-101u,O1,mips,gost_cipher_cleanup,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost_cipher_cleanup@0061c5f0.c,"The function takes an integer parameter (param_1) and uses it to access a specific memory location. It then calls the gost_destroy function on a value located at an offset of 0xc from the memory location accessed by param_1 + 0x60, likely a reference to a GOST cipher object that needs to be destroyed and cleaned up. The function sets the value at an offset of 0x54 from the memory location accessed by param_1 to 0, indicating that the cleanup operation was successful. Finally, the function returns a value of 1, which may be used as an indication of success or completion."
openssl-101u,O1,mips,gost_cipher_ctl,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost_cipher_ctl@0061ce84.c,"The function gost_cipher_ctl takes four parameters, including two integers, an undefined 4-byte value, and a pointer to an undefined 4-byte value, and returns an undefined 4-byte value. It includes an if-else statement that checks the second parameter's value, and if it is equal to 6, it calls a code pointer with specific parameters. The result of this call is stored in a variable, and if it is less than 1, the function calls another function with specific parameters and sets a variable's value to 0xffffffff."
openssl-101u,O1,mips,gost_cipher_do_cnt,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost_cipher_do_cnt@0061c7ec.c,"The first function implements the GOST block cipher in CNT mode. It takes a key schedule, plaintext, and a buffer for ciphertext as input. It checks the counter value and initializes it if necessary. It XORs the next 8 bytes of plaintext with the corresponding bytes of the keystream generated by the key schedule. If the plaintext is shorter than 8 bytes, it XORs only the remaining bytes. If the plaintext is longer than 8 bytes, it generates additional keystream.

The second function takes four parameters: param_1, param_2, param_3, and param_4. param_1 is a pointer to some data structure in memory. param_2 is another pointer to a buffer in memory that will be filled with data. param_3 is a pointer to some other data structure in memory. param_4 is an integer that represents the size of param_2 buffer. It sets a local variable uVar3 to the value of a byte at the address param_1 + 0x30. It XORs the byte at param_1 + 0x30 with the byte at param_3[0] and stores the result in the first byte of param_2. It then checks if param_4 is less than or equal to uVar3 + 1. If so, it sets a value of 1 in a specific location in param_1."
openssl-101u,O1,mips,gost_cipher_init,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost_cipher_init@0061e0a8.c,"The function checks if the cipher has been initialized, retrieves the cipher algorithm to use, sets the cipher algorithm and key length, initializes the cipher context, sets the key in the cipher context if provided, copies the initialization vector (IV) to the context structure, copies the IV to another location in the context structure for feedback mode, and returns a value indicating success or failure."
openssl-101u,O1,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O1_extraction/GOST_CIPHER_PARAMS_new@0061c2c0.c,"The function creates a new instance of the GOST_CIPHER_PARAMS data structure using the ASN1_item_new function with the GOST_CIPHER_PARAMS_it parameter, and returns without any value."
openssl-101u,O1,mips,gost_imit_final,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost_imit_final@0061de10.c,"The function `gost_imit_final` takes an integer `param_1` and an undefined 4-byte value `param_2` as parameters. It retrieves the value of an integer `iVar4` from the memory location pointed to by `param_1` plus an offset of 0xC, and then retrieves the value of an integer `iVar3` from the memory location pointed to by `iVar4` plus an offset of 0x103C. If `iVar3` is equal to 0, the function calls `ERR_GOST_error` with error code 0x8C and error message ""gost_crypt.c"" at line 0x239 and then jumps to the end of the function. Otherwise, the function retrieves the value of an unsigned integer `unaff_s1` from the memory location pointed to by `iVar4` plus an offset of 0x1038."
openssl-101u,O1,mips,gost_imit_init_cpa,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost_imit_init_cpa@0061cdfc.c,"The function initializes parameters for the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A. It sets various values in memory and calls the `gost_init` function with the memory location, CryptoPro parameter set A, two other parameters, and a pointer to a global variable. It returns 1 to indicate success."
openssl-101u,O1,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O1_extraction/GOST_KEY_PARAMS_new@0061c260.c,"The function creates a new instance of the GOST_KEY_PARAMS structure using the ASN1_item_new function to generate a GOST key pair, and returns void."
openssl-101u,O1,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_mips_gcc_O1_extraction/GOST_KEY_TRANSPORT_free@0061c158.c,"The function takes in an undefined 4-byte parameter and calls a function at the address PTR_ASN1_item_free_006a8658, passing in the parameter and a constant value GOST_KEY_TRANSPORT_it. This function is likely used to free memory allocated to a GOST key transport object. The function does not return anything and may use a jump table, but it is not clear from this code snippet what that table does."
openssl-101u,O1,mips,gost_param_free,./data/decomp/openssl-101u_mips_gcc_O1_extraction/gost_param_free@0061e380.c,"The ""gost_param_free"" function checks if the global variable ""gost_params"" is not equal to zero, and if so, it frees the memory allocated for the GOST parameters using the ""CRYPTO_free"" function. The function then sets ""gost_params"" to zero and returns."
openssl-101u,O1,mips,hash_step,./data/decomp/openssl-101u_mips_gcc_O1_extraction/hash_step@0061e560.c,"The first function takes in three parameters, performs bitwise operations on the values pointed to by the second and third parameters, and passes the result to another function called gost_enc_with_key.

The second function takes in two parameters, performs various bitwise operations on the integers in these arrays, and stores the results in local variables.

The third function takes two arguments, performs a series of operations on the data using the GOST encryption algorithm with the provided key, and returns the result.

The fourth function is an implementation of the GOST encryption algorithm, which takes three parameters and performs several bitwise operations and XOR operations on the plaintext and the subkeys.

The fifth function initializes some local variables and pointers, checks input parameters, allocates memory using malloc(), initializes the allocated memory using the gost_init() function, and returns 1 if `param_1` is equal to the value stored at the address pointed to by `puVar4`, or if memory allocation fails. Otherwise, it returns 0."
openssl-101u,O1,mips,hwcrhk_init,./data/decomp/openssl-101u_mips_gcc_O1_extraction/hwcrhk_init@005d44b4.c,"The `hwcrhk_init` function initializes the `hwcrhk` library by loading necessary functions from `nfhwcrhk`. It returns without doing anything if the library has already been initialized. If the library fails to load or necessary functions cannot be found, an error is generated and the library is unloaded. The function sets up mutex callbacks if they are not disabled and initializes a global variable `hndidx_rsa` to hold the handle for the RSA key."
openssl-101u,O1,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_mips_gcc_O1_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061c1e8.c,"The function i2d_GOST_KEY_AGREEMENT_INFO takes two parameters of type undefined4 and converts the GOST_KEY_AGREEMENT_INFO data structure into a DER-encoded format by calling a function with the two parameters and a third parameter GOST_KEY_AGREEMENT_INFO_it, whose address is stored in the global pointer PTR_ASN1_item_i2d_006a8678. The function then returns."
openssl-101u,O1,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_mips_gcc_O1_extraction/i2d_GOST_KEY_TRANSPORT@0061c128.c,"The i2d_GOST_KEY_TRANSPORT function takes in two undefined4 parameters, calls an external function using a pointer to that function, passes in the two parameters and a third parameter (GOST_KEY_TRANSPORT_it), and returns the converted data (which is assumed to be in DER-encoded format)."
openssl-101u,O1,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101u_mips_gcc_O1_extraction/load_pkcs12.constprop.4@00459d08.c,"The function takes in a file pointer, a password callback function, and other arguments related to PKCS12 file loading and parsing. It attempts to load the PKCS12 file using the d2i_PKCS12_bio function and checks if the loading was successful. If not, it prints an error message and returns 0. If the loading is successful, it checks if the PKCS12 file's MAC is valid by calling the PKCS12_verify_mac function with an empty password string and then with a password obtained from the password callback function (if provided). If the MAC is not valid, it prints an error message and returns 0. If the MAC is valid, it calls the PKCS12_parse function with the provided password and other arguments to parse the PKCS12 file. It then frees the loaded PKCS12 file. If an error occurred during the parsing or MAC verification, it returns 0. Otherwise, it returns a value indicating the success of the function."
openssl-101u,O1,mips,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_mips_gcc_O1_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@004efe10.c,"The function takes in a BIGNUM pointer, an integer, a uint pointer, and two uints as parameters. It checks if the BIGNUM's dmax is less than the integer parameter and if it is, it expands the BIGNUM using bn_expand2 function. If the expansion fails, the function returns 0. The function then sets a uint variable uVar8 to 1 shifted left by the last 5 bits of the fifth parameter. If the fifth parameter is less than 4, the function loops through each uint in the BIGNUM's d array up to the integer parameter. Within each loop iteration, the function sets a ulong variable puVar9 to the BIGNUM's d array and sets a ulong pointer puVar10 to puVar9. It then loops until uVar8 is less than 1 and sets a ulong pointer puVar11 to puVar10 plus 1, increments the uint pointer param_3 by uVar8, sets."
openssl-101u,O1,mips,param_copy_gost94,./data/decomp/openssl-101u_mips_gcc_O1_extraction/param_copy_gost94@00619b84.c,"The function takes two parameters of type undefined4 and calls several functions to obtain integer values. It checks if the base IDs of the parameters are equal and returns 0 with an error message if they are not. If the base IDs are equal, it checks if the first parameter is equal to 0 and returns 0 with an error message if it is. If the first parameter is not equal to 0, it checks if the second parameter is equal to 0 and creates a new DSA object if it is. It then copies the values of three integers from the first parameter to the corresponding integers in the second parameter using the BN_dup function. If the fourth integer in the second parameter is equal to 0, it calls the gost94_compute_public function. The function returns 1 if successful."
openssl-101u,O1,mips,param_print_gost01,./data/decomp/openssl-101u_mips_gcc_O1_extraction/param_print_gost01@0061a0f8.c,"The function takes in three parameters: param_1, param_2, and param_3, and returns an integer value. It first calls two functions using pointers: PTR_EVP_PKEY_get0_006a95d8 and PTR_EC_KEY_get0_group_006a7690, which return values stored in uVar1. It then calls PTR_EC_GROUP_get_curve_name_006a7f7c using uVar1 as a parameter, and stores the returned value in uVar1. The function then calls PTR_BIO_indent_006a86ac using param_1, param_3, and 0x80 as parameters, and stores the returned integer value in iVar2. If iVar2 is not equal to 0, the function calls two more functions using pointers."
openssl-101u,O1,mips,param_print_gost94,./data/decomp/openssl-101u_mips_gcc_O1_extraction/param_print_gost94@0061a1ac.c,"1. A function that takes three 4-byte parameters and returns a pointer to an integer. It handles the encoding of GOST parameters for a given key.
2. A low-level implementation of GOST parameter encoding, likely used in a larger program that deals with GOST encryption.
3. An implementation of the GOST R 34.10-2001 algorithm for key generation.
4. A function that performs cryptographic operations using the GOST algorithm.
5. A function responsible for printing information about a GOST key pair.
6. A function responsible for generating a GOST key pair."
openssl-101u,O1,mips,pkey_ctrl_gost,./data/decomp/openssl-101u_mips_gcc_O1_extraction/pkey_ctrl_gost@0061acd8.c,"The first function `pkey_ctrl_gost` takes in four parameters and performs different actions based on the value of `param_2`. It is likely responsible for encoding and decoding data using the GOST algorithm.

The second function is a part of a larger program involving cryptography. It includes several conditional statements and error handling measures to ensure that the cryptographic operations are performed correctly and securely.

The third function is responsible for printing out the details of a GOST public key, including the X and Y coordinates and the parameter set used for the key generation. It retrieves the EC_KEY object associated with the GOST public key and uses the EC_POINT_get_affine_coordinates_GFp function to retrieve the X and Y coordinates of the public key."
openssl-101u,O1,mips,pkey_free_gost94,./data/decomp/openssl-101u_mips_gcc_O1_extraction/pkey_free_gost94@0061a0d4.c,"The function takes an integer parameter called ""param_1"". It checks if the value stored in the memory location pointed to by ""param_1 + 0x14"" is not equal to zero. If it is not zero, it jumps to an unknown function using an indirect jump, likely to free up memory allocated for a DSA key. If the value stored in the memory location pointed to by ""param_1 + 0x14"" is zero, the function simply returns."
openssl-101u,O1,mips,priv_encode_gost,./data/decomp/openssl-101u_mips_gcc_O1_extraction/priv_encode_gost@0061b118.c,"The first function encodes a private key in GOST format by taking in a PKCS8_PRIV_KEY_INFO structure, an EVP_PKEY structure containing the private key, and a string for indentation. It gets the base id of the EVP_PKEY, uses OBJ_nid2obj to get the OID of the algorithm, and calls encode_gost_algor_params to encode the algorithm parameters. If the EVP_PKEY is an EC key, it gets the private key using EC_KEY_get0_private_key and converts it to an ASN1_INTEGER using BN_to_ASN.

The second function is a part of the OpenSSL library and prints the details of a GOST key pair by taking in an EVP_PKEY structure containing the GOST key pair and a BIO object for printing. It first checks if the input key pair is of the GOST type and returns 0 if not. If it is, it sets up a BN_CTX object, initializes some variables, and extracts the public key and parameters from the key pair. It then prints the public key and parameters to the BIO object using BN_print and prints the parameter set name using OBJ_nid2ln. If any error occurs during the process, it returns 0. Otherwise, it returns 1."
openssl-101u,O1,mips,pub_encode_gost94,./data/decomp/openssl-101u_mips_gcc_O1_extraction/pub_encode_gost94@0061af08.c,"The first function, `pub_encode_gost94`, encodes GOST algorithm parameters and returns an encoded key. It takes in two parameters, `param_1` and `param_2`, and initializes variables and calls functions to retrieve information about `param_2`. If the encoding is successful, it returns the encoded key. If not, it calls `priv_encode_gost` to encode the key privately and prints the encoded key using `priv_print_gost94`.

The second function takes an EVP_PKEY object as input and prints out information about the key, including the private key (if available), public key, and parameter set. It first checks if the key is of type EC and extracts the private key if it exists. It then prints out the private key value or ""<undefined>"" if it doesn't exist. Next, it checks if the key is using a specific parameter set and prints out the name of the set if it does. It then performs calculations on the public key and prints out its x and y coordinates. Finally, it prints out the name of the parameter set again. The function returns 1 if successful and 0 if there were any errors."
openssl-101u,O1,mips,pub_print_gost94,./data/decomp/openssl-101u_mips_gcc_O1_extraction/pub_print_gost94@0061a314.c,"These function summaries describe various operations related to cryptography using the GOST algorithm. The functions perform operations such as encryption and decryption using the GOST94 standard, processing various parameters and data structures related to GOST key operations, and printing out information about GOST keys and their public key and parameter sets. They often take in pointers to various data structures and perform operations such as encoding and decoding data structures, allocating and freeing memory, and performing error handling and reporting operations. Overall, the exact purpose of these functions is difficult to determine without more context."
openssl-101u,O1,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O1_extraction/RSA_padding_add_PKCS1_PSS@006284c8.c,"The first function, RSA_padding_add_PKCS1_PSS, adds padding to a message using the PKCS1-PSS standard. It takes in a RSA key, a message hash, a hash function, and a salt length as input. The function checks the hash length and sets the salt length if it is not provided. It then generates random bytes for the salt, initializes a hash context, and updates it with the message hash, salt, and padding bytes. Finally, it generates a mask for the message and applies it to the padded message, returning the resulting padded message.

The second function is performing some sort of encryption or decryption operation. It takes in several input parameters, including a message (EM), a local variable (local_4c), a pointer to some data (pbVar10), a length value (uVar3), and a hash value. The function first checks if a certain condition is met, and if not, it performs some operations on the message. It XORs certain bytes of the message with other bytes, and then continues to XOR more bytes in a loop until it has processed the entire message. It then checks if the length of the message is equal to a certain value, and if not, it XORs more bytes. Finally, it returns the length of the processed message. The exact purpose or algorithm of this function is difficult to determine without more context or information."
openssl-101u,O1,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O1_extraction/RSA_verify_PKCS1_PSS@00627a10.c,"These functions are used for RSA signature verification and implementation of the RSA-PSS signature scheme. The verification function takes in the RSA key, message hash, hash function used, signature to be verified, and length of the signature as input. It initializes an EVP_MD context, checks the signature length, extracts masked data and salt, performs MGF1 operation, checks padding bits, hashes message and salt, and compares the resulting hash with the extracted hash from the signature. The implementation function takes in the message to be signed, length of the message, RSA key pair, digest algorithm, and salt length as input parameters. It initializes an EVP_MD_CTX context, checks salt length, calculates hash of the message, sets up padding for RSA-PSS scheme, generates random salt, applies padding to hash and salt, and performs RSA encryption operation using private key."
openssl-101u,O1,mips,sha_block_data_order,./data/decomp/openssl-101u_mips_gcc_O1_extraction/sha_block_data_order@00620130.c,"These are function summaries for various implementations of the SHA-1 and SHA-256 cryptographic hash functions. The functions take in input data, process it in 512-bit blocks using bitwise operations, and output a fixed-size hash value. The SHA-1 implementation updates a set of five variables (A, B, C, D, E) for each block, while the SHA-256 implementation updates a set of eight variables. The specific operations performed include bitwise shifts, bitwise OR, bitwise AND, addition modulo 2^32, XOR, rotation, and substitution. The purpose and context of some of the functions are not provided in the code snippets."
openssl-101u,O1,mips,SHA_Final,./data/decomp/openssl-101u_mips_gcc_O1_extraction/SHA_Final@006215dc.c,"The function takes in a message digest and a SHA_CTX structure, adds padding to the message data, adds the total number of bits in the original message to the end of the last block, processes the message data in 512-bit blocks, and stores the final hash values in the message digest."
openssl-101u,O1,mips,srp_verify_server_param,./data/decomp/openssl-101u_mips_gcc_O1_extraction/srp_verify_server_param@004bb9ec.c,"The function takes in two parameters - an integer and a pointer to an undefined 4-byte variable. It compares two values in memory using a function located at PTR_BN_ucmp_006a7fb4. If the result of the comparison is greater than or equal to -1, then the function sets the value at the memory location pointed to by the second parameter to 0x2f and returns 0. If the comparison result is less than -1, the function proceeds to calculate the number of bits in another value in memory using a function located at PTR_BN_num_bits_006a71f4. If the number of bits is less than a value located at an offset of 0x1cc from the first parameter, the function sets the value at the memory location pointed to by the second parameter to 0x47 and returns 0. If the number of bits is greater than or equal to the value at the offset."
openssl-101u,O1,mips,SSLv23_method,./data/decomp/openssl-101u_mips_gcc_O1_extraction/SSLv23_method@0048f230.c,"The SSLv23_method function returns a pointer to an SSL_METHOD structure, which implements SSL/TLS communication and establishes a secure connection using the SSLv23 protocol. However, the warning message indicates that this function may not follow a standard calling convention, potentially causing issues for other parts of the program that use it."
openssl-101u,O1,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_mips_gcc_O1_extraction/SSL_SESSION_free.part.2@004ade34.c,"The function performs various tasks including freeing custom data associated with the SSL_SESSION object, clearing sensitive data stored in memory, freeing any SSL session certificate, X509 certificate, and stack of SSL session certificates associated with the SSL_SESSION object, freeing any memory allocated for session ID, master key, and session ticket, clearing the entire SSL_SESSION object, and freeing the SSL_SESSION object itself."
openssl-101u,O1,mips,start_hash,./data/decomp/openssl-101u_mips_gcc_O1_extraction/start_hash@0061f4c8.c,"The function takes a pointer to an array of 4 undefined 4-byte integers as input. It checks if the value of the third integer in the array is not equal to zero. If it is not equal to zero, it sets the values of the 4th and 5th integers in the array to zero using the memset function. It also sets the value of the 3rd integer in the array to zero, as well as the values of the 1st and 2nd integers in the array. Finally, it returns a value of 1. If the value of the third integer in the array is equal to zero, it simply returns a value of 0."
openssl-101u,O1,mips,surewarehk_finish,./data/decomp/openssl-101u_mips_gcc_O1_extraction/surewarehk_finish@005d5b74.c,"The function checks if the surewarehk_dso variable is 0. If it is, it sets SUREWARE_lib_error_code to the next error code in the library and calls PTR_ERR_put_error to log the error. It returns 0. If surewarehk_dso is not 0, it calls p_surewarehk_Finish to finish using the SureWare library. It then calls PTR_DSO_free to free the SureWare library. If it fails, it sets SUREWARE_lib_error_code to the next error code in the library and calls PTR_ERR_put_error to log the error. If the library is freed successfully, it returns 1. If logstream is not 0, it calls PTR_BIO_free to free the logstream. Finally, it sets all function pointers to 0 and surewarehk_dso to 0. It returns the result of the function."
openssl-101u,O1,mips,sv_body,./data/decomp/openssl-101u_mips_gcc_O1_extraction/sv_body@00443438.c,"These function summaries describe various aspects of SSL/TLS connections using the OpenSSL library. They include setting up SSL contexts, accepting connections, reading and writing data, handling errors and debugging, and performing various operations on the connection. Some of the functions also include specific features like checking file paths, setting SRP parameters, and implementing a command-line interface for a SSL/TLS client program. Overall, these functions are part of larger programs that handle SSL connections and are responsible for managing the connection and handling various events and errors that may occur during the connection."
openssl-101u,O1,mips,TLSv1_method,./data/decomp/openssl-101u_mips_gcc_O1_extraction/TLSv1_method@004913b0.c,"The TLSv1_method function returns a pointer to a pre-defined data structure named TLSv1_method_data_15790. This structure contains information about the SSL/TLS protocol version, cipher suite, and other settings. The SSL_METHOD structure is defined elsewhere in the code."
openssl-101u,O1,mips,__do_global_ctors_aux,./data/decomp/openssl-101u_mips_gcc_O1_extraction/__do_global_ctors_aux@00630f10.c,"The function calls all global constructors in the program by iterating through the constructor list in reverse order until it reaches the end of the list. It checks if the constructor list is not empty by verifying that the address of the constructor list is not equal to 0xffffffff. Once all constructors have been called, the function returns."
openssl-101u,O1,mips,__libc_csu_init,./data/decomp/openssl-101u_mips_gcc_O1_extraction/__libc_csu_init@00630e60.c,The function __libc_csu_init initializes the C runtime environment by calling a function pointed to by PTR__init_006a9920. The code at this pointer is executed for initialization and the function returns.
openssl-101u,O1,mips,__start,./data/decomp/openssl-101u_mips_gcc_O1_extraction/__start@00421520.c,"The ""__start"" function initializes local variables and calls ""__libc_start_main"" to set up the program's environment and execute the main function located at ""PTR_main_006a6df8"". The program enters an infinite loop after the main function returns."
openssl-101u,O1,mips,__udivdi3,./data/decomp/openssl-101u_mips_gcc_O1_extraction/__udivdi3@00630570.c,"The function takes in four parameters, performs various bitwise operations, and computes uVar variables. It checks if the divisor is zero and calls a trap function if necessary. It then performs unsigned integer division using a modified long division algorithm, which involves estimating the quotient, subtracting multiples of the divisor, and repeating the process with the next pair of bits until the entire dividend has been processed. If the divisor is a power of two, a faster division algorithm using bit shifting is used. The function returns the quotient."
openssl-101u,O2,mips,aep_mod_exp.part.0,./data/decomp/openssl-101u_mips_gcc_O2_extraction/aep_mod_exp.part.0@005ccd6c.c,The functions all involve implementing modular exponentiation using the AEP library. They check the length of input parameters and use either a hardware accelerator or software implementation to perform the operation. They also handle errors and use connection tables to manage connections to the AEP device. One function dynamically loads the AEP library and sets pointers to its functions.
openssl-101u,O2,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_mips_gcc_O2_extraction/asn1_bio_callback_ctrl@0062a2f0.c,"This function is a callback implementation for OpenSSL's BIO system. It takes an integer parameter and returns an integer value. If the integer value stored at an offset of 0x24 from the input parameter is not zero, the function calls another function through a function pointer stored at a fixed address (0x006a8428), and returns the return value of this function call. If the integer value at the offset 0x24 is zero, the function simply returns 0."
openssl-101u,O2,mips,asn1_bio_ctrl,./data/decomp/openssl-101u_mips_gcc_O2_extraction/asn1_bio_ctrl@0062a3e4.c,"The function takes in four parameters: param_1 (a pointer to a BIO object), param_2 (an integer that determines the type of control operation to be performed on the BIO object), param_3 (an undefined value that is not used in this function), and param_4 (a pointer to an integer that is used to pass data in and out of the control operation).

The function first checks if the pointer to the BIO object is null. If it is, the function returns 0. If param_2 is equal to 0x97, the function sets the values of two elements in the BIO object's array to the values passed in through param_4 and returns 1. If param_2 is less than 0x98, the function checks if param_2 is equal to 0x95. If it is, the function sets the... (the rest of the summary is cut off)"
openssl-101u,O2,mips,asn1_bio_free,./data/decomp/openssl-101u_mips_gcc_O2_extraction/asn1_bio_free@0062a314.c,"The function takes an integer parameter and retrieves the value of an integer variable from an offset of 0x20. If the retrieved integer value is not equal to zero, it checks if the integer value stored at an offset of 4 from the retrieved integer value is also not equal to zero. If it is not equal to zero, it calls a function at the address pointed to by PTR_CRYPTO_free_006a6e88. Then, it calls the same function at the retrieved integer value and sets the values of three integer variables to zero. Finally, it returns 1 if the retrieved integer value was not equal to zero, otherwise it returns 0. The purpose of the function seems to be to free memory allocated for an ASN.1 BIO structure."
openssl-101u,O2,mips,asn1_bio_write.part.1,./data/decomp/openssl-101u_mips_gcc_O2_extraction/asn1_bio_write.part.1@0062a7fc.c,"The function takes three parameters: an integer, a second integer, and a pointer to an unsigned integer. Its purpose is to write ASN.1 data to a BIO object. It initializes variables and checks if the BIO object is null. If not, it checks for certain conditions and calls itself recursively. It then checks the value at the beginning of the BIO object's buffer and enters a loop that switches on the value of the buffer's first element. If the value is 0x62a898, the function calls ASN1_object_size to determine the size of the ASN.1 object and sets the value at offset 0."
openssl-101u,O2,mips,asn1_bio_write,./data/decomp/openssl-101u_mips_gcc_O2_extraction/asn1_bio_write@0062ab7c.c,"The function validates input parameters and calls ""asn1_bio_write_part_1"" if conditions are met, otherwise it returns 0. Validity conditions include param_2 not being zero, param_3 being greater than -1, and the value at the memory address specified by param_1 plus 0x24 not being zero."
openssl-101u,O2,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BIO_asn1_get_suffix@0062ada0.c,This function takes a BIO object and two pointers as input parameters. It calls the BIO_ctrl function with specific parameters and assigns the resulting values to the input pointers if the return value of BIO_ctrl is greater than 0. The function returns the return value of BIO_ctrl and includes stack checking code to prevent stack overflow vulnerabilities.
openssl-101u,O2,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BIO_asn1_set_prefix@0062ac2c.c,"The function BIO_asn1_set_prefix initializes variables, calls BIO_ctrl with different arguments, sets variables based on the return value, and returns the address of a constant (_bignum_nist_p_192). It takes a BIO pointer, a prefix pointer, and a prefix_free pointer as arguments."
openssl-101u,O2,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_get0_nist_prime_224@0062ae4c.c,"The function returns a pointer to a pre-defined constant value _bignum_nist_p_224, which represents a NIST prime number commonly used in cryptographic algorithms. The prime number has a value of 2^224 - 2^96 + 1. The warning message indicates that the calling convention for the function is unknown, which may cause issues when calling the function from other code."
openssl-101u,O2,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_get0_nist_prime_384@0062ae64.c,"This function returns a pointer to a constant BIGNUM type variable that contains the NIST prime number of 384 bits. The value of this prime number is stored in a private variable named ""_bignum_nist_p_384"". The calling convention used by this function is unknown and the parameter storage is locked."
openssl-101u,O2,mips,BN_GF2m_add,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_add@00623a34.c,"The function BN_GF2m_add takes in three parameters which are pointers to arrays of unsigned integers. It performs addition of two binary polynomials represented by the second and third parameters and stores the result in the first parameter. The function first checks which of the two binary polynomials has a higher degree and assigns the pointers accordingly. It then checks if the first parameter has enough space to store the result and expands it if necessary. The function then performs the addition of the two binary polynomials by XORing the corresponding coefficients and storing the result in the first parameter. Finally, the function removes any leading zeros from the result and returns 1 to indicate success."
openssl-101u,O2,mips,BN_GF2m_mod,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod@00623cb4.c,"The functions BN_GF2m_mod and BN_GF2m_mod_arr_part_0 perform modular reduction of an integer using a precomputed table. BN_GF2m_mod takes in four parameters: an integer pointer, an integer pointer, an integer pointer pointer, and a character pointer, and returns an unsigned integer. It first checks if the second parameter is NULL, and expands the memory allocated to the integer pointer if necessary. It then calls BN_GF2m_mod_arr_part_0 with the integer pointer as its argument. If the third parameter is not NULL, it computes the square of the integer using the precomputed table and updates the length of the integer.

The second function takes in four parameters: a pointer to a BIGNUM structure (ppuVar8), a pointer to another BIGNUM structure (ppuVar4), a pointer to an array of integers (param_3), and a pointer to a BN_CTX structure (param_4). It first checks if ppuVar4 is equal to NULL or if ppuVar4's value is 0. If either of these conditions is true, it sets ppuVar8's value to 0 and returns 0. If ppuVar8 is not equal to ppuVar4, the function checks if the number of words in ppuVar8 is less than the number of words in ppuVar4, and expands ppuVar8 to have the same number of words as ppuVar4. It then copies the value of ppuVar4 into ppuVar8."
openssl-101u,O2,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_arr@00623bc0.c,"The function takes in three integer arrays and an integer parameter. It checks if the third array is equal to zero, and if so, sets the first array to zero and returns 1. Otherwise, it expands the first array to be at least as large as the second array if they are not equal. It then calls the function BN_GF2m_mod_arr_part_0 with the first and third arrays as arguments, and returns the result of that function."
openssl-101u,O2,mips,BN_GF2m_mod_div,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_div@006258c4.c,"The function BN_GF2m_mod_div takes five parameters, including two undefined values, an integer value, a pointer to an integer value, and another undefined value. It initializes and allocates memory for a BN_CTX object, then calculates the inverse of the third parameter modulo the fourth parameter using BN_GF2m_mod_inv. If the inverse exists, it allocates memory for an integer array and proceeds with further operations. If the second integer in the fourth parameter is zero, the function sets a variable to false and jumps."
openssl-101u,O2,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_div_arr@00625adc.c,"The function BN_GF2m_mod_div_arr performs division of two binary polynomials over the field GF(2^m). It takes five parameters: param_1 and param_2 are pointers to the binary polynomials to be divided, param_3 is a pointer to the modulus polynomial, param_4 is a pointer to an array of integers representing the divisor polynomial, and param_5 is a pointer to a BN_CTX structure used for temporary storage. The function initializes a BN_CTX structure, creates a binary polynomial representing the divisor, computes the inverse of the divisor polynomial modulo the modulus polynomial using the BN_GF2m_mod_inv function, and returns a boolean value."
openssl-101u,O2,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_mul@00624cdc.c,"The function BN_GF2m_mod_mul performs modular multiplication of two elements in a finite field of characteristic 2 (GF(2^m)). It takes as input two integers in binary representation, a modulus (also in binary representation), and a pointer to an integer array where the result will be stored. The function first calculates the number of bits in the modulus and allocates memory for an integer array to store the positions of non-zero bits in the modulus. It then converts the modulus into a sparse representation by storing the positions of non-zero bits in the integer array. If the modulus is zero, the function returns 0. Otherwise, it performs modular multiplication of the two input integers using the sparse representation of the modulus and stores the result in the output integer array. If the result has more bits than the modulus, an error is generated and the function returns an error code. The function then frees the memory allocated for the sparse representation of the modulus and returns the result."
openssl-101u,O2,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_mul_arr@00624144.c,"The functions perform mathematical operations on polynomials in GF(2^m) field. 

The first function, BN_GF2m_mod_mul_arr, multiplies two polynomials represented as arrays of uints and stores the result in a third array. It checks if the second and third parameters are the same and allocates a new array for the result. It then reduces the result modulo a fourth parameter polynomial using BN_GF2m_mod_arr_part_0 function. If the second and third parameters are not the same, it allocates a new array for the result and initializes it to zero. It performs multiplication of the input polynomials using a bitwise XOR operation and reduces the result modulo the fourth parameter polynomial using BN_GF.

The second function takes in several parameters and performs a series of bitwise operations on them to generate a new unsigned integer value. It updates the values of some of its local variables based on the input parameters and the generated value. It then uses the updated values of local variables to generate another unsigned integer value and updates the value of another local variable based on this value. Finally, it updates the values of some of its local variables based on the updated values of uVar25.

The third function performs modular reduction of a binary polynomial represented as a big integer in GF(2^m) field. It checks if the dividend is zero and returns zero if it is. It checks if the divisor is a power of two and calculates the remainder accordingly. If the divisor is not a power of two, it performs the polynomial reduction using a modified version of the Montgomery reduction algorithm.

The fourth function is part of the OpenSSL library and is used for multiplication of two polynomials over the Galois field GF(2^m). It takes four parameters and checks if any of the input polynomials are NULL. It then allocates memory for an array of integers that will store the coefficients of the result polynomial. It calculates the product of the two input polynomials using a bitwise multiplication algorithm and checks if the degree of the result polynomial is less than or equal to the degree of the modulus polynomial."
openssl-101u,O2,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_sqr@00624ed0.c,"The function BN_GF2m_mod_sqr computes the square of a binary polynomial in GF(2^m) field. It calculates the number of bits required to represent the polynomial, allocates memory accordingly, and extracts the coefficients of the polynomial. If the polynomial is zero, it returns 0. Otherwise, it computes the square of the polynomial using the BN_GF2m_mod_sqr_arr function and returns the result. If the allocated memory is not sufficient, the function raises an error using the ERR_put_error function and returns the error code. Finally, it frees the allocated memory using the CRYPTO_free function."
openssl-101u,O2,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_sqrt@006262f8.c,"The function BN_GF2m_mod_sqrt calculates the square root of a binary polynomial modulo a given binary polynomial in GF(2^m) field. It takes four parameters: param_1 is a pointer to a BIGNUM structure where the result will be stored, param_2 is a pointer to a BIGNUM structure representing the input polynomial, param_3 is a pointer to an array of integers representing the modulus polynomial, and param_4 is a pointer to a BN_CTX structure for temporary storage. The function first calculates the number of bits in the input polynomial and allocates an array of integers to store the positions of the non-zero bits in the input polynomial. It then checks if the input polynomial is zero and returns 0 if it is. If the input polynomial is non-zero, the function sets the highest bit in the array of non-zero bit positions and calls BN_GF2m_mod_exp_arr to calculate the square root of the input polynomial modulo the modulus polynomial."
openssl-101u,O2,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_GF2m_mod_sqr_arr@00623ea0.c,"The function takes in four parameters: a pointer to a pointer to an array of unsigned integers (param_1), a pointer to an array of integers (param_2), a pointer to an integer (param_3), and an undefined value (param_4). The function initializes a context and allocates memory for a uint pointer. If the memory allocated is less than twice the value of the second element of param_2, it expands the memory. The function then squares each element of the array pointed to."
openssl-101u,O2,mips,BN_kronecker,./data/decomp/openssl-101u_mips_gcc_O2_extraction/BN_kronecker@00622900.c,"The BN_kronecker function calculates the Kronecker symbol of two BIGNUMs (large integers) a and b. It first initializes a BN_CTX and copies the values of a and b into two separate uint pointers (ppuVar3 and ppuVar4). If ppuVar4 is null, the function returns -2. Otherwise, it checks if b is odd and a is a quadratic residue or non-residue modulo b. If b is even, it returns 0. If b = 0, it returns 0. If b = 1, it returns 1."
openssl-101u,O2,mips,by_dir_entry_free,./data/decomp/openssl-101u_mips_gcc_O2_extraction/by_dir_entry_free@00584cb0.c,"The function takes in a pointer to an integer array as its parameter. It checks if the first and third elements of the array are not equal to zero. If they are not zero, it calls functions through function pointers to free the memory allocated to those elements. Finally, it calls a function through a function pointer to free the memory allocated to the entire array and returns. The function pointer used here is the same as the one used to free the first element of the array."
openssl-101u,O2,mips,cswift_rand_bytes,./data/decomp/openssl-101u_mips_gcc_O2_extraction/cswift_rand_bytes@005cfaa0.c,"1. The function `cswift_rand_bytes` generates random bytes using the CSwift cryptographic library. It acquires an access context and generates random bytes in chunks of 1024 bytes or less using the `CSwift_SimpleRequest` function. If an error occurs, it sets the global variable `CSWIFT_lib_error_code` to the error code and calls `ERR_put_error` to log the error. 
2. The function is a C implementation of the Diffie-Hellman key exchange using the CryptoSwift library. It checks if the library has been loaded, acquires an access context, attaches the public key, and performs a series of modular exponentiations to compute the shared secret key. If any errors occur, it sets an error code and returns NULL. 
3. The function is a decompiled version of a C program that uses the CSWIFT library to perform cryptographic operations. It initializes variables, acquires an access context, performs cryptographic operations, and handles errors. 
4. The function is a decompiled version of a function in the CryptoSwift library, which performs a modular exponentiation operation using the Montgomery method. It checks parameters, acquires an access context, performs the modular exponentiation, and releases the access context. If an error occurs, it sets a global error code and returns an error message. 
5. The function is part of a larger program that performs cryptographic operations. It calls a function at a specific memory address, performs calculations, and calls another function if a condition is met. 
6. The function is a wrapper for the CryptoSwift library, setting up parameters and calling appropriate functions to perform cryptographic operations. It checks if parameters are valid and if the encryption algorithm is supported by the library. If there are errors, it sets an error code and returns NULL. 
7. The function is a decompiled version of an implementation of the Digital Signature Algorithm (DSA) in the CSWIFT library. It initializes variables and structures, checks the DSA key pair, generates random values, and performs calculations to generate the digital signature for the message. 
8. The function is a decompiled version of a cryptographic function that verifies a Digital Signature Algorithm (DSA) signature. It initializes variables, checks the length of the signature, calls cryptographic functions to perform the DSA verification, and sets an error code if the verification fails or an error occurs. 
9. The function is a wrapper for performing cryptographic operations using the"
openssl-101u,O2,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_mips_gcc_O2_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061c2f0.c,The function calls an external function through a function pointer stored in PTR_ASN1_item_d2i_006a8674. The specific function being called is unknown as the jumptable at address 0x0061c300 could not be recovered. The function then exits without any additional processing.
openssl-101u,O2,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_mips_gcc_O2_extraction/d2i_GOST_KEY_PARAMS@0061c230.c,"The function calls an unknown function through a pointer retrieved using the macro PTR_ASN1_item_d2i_006a8674. It likely converts a GOST key parameter structure from its ASN.1 representation to an internal format, but the actual function being called is unknown."
openssl-101u,O2,mips,decode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O2_extraction/decode_gost_algor_params@00618f2c.c,"The first function, `decode_gost_algor_params`, takes in two parameters, initializes variables, retrieves algorithm parameters, checks their length, creates key parameters, sets them for `param_1`, decodes the public key from the parameters, and returns an error code if any errors are encountered.

The second function takes in an EVP_PKEY object and a BIO object, initializes variables, checks if the EVP_PKEY object is NULL, reads the public key from the BIO object, sets it as the public key for the EVP_PKEY object, and returns 0 or 1 depending on whether the public key was successfully set. If the public key cannot be read or set, an error message is printed."
openssl-101u,O2,mips,DES_xcbc_encrypt,./data/decomp/openssl-101u_mips_gcc_O2_extraction/DES_xcbc_encrypt@00621820.c,"1. `DES_xcbc_encrypt`: Implements XCBC encryption mode using DES algorithm. Processes plaintext block by block using XCBC encryption and writes resulting ciphertext block to output buffer. Handles remaining bytes that are not a multiple of 8.

2. AES encryption using CBC mode of operation: Generates key schedule based on input key using key expansion algorithm. Divides plaintext message into blocks of 128 bits and performs encryption on each block using CBC mode of operation. Uses loop to encrypt each block of plaintext message. XORs current plaintext block with IV or previous ciphertext block, encrypts result using AES algorithm with generated key schedule, updates IV to be resulting ciphertext block, and stores it in output buffer.

3. AES encryption algorithm: Uses key to generate set of round keys, performs series of rounds on plaintext block using IV as initial state. Each round consists of a number of operations, including substitution of bytes, shifting of rows, and mixing of columns. Final round omits column mixing step. Updates IV to be used for next block of plaintext.

4. Blowfish encryption or decryption operation: Initializes Blowfish key using provided key. Determines whether to encrypt or decrypt input buffer. Performs Blowfish OFB encryption or decryption operation on input buffer and stores result in output buffer. Uses loop to process input buffer in blocks of 8 bytes. Performs encryption/decryption operation using Blowfish.

5. OFB mode of operation: Initializes variables and performs calculations to generate keystream. Uses keystream to encrypt plaintext using OFB mode of operation. XORs keystream with plaintext to generate ciphertext. Includes error checking and stack protection measures.

6. Pointer to memory locations and integer values: Declares variables and initializes them with values from input parameters. Performs calculations on input values using various functions, including bitwise operations and modular arithmetic. Uses pointer to a function called ""encrypt"" to encrypt data in a loop. XORs each byte of data with corresponding byte from buffer, which is updated with output of encryption function. Checks if a certain condition is met and returns or calls another function if it is not. Uses context object to manage memory allocation and deallocation."
openssl-101u,O2,mips,dgram_ctrl,./data/decomp/openssl-101u_mips_gcc_O2_extraction/dgram_ctrl@00529e10.c,"Two functions are described:
1. `dgram_ctrl`: takes in four parameters and returns an `undefined4` value. It performs various socket operations based on the specified command code.
2. A function that takes in several parameters including a BIO object, a buffer pointer, a length, and a destination address. It checks the type of operation to be performed and performs the operation accordingly. It provides a layer of abstraction for performing I/O operations on a BIO object."
openssl-101u,O2,mips,dlfcn_bind_func,./data/decomp/openssl-101u_mips_gcc_O2_extraction/dlfcn_bind_func@0062947c.c,"The ""dlfcn_bind_func"" function takes two integer parameters, ""param_1"" and ""param_2"". It checks if either parameter is 0 and sets two variables accordingly. If both parameters are not 0, it calls a function at a specific address with ""param_1 + 4"" as its argument. The result is stored in ""iVar1"". If ""iVar1"" is less than 1, it sets two variables to different values. If ""iVar1"" is greater than or equal to 1, it retrieves the value stored at ""param_1 + 4"" and calls another function."
openssl-101u,O2,mips,dlfcn_bind_var,./data/decomp/openssl-101u_mips_gcc_O2_extraction/dlfcn_bind_var@006295f0.c,"The function `dlfcn_bind_var` takes two integer parameters, `param_1` and `param_2`. If either parameter is equal to 0, it sets error codes and returns 0. Otherwise, it calls a function at `PTR_sk_num_006a6e2c` with `param_1 + 4` as an argument and stores the result in `iVar1`. If `iVar1` is less than 1, it sets different error codes and returns 0. If `iVar1` is greater than or equal to 1, it retrieves the value at `param_1 + 4` and calls another function at `PTR_sk_value_006a6e24` with this value."
openssl-101u,O2,mips,dlfcn_globallookup,./data/decomp/openssl-101u_mips_gcc_O2_extraction/dlfcn_globallookup@00629030.c,"The function uses the dlfcn library to look up a symbol by name. It calls dlopen to open the dynamic library specified by the first argument, and dlsym to look up the symbol specified by the second argument. If the symbol is found, its address is returned. The function then calls dlclose to close the library handle. If any of these steps fail, the function returns 0."
openssl-101u,O2,mips,doapr_outch.constprop.0,./data/decomp/openssl-101u_mips_gcc_O2_extraction/doapr_outch.constprop.0@00524768.c,"The function takes four parameters: two pointers to integers, and two pointers to unsigned integers. It returns an undefined value. The function first assigns the values of the two unsigned integers to variables uVar1 and uVar3, respectively. If the second parameter (param_2) is not null and uVar3 is equal to uVar1, the function checks if uVar3 is greater than 0x7ffffbff. If it is, the function returns 0. If the value of the integer pointed to by param_2 is 0, the function allocates memory of size uVar1 using a function pointer to malloc (PTR_CRYPTO_malloc_006a7008) and assigns the returned pointer to the integer pointed to by param_2. If the allocation fails (i.e. the returned pointer is null), the function returns 0. If the value of uVar3 is not 0, the function copies the contents of the integer pointed to by param_1."
openssl-101u,O2,mips,dtls1_link_min_mtu,./data/decomp/openssl-101u_mips_gcc_O2_extraction/dtls1_link_min_mtu@004a4df8.c,"The function returns a constant value of 0x100, which is likely used as the minimum MTU size for the DTLS protocol link. DTLS is used for secure communication over unreliable network connections, and the minimum MTU size is important for efficient and reliable communication."
openssl-101u,O2,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_mont_field_encode@0062730c.c,"The function ec_GFp_mont_field_encode takes four parameters: param_1, param_2, param_3, and param_4. Param_1 is an integer that accesses a data structure with information about the elliptic curve. Param_2, param_3, and param_4 are undefined 4-byte values used in the computation. The function checks if a certain integer value stored in the data structure accessed by param_1 is not zero and calls a function pointed to by a global variable if it is not zero."
openssl-101u,O2,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_mont_field_sqr@00627294.c,"This function is used to square a field element in a Montgomery curve. It takes four parameters: a pointer to an elliptic curve parameter structure, two field elements to be squared, and a pointer to a buffer for the result of the squaring operation. The function checks if a specific field element in the elliptic curve parameter structure is non-zero. If it is non-zero, the function calls a function at a specific address, passing in the two field elements to be squared, the non-zero field element from the elliptic curve parameter structure, and a pointer to the buffer for the result. The result of this function call is then returned. If the specific field element in the elliptic curve parameter structure is zero, the function does not perform any operation."
openssl-101u,O2,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_mont_group_init@00626d80.c,"The function initializes a Montgomery elliptic curve group over a finite field of prime order by first calling the ec_GFp_simple_group_init() function to initialize a simple elliptic curve group. It then sets two variables to zero, likely used to store parameters specific to the Montgomery curve, before returning."
openssl-101u,O2,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_nist_field_mul@0062772c.c,"The function takes five integer parameters and checks if any of the first four parameters are equal to zero. If so, it calls a function to put an error message and returns false. If param_5 is equal to zero, it creates a new BN_CTX object and multiplies param_2 with param_3 and param_4 using BN_mul function. It then squares the result using a function pointer stored in param_1 + 0xa8 and returns true if the result is non-zero, false otherwise. If param_5 is not equal to zero, it multiplies param_2 with param_3 and param_4 using BN_mul function and squares the result using the same function pointer as before. It returns true if the result is non-zero, false otherwise."
openssl-101u,O2,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_nist_group_copy@00627470.c,`ec_GFp_nist_group_copy` copies the parameters of an elliptic curve group from one `EC_GROUP` structure to another by first copying the `field` member of the `EC_GROUP` structure pointed to by `param_2` to the `field` member of the `EC_GROUP` structure pointed to by `param_1`. Then it calls `ec_GFp_simple_group_copy` to copy the remaining members of the `EC_GROUP` structure from `param_2` to `param_1`.
openssl-101u,O2,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_nist_group_set_curve@00627488.c,"The function `ec_GFp_nist_group_set_curve` sets the curve parameters for a NIST elliptic curve group over a prime field. It takes four parameters: `param_1` is a pointer to a `EC_GROUP` structure that will store the curve parameters, `param_2`, `param_3`, and `param_4` are pointers to `BIGNUM` structures that represent the prime modulus, the curve coefficients, and the base point coordinates, respectively. `param_5` is an optional `BN_CTX` structure that can be used for temporary storage during the function. The function first checks if `param_5` is equal to zero. If it is, it allocates a new `BN_CTX` structure and initializes it. If it fails to allocate the new structure, it returns zero. If `param_5` is not zero, it assumes that it is already initialized and sets `iVar1` to zero. Next, the function compares the curve coefficients and base point coordinates to certain predefined values to ensure that they are valid for a NIST elliptic curve."
openssl-101u,O2,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062d680.c,"The function takes in six parameters: param_1, param_2, param_3, param_4, param_5, and param_6. The function first checks if a certain value in the memory pointed to by param_1 is equal to zero. If it is, then it checks if param_3 and param_4 are non-zero and copies their values to certain locations in memory. If param_5 is non-zero, it also copies its value to a certain location in memory. If all these operations are successful, the function returns true. If the value in memory pointed to by param_1 is not zero, the function creates a new BN_CTX object and assigns its pointer to param_6. Then, it calls a function at a certain location in memory pointed to by the value in memory pointed to by param_1 with various parameters to perform some calculations. If all these operations are successful, it returns true. Otherwise, it returns false."
openssl-101u,O2,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_group_check_discriminant@0062d86c.c,"The function takes in an integer array and an integer value and returns a boolean value. It checks if the second parameter is equal to 0 and allocates memory for a new integer value if it is. It initializes several integer variables using functions from a library. If the fifth integer in the first parameter array is not equal to 0, it checks if a certain function pointer in the first parameter array is null. If it is null, it copies two values from the first parameter array into two of the initialized integer variables. If it is not null, it calls the function pointed to by that pointer, passing in the first parameter array, the first initialized integer variable, the address of the 29th integer in the first parameter array, and the second parameter. If the function call succeeds, it does the same with the second initialized integer variable."
openssl-101u,O2,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_group_clear_finish@0062d184.c,"The function clears the memory associated with three pointers located at offsets from an integer parameter. The first pointer is cleared using a specific function, and the other two pointers are cleared using the same function with different offsets. The function then returns."
openssl-101u,O2,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_group_copy@0062e6d4.c,"The function takes two integer parameters that represent pointers to data structures of a specific format - an elliptic curve group in GF(p). It copies the values of three big integers and one small integer from the second data structure to the first data structure, field by field. If all copying operations are successful, the function returns 1; otherwise, it returns 0."
openssl-101u,O2,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_group_get_degree@0062d234.c,"The function takes an integer parameter (param_1), adds 0x48 to it, and calls a function at the address PTR_BN_num_bits_006a71f4 with the result as its argument. The function being called likely returns the number of bits in a BN object, but it is not defined in the decompiled code. The result of the function call is not used, and the function simply returns."
openssl-101u,O2,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_group_set_curve@0062e814.c,"The function `ec_GFp_simple_group_set_curve` takes in five arguments: an integer pointer `param_1`, a pointer to a pointer to an unsigned integer `param_2`, two unsigned integers `param_3` and `param_4`, and an integer `param_5`. The function checks if the number of bits in the input unsigned integer is less than 3 or if the integer is even. If either of these conditions is true, the function returns 0. If `param_5` is 0, the function initializes a new `BN_CTX` object and sets up two `BIGNUM` objects (`param_1 + 0x12` and `iVar2`) using the input unsigned integer. If `param_5` is not 0, the function uses the existing `BN_CTX` object and sets up the same `BIGNUM` objects. The function then sets the sign of `param_1 +`."
openssl-101u,O2,mips,ec_GFp_simple_invert,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_invert@0062f784.c,"The function takes two integer parameters, param_1 and param_2. It checks if a certain point on an elliptic curve is at infinity by calling a function at the address stored in PTR_EC_POINT_is_at_infinity_006a864c. If this point is not at infinity and a certain integer value stored at an offset of 0x1c from param_2 is not equal to zero, it calls a function at the address stored in PTR_BN_usub_006a85b0 to perform a subtraction operation on two large integers. Otherwise, it returns the value 1. The purpose of this function is likely to invert an element in a finite field."
openssl-101u,O2,mips,EC_GFp_simple_method,./data/decomp/openssl-101u_mips_gcc_O2_extraction/EC_GFp_simple_method@0063055c.c,"The function returns a pointer to an unspecified EC_METHOD structure stored in ""ret_6815"". The calling convention and parameter storage are unknown and locked, preventing modification by the caller."
openssl-101u,O2,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_point_copy@0062e774.c,"The function takes two integer parameters, the destination point and the source point. It copies the values of the source point to the destination point by calling BN_copy three times for the x, y, and z coordinates, and then copying the point type. It returns 1 if successful, otherwise 0."
openssl-101u,O2,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_point_finish@0062d130.c,"The ""ec_GFp_simple_point_finish"" function frees memory allocated for the x, y, and z coordinates of a point in an elliptic curve. It takes an integer argument and uses function pointers to call ""BN_free"" for memory deallocation."
openssl-101u,O2,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_point_get_affine_coordinates@0062db70.c,"The function takes in five parameters and returns a boolean value. It first checks if a point is at infinity using another function. If param_5 is 0, it allocates memory for it using another function and starts a BN_CTX. It then gets four variables using another function and sets iVar1 to param_5. If the fourth variable is 0, it sets bVar8 to false and ends the BN_CTX. If memory allocation fails, the function returns false."
openssl-101u,O2,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O2_extraction/ec_GFp_simple_point_set_affine_coordinates@0062eb14.c,"The function takes in five parameters: param_1, param_2, param_3, param_4, and param_5. It checks if param_3 and param_4 are both non-zero. If they are, it calls two other functions: a pointer to a code block that returns a value of 1 and a pointer to a code block that sets the J-projective coordinates of an EC point in GFp. The second function takes in six parameters: the first two are the EC point, the next two are the x and y coordinates in affine form, the fifth parameter is the value 1, and the last parameter is param_5. The function returns the value returned by the second function call."
openssl-101u,O2,mips,encode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O2_extraction/encode_gost_algor_params@0061a624.c,"The following functions all deal with GOST encryption and decryption using OpenSSL:

1. `encode_gost_algor_params`: Takes an integer pointer `param_1` as input and returns an integer pointer `piStack_a8`. The function creates a new `GOST_KEY_PARAMS` object and determines the key type and sets the appropriate values in the `GOST_KEY_PARAMS` object. It then encodes the `GOST_KEY_PARAMS` object and returns a pointer to the encoded data. Finally, the function frees the `GOST_KEY_PARAMS` object and returns the encoded data pointer.

2. `GOST_asymmetric_key_generation`: Takes in a pointer to a GOST key generation parameters structure and uses it to generate a GOST key pair. It retrieves the necessary parameters from the input structure and uses OpenSSL's GOST key generation method to generate a new key pair. If the key generation fails, it sets an error and returns NULL. If the key generation succeeds, it then performs some additional steps to encode the key pair into a format that can be stored or transmitted. Finally, it returns a pointer to the generated key pair. The function also includes some error handling code to handle cases where certain parameters are missing or invalid.

3. `GOST_key_management`: Takes in an `EVP_PKEY` object and determines the type of operation to be performed (encryption, decryption, key generation, or parameter encoding) based on the value of the ""op"" argument. If the operation is encryption or decryption, the function checks if a cipher context has already been created for the key. If not, it creates a new context and initializes it with the key and the specified parameters. It then calls the appropriate encryption or decryption function using the context to perform the operation. If the operation is key generation, the function generates a new key pair using the specified parameters and returns the public and private keys. If the operation is parameter encoding, the function encodes the parameters of the key into a binary format specified by the GOST algorithm and returns the encoded parameters. In all cases, the function returns an error.

4. `GOST_print_key`: Takes in a pointer to a GOST key pair and uses various OpenSSL functions to extract information about the private and public keys, as well as the parameter set used to generate the keys. It prints out information about the private key, including whether it is defined or not. If the key is an EC key, the function also prints"
openssl-101u,O2,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_mips_gcc_O2_extraction/general_allocate_boolean.constprop.5@005b096c.c,"The function takes in eight parameters: four integers, two character pointers, and two integer pointers. It returns an integer value. The function first checks if the fourth parameter, `param_4`, is null. If it is, the function sets an error code and returns -1. If it is not null, the function checks if the fifth parameter, `param_5`, is non-zero. If it is zero, the function sets an error code and returns -1. If `param_4` is not null and `param_5` is non-zero, the function iterates through the characters in `param_4` and checks if each character is a valid input character using a function pointed to by `PTR_strchr_006a9a28`. If any character is not valid, the function sets an error code and returns -1. If all input parameters are valid, the function checks if `param_2` is non-zero. If it is zero, the function."
openssl-101u,O2,mips,get_gost_engine_param,./data/decomp/openssl-101u_mips_gcc_O2_extraction/get_gost_engine_param@0061e458.c,"The function takes an integer parameter named ""param_1"". If the value of ""param_1"" is 0, it checks if the global variable ""gost_params"" is equal to 0. If ""gost_params"" is 0, it gets the value of the environment variable named ""CRYPT_PARAMS"" using the function ""getenv"" and stores it in the variable ""iVar1"". If ""iVar1"" is 0, it returns 0. Otherwise, it duplicates the string pointed to by ""iVar1"" using the function ""BUF_strdup"" and stores the result in ""gost_params"". Finally, it returns the value of ""gost_params"". If the value of ""param_1"" is not 0, the function returns 0."
openssl-101u,O2,mips,gost2001_param_encode,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost2001_param_encode@006196e8.c,"The function takes in two undefined parameters and performs a series of function calls using memory addresses to manipulate a variable called uVar1. These function calls include calling PTR_EVP_PKEY_get0_006a95d8, PTR_EC_KEY_get0_group_006a7690, PTR_EC_GROUP_get_curve_name_006a7f7c, and PTR_OBJ_nid2obj_006a7140."
openssl-101u,O2,mips,gost_cipher_cleanup,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost_cipher_cleanup@0061c5f0.c,"The function takes an integer parameter, likely a pointer to a GOST cipher data structure. It calls the `gost_destroy` function on a specific offset to free memory/resources, sets another offset to 0, and returns 1, indicating success or completion of the cleanup process."
openssl-101u,O2,mips,gost_cipher_ctl,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost_cipher_ctl@0061ce84.c,"The function gost_cipher_ctl takes four parameters: two integers, an undefined 4-byte value, and a pointer to an undefined 4-byte value. If the second parameter is equal to 6, the function calls another function with specific parameters and sets the return value based on the result. If the second parameter is equal to 7, the function checks if the fourth parameter is not null."
openssl-101u,O2,mips,gost_cipher_do_cnt,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost_cipher_do_cnt@0061c7ec.c,"The `gost_cipher_do_cnt` function is responsible for encrypting or decrypting data using the Counter (CTR) mode of operation in the GOST cipher algorithm implementation. It takes four arguments: `param_1` is a pointer to the cipher context, `param_2` is a pointer to the output buffer, `param_3` is a pointer to the input buffer, and `param_4` is the length of the data to be processed. The function checks if there are any bytes left from the previous block, XORs them with the first bytes of the input buffer, and updates the counters. Then, it processes the remaining data in blocks of 8 bytes using the CTR mode, XORing the counter value with the input data and storing the result in the output buffer. If there are any bytes left after processing the blocks, they are handled separately.

The second function takes four parameters: a pointer to a byte array (param_1), a pointer to another byte array (param_2), an integer value (param_4), and a pointer to a third byte array (param_3). The function initializes variables uVar3 and uVar2 and performs a series of XOR operations between the byte values in param_1 and param_3, storing the result in the corresponding index of param_2. After each XOR operation, the function checks if the value of param_4 is less than or equal to uVar3 plus the index of the current operation. If it is, the function sets the value of a variable at offset 0x50 in param_1 to the current index and returns 1. If the value of param_4 is greater than uVar3 plus the index of the current operation, the function continues with the next XOR operation until."
openssl-101u,O2,mips,gost_cipher_init,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost_cipher_init@0061e0a8.c,"The function initializes the GOST cipher by checking if it has already been initialized and setting the key and initialization vector if provided. It returns 1 if successful and 0 if there is an error. If the cipher has not been initialized, the function checks for the GOST engine parameter and uses the default GOST cipher algorithm if it is not set, or the algorithm specified by the parameter if it is set."
openssl-101u,O2,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O2_extraction/GOST_CIPHER_PARAMS_new@0061c2c0.c,"The function creates a new instance of the GOST_CIPHER_PARAMS data structure using the ASN1_item_new function, casting the function pointer to the correct type using typedef, and returning the newly created instance."
openssl-101u,O2,mips,gost_imit_final,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost_imit_final@0061de10.c,"The function `gost_imit_final` takes two parameters: an integer `param_1` and an undefined value `param_2`. It retrieves the value of the integer variable `iVar4` from memory at an offset of 0xc from `param_1`. It then retrieves the value of the integer variable `iVar3` from memory at an offset of 0x103c from `iVar4`. If `iVar3` is equal to 0, the function calls `ERR_GOST_error` and jumps to the label `LAB_0061de8c`. Otherwise, the function retrieves the value of the unsigned integer variable `unaff_s1` from memory at an offset of 0x1038 from `iVar4`. If the value of the integer variable at an offset of 0x1030 from `iVar4` is equal to 0 and `unaff_s1` is not equal to 0, the function initializes the value."
openssl-101u,O2,mips,gost_imit_init_cpa,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost_imit_init_cpa@0061cdfc.c,"The function initializes the GOST 28147-89 encryption algorithm with CryptoPro parameters by setting initial values in a context structure, calling the gost_init function with the context structure and other parameters, and returning 1 to indicate success. It takes four parameters, but only uses the first one."
openssl-101u,O2,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O2_extraction/GOST_KEY_PARAMS_new@0061c260.c,"The function creates a new instance of the GOST_KEY_PARAMS structure by calling the ASN1_item_new function with the GOST_KEY_PARAMS_it parameter, which creates a new instance of the GOST_KEY_PARAMS ASN.1 structure. The code pointer is dereferenced to call the function, and then the new instance is returned."
openssl-101u,O2,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_mips_gcc_O2_extraction/GOST_KEY_TRANSPORT_free@0061c158.c,The function GOST_KEY_TRANSPORT_free takes in an undefined4 parameter and calls a code pointer at the address PTR_ASN1_item_free_006a8658 with the parameter and a reference to the GOST_KEY_TRANSPORT_it structure to free memory allocated for the GOST_KEY_TRANSPORT object. The function then returns.
openssl-101u,O2,mips,gost_param_free,./data/decomp/openssl-101u_mips_gcc_O2_extraction/gost_param_free@0061e380.c,"The function checks if a global variable called ""gost_params"" is not equal to zero and frees the memory allocated for the ""gost_params"" structure if it is not zero. It sets the variable to zero and returns if ""gost_params"" is already zero. This function is likely used to free memory allocated for GOST parameters in OpenSSL."
openssl-101u,O2,mips,hash_step,./data/decomp/openssl-101u_mips_gcc_O2_extraction/hash_step@0061e560.c,"1. The function performs bitwise operations on input parameters and calls another function with the input parameters and local variables. It is difficult to understand without knowledge of the specific cryptographic algorithm being used.
2. The function performs bitwise operations on input parameters and uses memory manipulation functions. Its purpose and context are unclear without more information.
3. The function decrypts and encrypts data using the GOST cipher with a given key.
4. The function performs GOST encryption using a key and input data provided as parameters. It checks for a stack buffer overflow. 
5. The function initializes local variables and checks if a memory address contains a specific value. If not, it allocates memory and initializes it using the gost_init() function. It returns 1 in a specific condition."
openssl-101u,O2,mips,hwcrhk_init,./data/decomp/openssl-101u_mips_gcc_O2_extraction/hwcrhk_init@005d44b4.c,"The `hwcrhk_init` function initializes the `nfhwcrhk` hardware cryptographic library by loading it as a dynamic shared object and binding its functions. It also sets up mutex callbacks and creates a new index for the RSA key handle. The function returns 1 on success and 0 on failure, setting an error code. If the library is already loaded, it returns an error and frees the library before returning."
openssl-101u,O2,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_mips_gcc_O2_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061c1e8.c,"The function i2d_GOST_KEY_AGREEMENT_INFO takes two parameters of type undefined4 and does not return anything. The first parameter is likely a pointer to a GOST_KEY_AGREEMENT_INFO object, and the second parameter is the output buffer where the encoded object will be stored. The function calls a function pointer, which is likely pointing to the i2d function of the ASN1_item structure for GOST_KEY_AGREEMENT_INFO. The function pointer is obtained from the global variable PTR_ASN1_item_i2d_006a8678. The i2d function converts the GOST_KEY_AGREEMENT_INFO object to its DER encoded form and stores it in the output buffer."
openssl-101u,O2,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_mips_gcc_O2_extraction/i2d_GOST_KEY_TRANSPORT@0061c128.c,"The i2d_GOST_KEY_TRANSPORT function takes in two parameters of type undefined4 and converts a GOST_KEY_TRANSPORT object into its ASN.1 representation for transmission over a network. It calls a function using an indirect jump, determined at runtime and cannot be recovered from the decompiled code, which takes in the two parameters and a pointer to an ASN1_ITEM structure used in the encoding and decoding of ASN.1 data."
openssl-101u,O2,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101u_mips_gcc_O2_extraction/load_pkcs12.constprop.4@00459d08.c,"The function takes in a PKCS12 file pointer, a password callback function, and other arguments. It attempts to load the file using d2i_PKCS12_bio and verifies the MAC using PKCS12_verify_mac. If the MAC verification fails, it returns 0. If it succeeds, it parses the file using PKCS12_parse. If parsing fails, it returns 0. If parsing succeeds, it returns the type of certificate found in the file. The function also checks for stack overflow."
openssl-101u,O2,mips,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_mips_gcc_O2_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@004efe10.c,"The function takes input in the form of a BIGNUM structure, an integer representing the number of words in the BIGNUM, a pointer to an array of integers, the value to be copied into the BIGNUM, and the number of bits in each word. It then copies the input array into the BIGNUM structure, expanding the BIGNUM if necessary using the bn_expand2 function. The function iterates through each word in the input array and copies it into the BIGNUM, performing a simple copy if the number of bits in each word is less than 4, and a more complex copy involving bit-shifting and masking operations if the number of bits is 4 or greater. Finally, the function reduces the size of the BIGNUM by removing any leading zero words and returns."
openssl-101u,O2,mips,param_copy_gost94,./data/decomp/openssl-101u_mips_gcc_O2_extraction/param_copy_gost94@00619b84.c,"The function takes two parameters of type undefined4 and copies the values from one parameter to the other. It gets the internal representation of the two parameters and checks if their base ids match. If not, it raises an error and returns 0. If the base ids match, it checks if the second parameter is null. If it is, it creates a new DSA object and assigns it to the second parameter. Then, it copies the values of three big integers from the first parameter to the corresponding fields in the DSA object using BN_dup to avoid any memory conflicts. Finally, it computes the public key for the DSA object using the gost94_compute_public function and returns 1."
openssl-101u,O2,mips,param_print_gost01,./data/decomp/openssl-101u_mips_gcc_O2_extraction/param_print_gost01@0061a0f8.c,"The function takes in three parameters and prints out information about the elliptic curve used for encryption. It calls three functions using function pointers to get the curve name, and another function to indent the output. If successful, it calls another function to get the long name of the curve name and prints out the parameter set. It returns 1 if the indentation was successful and 0 otherwise."
openssl-101u,O2,mips,param_print_gost94,./data/decomp/openssl-101u_mips_gcc_O2_extraction/param_print_gost94@0061a1ac.c,"The following are summaries of functions related to GOST keys in the OpenSSL library:

1. The function takes three undefined 4-byte parameters and returns a pointer to an integer. It initializes variables, gets values from keys, enters loops, and prints messages to the console.

2. The function encodes and decodes GOST keys, checking their validity and encoding their parameters. It creates and encodes a GOST key parameter object before freeing it and returning the encoded GOST key parameter.

3. The function is part of OpenSSL's implementation of the GOST cryptographic algorithm. It encodes a public or private key using the GOST algorithm and sets an error message if necessary before returning a pointer to the encoded key data.

4. The function encodes GOST keys and algorithm parameters based on their type, checks for errors, and returns the encoded value.

5. The function prints the details of a GOST key pair, retrieving and printing the private and public keys, parameter set, and public key coordinates.

6. The function generates a GOST key pair by checking for a valid EVP_PKEY object and generating a random private key and corresponding public key. It then prints information about the key pair."
openssl-101u,O2,mips,pkey_ctrl_gost,./data/decomp/openssl-101u_mips_gcc_O2_extraction/pkey_ctrl_gost@0061acd8.c,"The function `pkey_ctrl_gost` takes four parameters and uses a switch statement to perform different actions based on the value of `param_2`. If `param_3` is 0, the function performs the specified action, otherwise it returns -2. The function uses various functions and variables, and appears to be part of some cryptographic software.

The function decodes and encodes data using the GOST algorithm. It initializes variables, calls external functions, and prints information about private and public keys and parameter sets. It returns an error code based on the success or failure of the operations performed.

The function checks if the input is a valid EVP_PKEY structure, gets the public key and EC_GROUP structure, calculates affine coordinates, and prints the public key and parameter set to a BIO object. If the input is not valid, an error message is printed and the function returns 0."
openssl-101u,O2,mips,pkey_free_gost94,./data/decomp/openssl-101u_mips_gcc_O2_extraction/pkey_free_gost94@0061a0d4.c,"The pkey_free_gost94 function takes an integer parameter and checks if the value stored at the memory address param_1+0x14 is not equal to zero. If it is not zero, it jumps to an unknown function pointed by PTR_DSA_free_006a7530 (which is an indirect jump). If it is zero, the function returns. This function is likely freeing some memory allocated for a GOST94 key."
openssl-101u,O2,mips,priv_encode_gost,./data/decomp/openssl-101u_mips_gcc_O2_extraction/priv_encode_gost@0061b118.c,"These functions both deal with the GOST algorithm and private/public keys. 

The first function encodes a private key using the GOST algorithm, sets the parameters, and prints out information about the keys. It also encodes the private key value as an ASN.1 INTEGER if it is an EC key.

The second function prints the details of a GOST algorithm public key in a human-readable format. It checks the validity of the input parameter and the algorithm, extracts necessary information, and prints it using the BN_CTX structure for temporary storage of BigNum values. If there is an error, it prints an error message and returns 0. Otherwise, it returns 1."
openssl-101u,O2,mips,pub_encode_gost94,./data/decomp/openssl-101u_mips_gcc_O2_extraction/pub_encode_gost94@0061af08.c,"Two functions are described. 

The first function, `pub_encode_gost94`, encodes a GOST 94 public key. It takes two parameters, `param_1` and `param_2`, which are integers representing the key and a pointer to the EVP_PKEY structure. The function first gets the algorithm parameters and encodes them using the `encode_gost_algor_params` function. It then calculates the size of the key and allocates memory for it. Next, it gets the base ID of the key and encodes the algorithm parameters again. If the base ID is `0x32b` (EC key), it gets the private key and prints it. If the base ID is `0x32c` (DH key), it prints ""<undefined>"". Finally, it frees the memory and returns the encoded key.

The second function takes an EVP_PKEY object as input and prints out information about the key, including the private and public keys, the parameter set used, and the curve name. First, it checks if the key is an EC key and if it has a private key. If so, it prints out the private key value. If not, it prints out ""<undefined>"". Next, it checks if the key is using the R3410 parameter set and if it has a public key. If so, it prints out the public key value. If not, it prints out ""<undefined>"". Then, it retrieves the parameter set used by the key and prints out its name. Finally, it uses the key to generate the public key coordinates and prints them out along with the parameter set name. If any errors occur during this process, the function returns 0. Otherwise, it returns 1."
openssl-101u,O2,mips,pub_print_gost94,./data/decomp/openssl-101u_mips_gcc_O2_extraction/pub_print_gost94@0061a314.c,"The first function takes in three 4-byte parameters, retrieves values from the second parameter, encodes data into a buffer, and returns an integer pointer. It is related to the GOST algorithm.

The second function prepares a GOST public key for cryptographic operations by creating a GOST key parameter structure and performing operations related to the GOST algorithm. It returns a pointer to the GOST key parameter structure.

The third function generates a GOST key pair and encodes it into an EVP_PKEY structure. It returns a pointer to the EVP_PKEY structure.

The fourth function decodes a GOST private key using the GOST algorithm and returns it as an integer array. It also checks for valid input parameters and supported algorithms.

The fifth function prints the details of a GOST key pair, including the private and public keys, parameter set, and affine coordinates. It returns an integer pointer."
openssl-101u,O2,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O2_extraction/RSA_padding_add_PKCS1_PSS@006284c8.c,"The first function, RSA_padding_add_PKCS1_PSS, generates PSS padding for a message hash and salt, adds it to an EM buffer, and hashes the message hash, zeroes, and salt together. It takes in an RSA key, an EVP_MD object, and a salt length, which can be calculated based on the RSA key and message digest algorithm. If the salt length is invalid, an error is thrown.

The second function performs XOR operations on input data and stores the result in a buffer. It returns the length of the output data. Its purpose is unclear from the code alone, but it appears to be related to encryption or decryption."
openssl-101u,O2,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O2_extraction/RSA_verify_PKCS1_PSS@00627a10.c,"The functions are both related to the RSA-PSS signature scheme. 

The first function, RSA_verify_PKCS1_PSS, verifies a message signature using the RSA-PSS algorithm. It takes in an RSA key, a message hash, an EVP_MD digest algorithm, a signature, and the length of the signature. The function initializes an EVP_MD_CTX context, checks the signature length, calculates the size of the RSA key, extracts the salt value from the signature, computes the MGF1 mask, XORs the mask with the message representative to obtain the encoded message, and checks if the leftmost bits of the encoded message are zero. It then extracts the leftmost byte of the encoded message as the salt length and verifies that it matches the expected value.

The second function is an implementation of the RSA-PSS signature scheme. It takes in a message, a RSA private key, a hash function, and some parameters for the signature scheme. It checks if the hash function is supported and if the parameters are valid. Then, it generates a random salt, computes the hash of the message concatenated with the salt, pads the hash, and applies the RSA private key operation to get the signature. Finally, it verifies the signature by computing the hash of the message concatenated with the salt, padding the hash, and applying the RSA public key operation. The function also handles error cases by setting appropriate error codes and messages using the OpenSSL error handling functions."
openssl-101u,O2,mips,sha_block_data_order,./data/decomp/openssl-101u_mips_gcc_O2_extraction/sha_block_data_order@00620130.c,"These functions are all related to cryptographic operations, specifically the SHA-1 hashing algorithm. They take in input data and process it in 512-bit blocks, performing bitwise and arithmetic operations on each block to generate intermediate values. These intermediate values are then combined and processed further to generate the final hash value. The specific details of the algorithm are difficult to decipher from the provided code, as it appears to be heavily optimized and obfuscated. However, it is clear that the function is designed to be highly secure and resistant to attacks such as collision and preimage attacks. Some of the functions take in additional parameters such as keys and perform operations specifically related to those parameters."
openssl-101u,O2,mips,SHA_Final,./data/decomp/openssl-101u_mips_gcc_O2_extraction/SHA_Final@006215dc.c,"The function appends a single bit (0x80) to the end of the data in the SHA_CTX structure. If there is not enough space for the bit and the padding, it fills the remaining space with zeroes, processes the block with the sha_block_data_order function, and starts a new block with the remaining data. It then appends the total number of bits in the data to the end of the block, in little-endian order. It processes the final block with the sha_block_data_order function and cleans up the SHA_CTX structure. Finally, it stores the resulting hash values (h0-h4) in the message digest (md) in big-endian order, and returns 1."
openssl-101u,O2,mips,srp_verify_server_param,./data/decomp/openssl-101u_mips_gcc_O2_extraction/srp_verify_server_param@004bb9ec.c,"The function srp_verify_server_param takes two parameters: an integer param_1 and a pointer to an undefined 4-byte variable param_2. It compares two values in memory at offsets param_1 + 0x1ac and param_1 + 0x1a8 using a code pointer. If either value is less than zero or if a certain value in memory at an offset is equal to zero, the function sets the value of the pointer param_2 to 0x2f and returns 0. If the first comparison is successful, the function calculates the number of bits in the value at offset param_1 + 0x1a8 and compares it to the value at offset param_1 + 0x1cc. If the number of bits is less than the value at offset param_1 + 0x1cc, the function sets the value of the."
openssl-101u,O2,mips,SSLv23_method,./data/decomp/openssl-101u_mips_gcc_O2_extraction/SSLv23_method@0048f230.c,"The SSLv23_method function returns a pointer to an SSL_METHOD structure. It is unclear how the function's parameters are passed or stored, and the implementation of the function is not shown. The function appears to call another function or use data stored in a variable to obtain the SSL_METHOD pointer. The parameter storage is locked, making it impossible to determine how the function's parameters are passed or stored."
openssl-101u,O2,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_mips_gcc_O2_extraction/SSL_SESSION_free.part.2@004ade34.c,"The function frees any additional data associated with the SSL_SESSION object, clears sensitive data from the object, frees any associated SSL_SESSION_CERT and X509 objects, frees any associated STACK_OF(X509) object, frees memory allocated for session ID, session ticket, and master key, clears the entire SSL_SESSION object, and finally frees the SSL_SESSION object."
openssl-101u,O2,mips,start_hash,./data/decomp/openssl-101u_mips_gcc_O2_extraction/start_hash@0061f4c8.c,"The function initializes an array of 4-byte integers to all zeroes if it has not already been initialized. It takes a pointer to the array as its parameter and checks if the third element of the array is not equal to zero. If it is not zero, it sets the fourth element of the array to zero, followed by setting the twelfth element of the array to zero. It then sets the third element of the array to zero, followed by setting the second element of the array to zero, and finally setting the first element of the array to zero. The function returns 1 if the third element of the array was not equal to zero, otherwise it returns 0."
openssl-101u,O2,mips,surewarehk_finish,./data/decomp/openssl-101u_mips_gcc_O2_extraction/surewarehk_finish@005d5b74.c,"This function checks if the surewarehk_dso variable is equal to 0. If it is, it sets the SUREWARE_lib_error_code to the error code returned by the PTR_ERR_get_next_error_library_006a9538 function and calls the PTR_ERR_put_error_006a7f34 function to log the error. If it is not, it calls the p_surewarehk_Finish function and frees the surewarehk_dso variable using the PTR_DSO_free_006a8874 function. If the PTR_DSO_free_006a8874 function returns 0, it sets the SUREWARE_lib_error_code to the error code returned by the PTR_ERR_get_next_error_library_006a9538 function and calls the PTR_ERR_put_error_006a7f34 function to log the error. If the PTR_DSO_free_006a8874 function returns a non-zero value, it sets the return value to 1."
openssl-101u,O2,mips,sv_body,./data/decomp/openssl-101u_mips_gcc_O2_extraction/sv_body@00443438.c,"The following are summaries of various functions related to SSL/TLS server implementation:

1. This function initializes the SSL/TLS protocol, reads data from the socket, and processes it based on the request type. It also handles timeouts, debug output, and sets various SSL/TLS-related flags.

2. This function sets up an SSL connection with a client and enters a loop to handle incoming data from the client. It reads data from the client and writes data back using SSL_read and SSL_write functions. It also handles various SSL-related events and cleans up the SSL connection if an error occurs.

3. This function initializes an SSL context and accepts incoming SSL connections. It reads incoming data from the SSL connection and processes it based on the request type. It also sends back a response with server statistics if the request is for statistics.

4. This function prints various information about the SSL connection, including the cipher being used, SSL version, and whether secure renegotiation is supported. It also checks if the `quiet` flag is set and exits if it is.

5. This function implements a command-line interface for an SSL/TLS server. It initializes various variables and structures, sets up the SSL/TLS context and socket, and enters a loop that reads commands from the user via stdin and processes them. It also handles SSL/TLS renegotiation and implements a callback function to handle SRP authentication.

6. This function handles incoming requests from the client, reads the request method, URI, and version, and sends a response based on the requested file type. It also checks for more requests from the client and cleans up the SSL connection if there are no more requests."
openssl-101u,O2,mips,TLSv1_method,./data/decomp/openssl-101u_mips_gcc_O2_extraction/TLSv1_method@004913b0.c,The function returns a pointer to a data object of type SSL_METHOD*. The purpose of the object is unclear.
openssl-101u,O2,mips,__do_global_ctors_aux,./data/decomp/openssl-101u_mips_gcc_O2_extraction/__do_global_ctors_aux@00630f10.c,"The function initializes pointers to the start of a constructor list, iterates through the list calling each constructor function, and returns when it reaches the end of the list."
openssl-101u,O2,mips,__libc_csu_init,./data/decomp/openssl-101u_mips_gcc_O2_extraction/__libc_csu_init@00630e60.c,"Function summary: 
- Name: __libc_csu_init
- Purpose: initializing the C runtime environment by calling a function pointed to by PTR__init_006a9920
- Additional information: the code inside the function is not shown in the decompiled code, and the function then returns."
openssl-101u,O2,mips,__start,./data/decomp/openssl-101u_mips_gcc_O2_extraction/__start@00421520.c,"The function initializes local variables and calls `__libc_start_main` with `main` as an argument. It then enters an infinite loop, indicating that it is the entry point of the program and `main` is responsible for the program's tasks."
openssl-101u,O2,mips,__udivdi3,./data/decomp/openssl-101u_mips_gcc_O2_extraction/__udivdi3@00630570.c,"The function takes in four unsigned integers as parameters and performs various bitwise operations on them to perform division and multiplication operations. It calculates a value uVar8 using the parameters and checks if the upper 16 bits of uVar8 are zero, calling a trap function if so. It then performs integer division of a value uVar2 by the upper 16 bits of uVar8 and calculates a value uVar7. It multiplies the lower 16 bits of uVar8 by the quotient uVar4 and stores the result in uVar9. If the upper 16 bits of uVar8 are zero, the function calls the trap function again. 

The function performs unsigned integer division of two 64-bit integers represented by four 32-bit input parameters. It checks for special cases where the divisor is zero or the dividend is smaller than the divisor, and returns 0 or the dividend respectively in those cases. Next, it calculates the number of leading zeros in the divisor and uses it to perform long division using a series of multiplications and subtractions. If the divisor is not zero and the dividend is greater than or equal to the divisor, it performs long division again. Finally, it returns the quotient and remainder."
openssl-101u,O3,mips,aep_mod_exp.part.0,./data/decomp/openssl-101u_mips_gcc_O3_extraction/aep_mod_exp.part.0@005ccd6c.c,"These summaries describe functions that perform modular exponentiation using an external hardware accelerator, specifically the AEP (Accelerated Encryption Processor) cryptographic library. The functions take in several parameters, including the base, exponent, modulus, and some internal variables. They first check if the AEP hardware is available and if the modulus is small enough to be processed by the hardware. If both conditions are met, they establish a connection with the AEP hardware and perform the modular exponentiation operation using the hardware. If the operation is successful, they update some internal variables and return a success code. If the AEP hardware is not available or the modulus is too large, the functions fall back to a software implementation of the modular exponentiation operation. They also handle some error conditions, such as when the AEP hardware is not available or when an error occurs during the modular exponentiation operation."
openssl-101u,O3,mips,asn1_bio_callback_ctrl,./data/decomp/openssl-101u_mips_gcc_O3_extraction/asn1_bio_callback_ctrl@0062a2f0.c,"The function takes an integer parameter and returns an integer value. It checks if the value stored at an offset of 0x24 from the input parameter is not equal to zero. If it is not zero, it jumps to an address stored in a global variable PTR_BIO_callback_ctrl_006a8428 and executes the code at that address as a function. The return value of that function is then returned by this function. If the value stored at the offset is zero, the function returns 0."
openssl-101u,O3,mips,asn1_bio_ctrl,./data/decomp/openssl-101u_mips_gcc_O3_extraction/asn1_bio_ctrl@0062a3e4.c,"The `asn1_bio_ctrl` function takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. It retrieves a pointer to a data structure from `param_1` and checks if it is NULL. If it is, the function returns 0. If `param_2` is equal to 0x97, the function sets two values in the data structure based on values in `param_4` and returns 1. If `param_2` is less than 0x98, the function checks if `param_2` is equal to 0x95. If it is, the function sets two values in the data structure based on values in `param_4` and returns 1. If `param_2` is greater than 0x95, the function retrieves two values from the data structure and stores them in `param_4` before returning 1."
openssl-101u,O3,mips,asn1_bio_free,./data/decomp/openssl-101u_mips_gcc_O3_extraction/asn1_bio_free@0062a314.c,"The function checks if an integer at an offset of 0x20 from the input integer is not equal to zero. If it is not zero, the function checks if the integer at an offset of 4 from the integer stored at the offset of 0x20 is not zero. If it is not zero, the function calls a function pointed to by a global variable PTR_CRYPTO_free_006a6e88, assumed to be the free function from the OpenSSL library. The function then calls the free function again with the integer stored at the offset of 0x20 as its argument. Finally, the function sets the integers stored at offsets of 0xc, 0x20, and 0x14 to zero and returns 1. If the integer stored at the offset of 0x20 is zero, the function returns 0."
openssl-101u,O3,mips,asn1_bio_write.part.1,./data/decomp/openssl-101u_mips_gcc_O3_extraction/asn1_bio_write.part.1@0062a7fc.c,"The function takes in three parameters: an integer, a second integer, and a pointer to an unsigned integer. It returns an integer. The function initializes local variables and checks conditions before calling itself recursively. If the first parameter plus 0x20 points to a null pointer, the function checks for a matching stack guard value and returns the result. If they do not match, the function sets the result to the local variable value, calls a stack check fail function, and then returns the result."
openssl-101u,O3,mips,asn1_bio_write,./data/decomp/openssl-101u_mips_gcc_O3_extraction/asn1_bio_write@0062ab7c.c,The function asn1_bio_write takes in three integer parameters and checks if certain conditions are met before calling another function. Its purpose is unclear without more context.
openssl-101u,O3,mips,BIO_asn1_get_suffix,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BIO_asn1_get_suffix@0062ada0.c,"The ""BIO_asn1_get_suffix"" function takes in a pointer to a BIO object (b), pointers to two undefined types (psuffix and psuffix_free), and returns an integer value. Within the function, a pointer to a stack guard variable is assigned to ""puVar1"" and the value of the stack guard is stored in ""local_14"". The function then calls the ""BIO_ctrl"" function with the parameters 0x98, 0, and a pointer to ""local_1c"". If the result of the function call is greater than 0, the value of ""local_1c"" is assigned to ""*psuffix"" and the value of ""local_18"" is assigned to ""*psuffix_free"". Finally, the function checks if the value of ""local_14"" is equal to the value of the stack guard variable stored in ""puVar1""."
openssl-101u,O3,mips,BIO_asn1_set_prefix,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BIO_asn1_set_prefix@0062ac2c.c,"The function takes in a BIO object and two pointers to undefined data types and returns an integer value. It calls the BIO_ctrl function with various parameters and stores the result in the iVar3 variable. It then checks if the stack guard variable has been modified, and if so, calls the stack check fail function. If the result of the BIO_ctrl function is greater than zero, it sets the values of two undefined variables (puVar4 and puVar5) to the values of four other undefined variables (uStack_4c, uStack_48, uStack_b4, and uStack_b0). Finally, the function checks the stack guard variable again and returns the value of iVar3."
openssl-101u,O3,mips,BN_get0_nist_prime_224,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_get0_nist_prime_224@0062ae4c.c,The function returns a pointer to a BIGNUM structure containing a pre-defined NIST prime number with 224 bits. The prime number value is stored in a static array and the function does not take any parameters. The calling convention is unknown.
openssl-101u,O3,mips,BN_get0_nist_prime_384,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_get0_nist_prime_384@0062ae64.c,"The function returns a pointer to a BIGNUM structure containing a pre-defined NIST prime number with 384 bits. The prime number's value is stored in a static array named _bignum_nist_p_384. However, the function's calling convention is unknown, which may cause issues when called from other parts of the code."
openssl-101u,O3,mips,BN_GF2m_add,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_add@00623a34.c,"The function BN_GF2m_add takes in three parameters, which are pointers to arrays of uints. It performs the addition of the two arrays pointed to by param_2 and param_3, and stores the result in the array pointed to by param_1. It checks which of the two arrays pointed to by param_2 and param_3 has a higher index value, sets puVar4 to point to the array with the lower index value, and ppuVar6 to point to the array with the higher index value. If the length of the array pointed to by param_1 is less than the length of the array pointed to by param_3, the function expands the array pointed to by param_1 using the function PTR_bn_expand2_006a8524. The function then performs the addition of the two arrays pointed to by ppuVar6 and param_2, and stores the result in the array pointed to by param_1."
openssl-101u,O3,mips,BN_GF2m_mod,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod@00623cb4.c,"The functions BN_GF2m_mod and BN_GF2m_mod_arr_part_0 both take in four parameters and return an unsigned integer. BN_GF2m_mod first checks if the second parameter is NULL, and if not, calls BN_GF2m_mod_arr_part_0. If a certain condition is met, BN_GF2m_mod calls another function and returns a value. 

On the other hand, BN_GF2m_mod_arr_part_0 takes in a pointer to a BIGNUM structure, a pointer to an array of integers, the length of the array, and a pointer to a BN_CTX structure. It first checks if the length of the array is zero, and if not, checks if the BIGNUM pointer and the array pointer are the same. If they are not, it checks if the BIGNUM has enough space to hold the array. If it does not, it expands the BIGNUM. Then, it copies the array into the BIGNUM and updates the BIGNUM's length. Finally, the function returns a value based on the result of another function call."
openssl-101u,O3,mips,BN_GF2m_mod_arr,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_arr@00623bc0.c,"The function takes in three integer arrays and a fourth integer parameter. It first checks if the third array is empty and if so, sets the first array to 0 and returns 1. If the third array is not empty, it checks if the first array is the same as the second array. If they are not the same, it expands the first array if necessary to be at least as large as the second array, and then copies the contents of the second array into the first array. It then calls the function BN_GF2m_mod_arr_part_0 with the first and third arrays as arguments and returns the result of that function."
openssl-101u,O3,mips,BN_GF2m_mod_div,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_div@006258c4.c,"The function BN_GF2m_mod_div performs modular division in the binary Galois field GF(2^m) by taking in four parameters: the dividend and divisor, the modulus, and a BN_CTX structure used for temporary storage. It first initializes the BN_CTX structure using the start and get functions. It then computes the modular inverse of the modulus using BN_GF2m_mod_inv and stores it in iVar1. If the inverse is successfully computed, the function proceeds to allocate memory for an array of integers of size (number of bits in the dividend + 1) * 4. This array is used to store the positions of the non-zero bits in the dividend. If the memory allocation is successful, the function checks if the dividend is zero. If it is, the function sets bVar11 to false and goes to the end of the function. Otherwise, the function computes the positions of the non-zero bits in the dividend."
openssl-101u,O3,mips,BN_GF2m_mod_div_arr,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_div_arr@00625adc.c,"The function BN_GF2m_mod_div_arr performs polynomial division in the GF(2^m) field. It takes five parameters - three integers and two pointers for temporary memory allocation. The function initializes a polynomial to 0 and sets the first bit to 1. It computes the inverse of the divisor polynomial using BN_GF2m_mod_inv and checks if it can be computed. It calculates the number of bits required to represent the inverse polynomial, allocates memory accordingly, and checks if the leading coefficient of the inverse polynomial is non-zero. It then calculates the positions of the non-zero bits in the inverse polynomial and stores them in an array. If the leading coefficient is zero, the function returns false."
openssl-101u,O3,mips,BN_GF2m_mod_mul,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_mul@00624cdc.c,"BN_GF2m_mod_mul is a function that performs multiplication on two binary polynomials in GF(2^m) field. The function takes in five parameters: param_1, param_2, param_3, param_4, and param_5. The first parameter (param_1) is a pointer to the first binary polynomial to be multiplied, the second parameter (param_2) is a pointer to the second binary polynomial to be multiplied, and the third parameter (param_3) is a pointer to the irreducible binary polynomial that defines the GF(2^m) field. The fourth parameter (param_4) is a pointer to an array of integers that represent the binary polynomial. The function calculates the number of bits in the binary polynomial using the function PTR_BN_num_bits_006a71f4 and allocates memory for an array of integers that is equal to the number of bits plus one, where each integer represents the binary polynomial."
openssl-101u,O3,mips,BN_GF2m_mod_mul_arr,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_mul_arr@00624144.c,"The following functions all involve arithmetic operations on binary polynomials in GF(2^m) fields:

1. This function multiplies two elements in GF(2^m) and stores the result in a third element. It uses a standard polynomial multiplication algorithm and initializes a context variable before performing the multiplication. The function returns 0 if memory allocation fails.

2. This function performs several bitwise operations on input values and arrays to generate new values and store them in local variables. It also uses a local array to store intermediate results. The function returns the result of a bitwise XOR operation.

3. This function performs modular reduction of the first polynomial modulo the second polynomial, using the irreducible polynomial stored in the second polynomial. The result is stored in the first polynomial. The function returns 0 if the second polynomial is zero or has degree zero.

4. This function performs finite field arithmetic over binary fields (GF(2^m)). It checks if either of the operands is zero, and if the modulus is zero, it returns failure. If the reduction polynomial is null, it computes it using a pre-defined algorithm. It then iterates over the bits of the second operand and sets the corresponding bits in a temporary buffer to the value of the first operand if the corresponding bit in the second operand is set. The function returns success or failure."
openssl-101u,O3,mips,BN_GF2m_mod_sqr,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_sqr@00624ed0.c,"The function BN_GF2m_mod_sqr performs a modular squaring operation on a binary polynomial represented as an array of integers. It calculates the number of bits required to represent the polynomial and allocates memory for a new array to store the result. It extracts the indices of the non-zero bits of the polynomial and stores them in the new array. It calls the function BN_GF2m_mod_sqr_arr to perform the modular squaring operation on the new array. If the resulting array has more bits than the original polynomial, an error is generated and the function returns zero. The memory allocated for the new array is freed and the result of the operation is returned."
openssl-101u,O3,mips,BN_GF2m_mod_sqrt,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_sqrt@006262f8.c,"The function BN_GF2m_mod_sqrt takes four parameters: param_1, param_2, param_3, and param_4. The first parameter (param_1) is an undefined value that is used to store the result of the function. The second parameter (param_2) is an undefined value that is not used in the function. The third parameter (param_3) is an array of integers that represents a polynomial in GF(2^m) where m is the degree of the polynomial. The fourth parameter (param_4) is a context variable that is used to manage memory allocation and deallocation. The function first calculates the degree of the polynomial represented by param_3 and allocates an array of integers (piVar2) to store the positions of the non-zero coefficients in the polynomial. It then checks if the polynomial is zero and returns 0 if it is. Next, the function sets the most significant bit of the polynomial and calculates the square."
openssl-101u,O3,mips,BN_GF2m_mod_sqr_arr,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_GF2m_mod_sqr_arr@00623ea0.c,"The function initializes a BN_CTX object and allocates memory for an array of unsigned integers. If the allocation is successful, it checks the size of the array and expands it if necessary. The function takes four parameters: a pointer to a pointer to an array of unsigned integers, a pointer to an integer, a pointer to another integer, and an undefined value."
openssl-101u,O3,mips,BN_kronecker,./data/decomp/openssl-101u_mips_gcc_O3_extraction/BN_kronecker@00622900.c,The function BN_kronecker calculates the Kronecker symbol of two BIGNUMs a and b using the binary algorithm. The Kronecker symbol extends the definition of the Legendre symbol to all integers a and odd positive integers b. The binary algorithm works by repeatedly dividing b by 2 until it becomes odd and then applies the properties of the Kronecker symbol to simplify the calculation.
openssl-101u,O3,mips,by_dir_entry_free,./data/decomp/openssl-101u_mips_gcc_O3_extraction/by_dir_entry_free@00584cb0.c,"The function takes in a pointer to an integer parameter called ""param_1"". It checks if the value pointed to by ""param_1"" is not equal to 0. If it is not 0, it calls a function at address ""PTR_CRYPTO_free_006a6e88"" to free the memory allocated to it. It also checks if the value at index 2 of the array pointed to by ""param_1"" is not equal to 0. If it is not 0, it calls a function at address ""PTR_sk_pop_free_006a7058"" to free the memory allocated to it, passing in another function ""by_dir_hash_free"" as a parameter. Finally, it calls a function at address ""PTR_CRYPTO_free_006a6e88"" to free the memory allocated to the entire ""param_1"" array. The function contains two function pointers, ""PTR_CRYPTO_free_006a6e""."
openssl-101u,O3,mips,cswift_rand_bytes,./data/decomp/openssl-101u_mips_gcc_O3_extraction/cswift_rand_bytes@005cfaa0.c,"1. The function `cswift_rand_bytes` generates a specified number of random bytes using the CSwift cryptographic library. It first acquires an access context using the `CSwift_AcquireAccContext` function. If the acquisition is successful, it proceeds to generate random bytes in chunks of 1024 bytes or less until the requested number of bytes is generated. It does this by calling the `CSwift_SimpleRequest` function with the appropriate parameters. If an error occurs during the generation of random bytes, the function sets the `CSWIFT_lib_error_code` variable to the error code and calls the `ERR_put_error` function to log the error. The function returns a pointer to the generated random bytes.

2. The function is a C implementation of the Diffie-Hellman key exchange using the CryptoSwift library. It takes in two parameters: a pointer to a buffer containing the public key of the other party and the length of the buffer. It returns a pointer to a buffer containing the shared secret key. The function first initializes some variables and checks if the CryptoSwift library has been loaded. If it hasn't been loaded, it loads the library and retrieves function pointers for various CryptoSwift functions. It then acquires an access context, attaches the key parameter, and performs a simple request to generate a random number. It then performs a loop to calculate the shared secret key using the Diffie-Hellman key exchange algorithm. It does this by generating a random number, raising the public key of the other party to the power of the random number, and sending the result to the other party. It then receives a response from the other party, raises it to the power of the random number, and stores.

3. The decompiled function is a part of a larger program and it is difficult to determine its exact purpose without additional context. However, it appears to be performing some cryptographic operations using a library called CSWIFT. The function begins by setting up some variables and calling a function to acquire an access context. If the function returns 0, the program continues to execute. Otherwise, an error code is set and an error message is printed. Next, the program calls a function to perform some cryptographic operations using the CSWIFT library. If these operations are successful, the program continues to execute. Otherwise, an error code is set and an error message is printed. Finally, the program calls another function to perform some additional cryptographic operations using"
openssl-101u,O3,mips,d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS,./data/decomp/openssl-101u_mips_gcc_O3_extraction/d2i_GOST_CLIENT_KEY_EXCHANGE_PARAMS@0061c2f0.c,"The function calls an external function through a function pointer stored at PTR_ASN1_item_d2i_006a8674, likely to deserialize a GOST client key exchange parameter from ASN.1 format into an internal representation. It does not perform any other operations and simply returns after calling the external function."
openssl-101u,O3,mips,d2i_GOST_KEY_PARAMS,./data/decomp/openssl-101u_mips_gcc_O3_extraction/d2i_GOST_KEY_PARAMS@0061c230.c,"The function ""d2i_GOST_KEY_PARAMS"" is a wrapper function that calls another function through a function pointer stored at the address ""PTR_ASN1_item_d2i_006a8674"". The function being called is not shown in the code, but it likely performs some operation related to converting a GOST key parameter from DER encoding to an internal representation. The function returns no value."
openssl-101u,O3,mips,decode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O3_extraction/decode_gost_algor_params@00618f2c.c,"The first function, `decode_gost_algor_params`, takes in two parameters of type `undefined4` and is responsible for decoding GOST key parameters from algorithm parameters. It initializes variables, extracts algorithm parameters, decodes GOST key parameters, sets the type of an EVP_PKEY object, and fills in the GOST.

The second function is a part of the OpenSSL library and generates a public key from a private key using the GOST R 34.10-2001 elliptic curve digital signature algorithm. It takes in an EVP_PKEY structure containing the private key and a pointer to a BIO structure for outputting errors. It checks if the private key is of the correct type, extracts the private key value, generates a public key, sets the public key in the EVP_PKEY structure, outputs an error message if any errors occur, and returns 0 or 1 indicating success."
openssl-101u,O3,mips,DES_xcbc_encrypt,./data/decomp/openssl-101u_mips_gcc_O3_extraction/DES_xcbc_encrypt@00621820.c,"These functions all perform encryption or decryption operations using various block cipher modes of operation (XCBC, CBC, OFB). They take in input data, a key, and an initialization vector (IV) and produce encrypted output data. They also include some stack protection code to prevent buffer overflow attacks. The specific encryption algorithms used are DES, AES, and Blowfish. The functions divide the input data into blocks and process them using the specified mode of operation, XORing and encrypting each block as necessary. If the input data is not a multiple of the block size, padding is added. The functions return the encrypted output data."
openssl-101u,O3,mips,dgram_ctrl,./data/decomp/openssl-101u_mips_gcc_O3_extraction/dgram_ctrl@00529e10.c,"The first function, `dgram_ctrl`, takes in four parameters and uses a switch statement to perform different actions based on the value of `param_2`. If `param_2` is 0, it retrieves a pointer to a data structure from `param_1` and returns it. If `param_2` is 1, it sets a pointer to a data structure in `param_1` to the value of `param_3` and returns 1. If `param_2` is 3 or 4, it enters a block of code that is not shown in the decompiled output. If `param_2` is 0x17 or 0x24, it retrieves a short value from `param_4` and returns it.

The second function takes in several parameters, including a BIO object, a buffer, a length, and a pointer to a pointer to a sockaddr structure. It checks the type of the BIO object and performs different actions depending on the type. For example, if the BIO object is of type 0x60 (a socket BIO), it sets the BIO object's internal state to indicate that it is connected to a socket, and stores the socket file descriptor and sockaddr structure in the BIO object. If the BIO object is of type 0x61 (a connected socket BIO), it retrieves the stored socket file descriptor and sockaddr structure from the BIO object and returns them to the caller. The function also performs error checking and sets appropriate flags and error codes if necessary."
openssl-101u,O3,mips,dlfcn_bind_func,./data/decomp/openssl-101u_mips_gcc_O3_extraction/dlfcn_bind_func@0062947c.c,"The function takes in two integer parameters, param_1 and param_2. It first checks if either parameter is equal to 0, and if so, sets two variables uVar2 and uVar3 to specific values (0x43 and 0x109). If neither parameter is equal to 0, it calls a function at the address PTR_sk_num_006a6e2c with the value at address (param_1 + 4) as an argument. This function returns the number of items in a stack, which is stored in iVar1. If iVar1 is less than 1, uVar2 and uVar3 are set to different specific values (0x69 and 0x10d). Otherwise, the function retrieves the value at address (param_1 + 4) and calls the same function as before to get the number of items in the stack. It then retrieves the last item in the stack and stores it in iVar1."
openssl-101u,O3,mips,dlfcn_bind_var,./data/decomp/openssl-101u_mips_gcc_O3_extraction/dlfcn_bind_var@006295f0.c,"The function dlfcn_bind_var takes in two integer parameters: param_1 and param_2. It checks if either parameter is equal to zero, and if so, sets two variables (uVar2 and uVar3) to specific values. If both parameters are non-zero, it calls a function at the memory address PTR_sk_num_006a6e2c with the value at offset 4 of param_1 as an argument. It then checks if the return value is less than 1 and if so, sets uVar2 and uVar3 to specific values. If the return value is greater than or equal to 1, it sets a variable (uVar3) to the value at offset 4 of param_1, calls the function at the memory address PTR_sk_num_006a6e2c with uVar3 as an argument, and sets a variable (iVar1) to the return value minus 1."
openssl-101u,O3,mips,dlfcn_globallookup,./data/decomp/openssl-101u_mips_gcc_O3_extraction/dlfcn_globallookup@00629030.c,"The function uses dynamic linking to retrieve the address of a specified symbol at runtime. It opens a shared library using dlopen, retrieves the symbol address using dlsym, and returns it as an unsigned integer. If it fails, it returns 0. The function closes the library using dlclose."
openssl-101u,O3,mips,doapr_outch.constprop.0,./data/decomp/openssl-101u_mips_gcc_O3_extraction/doapr_outch.constprop.0@00524768.c,"The function takes in four parameters: two pointers to integers and two pointers to unsigned integers. It returns an undefined value. The function first assigns the values of the unsigned integers pointed to by param_3 and param_4 to variables uVar3 and uVar1, respectively. If the pointer param_2 is not equal to NULL and uVar3 is equal to uVar1, the function checks if uVar3 + 0x400 is greater than 0x7ffffbff. If it is, the function returns 0. If param_2 points to NULL, the function allocates memory for a new block of size uVar1 using the function PTR_CRYPTO_malloc_006a7008. If the allocation fails, the function returns 0. Otherwise, the function copies the contents of the block pointed to by param_1 to the newly allocated block, updates the value of uVar3 to the original value pointed to by param_3, sets the value pointed to."
openssl-101u,O3,mips,dtls1_link_min_mtu,./data/decomp/openssl-101u_mips_gcc_O3_extraction/dtls1_link_min_mtu@004a4df8.c,"The function returns the minimum MTU size (256 in decimal) for DTLS links, which is a protocol used to secure UDP connections."
openssl-101u,O3,mips,ec_GFp_mont_field_encode,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_mont_field_encode@0062730c.c,"The function takes four parameters: param_1, param_2, param_3, and param_4. It retrieves an integer value from the memory location at offset 0xa0 of param_1 and stores it in the variable iVar1. If iVar1 is non-zero, it calls a function pointer stored at a certain memory location (PTR_BN_mod_mul_montgomery_006a8558) with param_2, param_3, the value at offset 4 of iVar1, iVar1, and param_4 as arguments. It then returns the result of this function call. If iVar1 is zero, it calls another function pointer (PTR_ERR_put_error_006a7f34) with four arguments: 0x10, 0x86, 0x6f, and the string ""ecp_mont.c"", 0x117. It then returns 0."
openssl-101u,O3,mips,ec_GFp_mont_field_sqr,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_mont_field_sqr@00627294.c,"The function performs a squaring operation on a field element in a Montgomery domain. It takes four parameters: a pointer to a data structure containing the parameters of the elliptic curve, two input field elements to be squared, and a pointer to a data structure containing the Montgomery domain parameters. The function checks if the Montgomery domain parameter is set and calls a code snippet to perform the squaring operation in the Montgomery domain if it is. If not, the function calls another function."
openssl-101u,O3,mips,ec_GFp_mont_group_init,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_mont_group_init@00626d80.c,The function initializes a Montgomery-form elliptic curve group by calling ec_GFp_simple_group_init() to initialize a basic elliptic curve group. It sets two variables to zero in the group structure for later use in the Montgomery multiplication algorithm. No error checking is performed before returning.
openssl-101u,O3,mips,ec_GFp_nist_field_mul,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_nist_field_mul@0062772c.c,"The function takes in five integer parameters. It checks if any of the first four parameters are equal to zero and if so, calls a function to put an error. If the fifth parameter is not equal to zero, it multiplies the second, third, and fourth parameters together using a function called BN_mul. It then squares the result using a function pointer stored in the first parameter plus an offset of 0x48. If the square operation is successful, it returns true, otherwise false. If the fifth parameter is equal to zero, it creates a new BN_CTX object using a function called BN_CTX_new. It then multiplies the second, third, and fourth parameters together using a function called BN_mul and stores the result in the BN_CTX object. It then squares the result using a function pointer stored in the first parameter plus an offset of 0x48. If the square operation is successful, it returns true, otherwise false. Finally, it frees the BN_CTX object using."
openssl-101u,O3,mips,ec_GFp_nist_group_copy,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_nist_group_copy@00627470.c,"The `ec_GFp_nist_group_copy` function copies the parameters of `param_2` into `param_1`, including the curve parameters stored at offset `0xa8`. It then calls `ec_GFp_simple_group_copy()` to copy the remaining parameters of the group structure. The function returns after these operations."
openssl-101u,O3,mips,ec_GFp_nist_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_nist_group_set_curve@00627488.c,"The function `ec_GFp_nist_group_set_curve` initializes an `EC_GROUP` structure with curve parameters for a NIST elliptic curve over a prime field. It takes four input parameters: `param_1`, `param_2`, `param_3`, and `param_4`, which represent the `EC_GROUP` structure and `BIGNUM` structures for curve parameters `p`, `a`, and `b`. If a `BN_CTX` object is not passed as the `param_5` parameter, it creates a new one and initializes it. The function retrieves a `BIGNUM` object representing the NIST prime for the given curve size and compares it."
openssl-101u,O3,mips,ec_GFp_simple_get_Jprojective_coordinates_GFp,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_get_Jprojective_coordinates_GFp@0062d680.c,"The function takes in six integer parameters and returns a boolean value. It first checks if a certain value in the memory location pointed to by the first parameter is zero. If it is zero, it checks if the third and fourth parameters are also zero or if they are not zero, it copies values from the memory locations pointed to by the second parameter to them. If the fifth parameter is not zero, it copies a value from the memory location pointed to by the second parameter to it. If any of these copy operations fail, the function returns false. If the value in the memory location pointed to by the first parameter is not zero, it creates a new BN_CTX object and assigns it to the sixth parameter. It then calls a function pointer stored in the memory location pointed to by the first parameter with various arguments, including the second parameter and the third, fourth, and fifth parameters if they are not zero, to perform some calculations. If any of these calculations fail, the function returns false."
openssl-101u,O3,mips,ec_GFp_simple_group_check_discriminant,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_group_check_discriminant@0062d86c.c,"The function takes an integer array and an integer as input and returns a boolean value. It checks if the second parameter is zero and allocates memory for a new integer if it is. It initializes several integer variables using a context object. If the fifth element of the input array is not zero, it calculates the discriminant of an elliptic curve using the values in the array. If the function pointer at offset 0x94 of the first element of the input array is NULL, it calculates the discriminant directly. Finally, it checks if the discriminant is zero or not and returns false if it is zero."
openssl-101u,O3,mips,ec_GFp_simple_group_clear_finish,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_group_clear_finish@0062d184.c,The function ec_GFp_simple_group_clear_finish clears and frees memory associated with the group structure used in elliptic curve cryptography by calling BN_clear_free function three times with specific memory addresses within the group structure and returns.
openssl-101u,O3,mips,ec_GFp_simple_group_copy,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_group_copy@0062e6d4.c,"The function takes in two integer parameters and copies the contents of one elliptic curve group to another. It calls a function at memory address PTR_BN_copy_006a8450 to copy the contents of the second group's parameter 0x48 to the first group's parameter 0x48. If successful, it copies the contents of the second group's parameter 0x74 to the first group's parameter 0x74, and then the contents of the second group's parameter 0x88 to the first group's parameter 0x88. Finally, it copies the value of the second group's parameter 0x9c to the first group's parameter 0x9c. The function returns 1 if all operations are successful and 0 otherwise."
openssl-101u,O3,mips,ec_GFp_simple_group_get_degree,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_group_get_degree@0062d234.c,"The function takes an integer parameter, adds an offset of 0x48 to it, and indirectly calls a function located at the address pointed to by PTR_BN_num_bits_006a71f4 using an indirect jump. The purpose of the called function is to get the degree of a simple elliptic curve group over a finite field."
openssl-101u,O3,mips,ec_GFp_simple_group_set_curve,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_group_set_curve@0062e814.c,"The function `ec_GFp_simple_group_set_curve` initializes variables and performs mathematical operations using input parameters. It uses functions from the ""libcrypto"" library. If input parameters do not meet certain conditions, an error is thrown and the function returns 0. The function returns either 0 or 1 depending on the result of the mathematical operations performed."
openssl-101u,O3,mips,ec_GFp_simple_invert,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_invert@0062f784.c,"The function takes two parameters, param_1 and param_2. It first calls a function at address PTR_EC_POINT_is_at_infinity_006a864c, and if the return value is 0 and the value at offset 0x1c of param_2 is not 0, it calls a function at address PTR_BN_usub_006a85b0 with param_2+0x18 and param_1+0x48 as arguments. If the return value from this call is not an error code, it is returned. Otherwise, the function returns 1."
openssl-101u,O3,mips,EC_GFp_simple_method,./data/decomp/openssl-101u_mips_gcc_O3_extraction/EC_GFp_simple_method@0063055c.c,"The function EC_GFp_simple_method() returns a pointer to an object of type EC_METHOD, with an unknown calling convention and locked parameter storage. No input parameters are required. The implementation of the object is not shown in the code snippet."
openssl-101u,O3,mips,ec_GFp_simple_point_copy,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_point_copy@0062e774.c,"This function is used in an elliptic curve cryptography library to copy the contents of one point on the curve to another. It takes two parameters, both pointers to structures representing points on the curve. The function first copies the x-coordinate of the point from the second structure to the first using a function at address PTR_BN_copy_006a8450. If successful, it then copies the y-coordinate and z-coordinate of the point from the second structure to the first. Finally, it copies a flag value from the second structure to the first and returns 1 if all copy operations were successful, otherwise it returns 0."
openssl-101u,O3,mips,ec_GFp_simple_point_finish,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_point_finish@0062d130.c,"The ""ec_GFp_simple_point_finish"" function takes an integer parameter and frees memory allocated for three objects located at specific memory addresses before returning."
openssl-101u,O3,mips,ec_GFp_simple_point_get_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_point_get_affine_coordinates@0062db70.c,"The function takes in five parameters, four integers and a pointer to an EC point structure. It returns a boolean value indicating whether it was successful in retrieving the affine coordinates of the EC point. The function first checks if the EC point is at infinity. If it is, it returns false and sets an error message. If the fifth parameter (a BN_CTX object) is not provided, the function creates a new one and initializes it. It then sets up four variables to be used for intermediate calculations. If the EC point has a null function pointer for computing its affine coordinates, the function checks if the point is already in affine form. If it is, it copies the x and y coordinates to the output parameters (param_3 and param_4). If not, it computes the inverse of the y coordinate modulo the curve's order, and then computes the x and y coordinates in affine form using the curve's equation. If the output parameters are provided, it copies the computed values to them."
openssl-101u,O3,mips,ec_GFp_simple_point_set_affine_coordinates,./data/decomp/openssl-101u_mips_gcc_O3_extraction/ec_GFp_simple_point_set_affine_coordinates@0062eb14.c,"The function takes in five parameters: two undefined 4-byte values, two integers, and another undefined 4-byte value. It checks if both integers are not equal to 0 and calls two other functions using function pointers if they are not 0. The first function returns a value of 1, and the second function sets the J-projective coordinates of an elliptic curve point using the given parameters. The function then returns the value returned by the second function. If either integer is equal to 0, it calls another function using a function pointer to put an error message into the error queue and returns 0."
openssl-101u,O3,mips,encode_gost_algor_params,./data/decomp/openssl-101u_mips_gcc_O3_extraction/encode_gost_algor_params@0061a624.c,"The following functions are described:

1. `encode_gost_algor_params`: Takes an integer pointer `param_1` as input and returns an integer pointer `piStack_a8`. Creates a new `GOST_KEY_PARAMS` object, sets appropriate parameters, encodes the object, frees the object, and returns the encoded data pointer. Includes error checks that call `ERR_GOST_error` if necessary.

2. Signature creation function: Takes in a public key and uses it to create a signature for a message. Checks if the input public key is valid, retrieves two integers from the key, performs cryptographic operations on the message, encodes the resulting signature, and returns it as an integer array. Includes error handling code.

3. `gost_pkey_asn1_meth` (decompiled version): Takes in a pointer to an EVP_PKEY structure and a pointer to a buffer containing ASN.1 encoded data. Decodes the ASN.1 data, sets variables based on the decoded data, checks the type of the EVP_PKEY structure, performs different actions based on the type, encodes some data based on the EVP_PKEY structure and the decoded ASN.1 data, and returns a pointer to the encoded data.

4. `print_key_info`: Takes in a pointer to an EVP_PKEY structure as an argument. Checks if the input argument is NULL and returns NULL if it is. Gets the type of the EVP_PKEY structure, checks if it is a GOST R 34.10-2001 key, gets the private key and prints it out, gets the public key and prints it out, gets the parameter set for the key and prints it out, and returns a pointer to an integer with the value of 1 to indicate success. Prints out an error message and returns NULL if any errors occur.

5. `GOST_MAC_Init`: Takes three arguments: a pointer to a GOST_MAC_CTX structure, a pointer to a GOST_KEY structure, and a pointer to a GOST_CIPHER_PARAMS structure. Checks if the input pointers are not null, initializes the GOST_MAC_CTX structure by setting its key and cipher parameters to the input pointers, sets the MAC function to the GOST R 34.11-94 hash function, sets an error code and returns a null pointer if any errors occur, and returns a pointer to the initialized GOST_MAC_CTX structure."
openssl-101u,O3,mips,general_allocate_boolean.constprop.5,./data/decomp/openssl-101u_mips_gcc_O3_extraction/general_allocate_boolean.constprop.5@005b096c.c,"The function takes in eight parameters, including an integer pointer, integers, and a character pointer. It first checks if the character pointer is null and returns an error code if it is. If not, it checks if the length of the character pointer is greater than zero and if all its characters are valid. If not, it returns an error code. If the character pointer is valid, the function checks if the second parameter is zero and returns an error code if it is. It then checks if the eighth parameter is non-zero and allocates memory for an integer array of size 0x20 if it is. It sets values in the array based on the input parameters and pushes it onto a stack. Finally, the function returns the index of the pushed array on the stack minus one if successful, or -1 if there was an error."
openssl-101u,O3,mips,get_gost_engine_param,./data/decomp/openssl-101u_mips_gcc_O3_extraction/get_gost_engine_param@0061e458.c,"The function checks if an integer parameter is equal to 0. If it is, it checks if a global variable is also equal to 0. If it is, it gets the value of an environment variable using a function pointer. If the value is not null, it duplicates the string and assigns it to the global variable. Finally, it returns the value of the global variable. If the integer parameter is not equal to 0, it returns 0."
openssl-101u,O3,mips,gost2001_param_encode,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost2001_param_encode@006196e8.c,"The function gost2001_param_encode takes two parameters of type undefined4. It calls several other functions using function pointers stored at memory addresses PTR_EVP_PKEY_get0_006a95d8, PTR_EC_KEY_get0_group_006a7690, PTR_EC_GROUP_get_curve_name_006a7f7c, PTR_OBJ_nid2obj_006a7140, and PTR_i2. The return values of these functions are stored in a variable uVar1."
openssl-101u,O3,mips,gost_cipher_cleanup,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost_cipher_cleanup@0061c5f0.c,"The function takes an integer parameter `param_1`. It then calls the `gost_destroy` function with an argument that is the value stored at the memory address `(param_1 + 0x60) + 0xc`. This likely refers to a GOST cipher object that is being destroyed. Next, the function sets the value at the memory address `(param_1 + 0x54)` to 0. It is unclear what this specific memory address refers to without more context. Finally, the function returns the value 1."
openssl-101u,O3,mips,gost_cipher_ctl,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost_cipher_ctl@0061ce84.c,"The function `gost_cipher_ctl` takes four parameters: `param_1`, `param_2`, `param_3`, and `param_4`. If `param_2` is equal to 6, the function calls the `RAND_bytes` function using a pointer to `param_4`, the value stored at the memory address `(param_1 + 0x58)`, `param_3`, and a pointer to the global pointer `_gp`. If the return value of `RAND_bytes` is less than 1, the function calls `ERR_GOST_error` with error codes 0x6f and 0x7b, and sets the return value to `0xffffffff`. Otherwise, the return value is set to 1. If `param_2` is equal to 7, the function checks if `param_4` is not equal to null. If it is not null, the function sets the value at the memory address."
openssl-101u,O3,mips,gost_cipher_do_cnt,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost_cipher_do_cnt@0061c7ec.c,"The first function implements the GOST cipher in counter mode (GOST CTR), taking in an integer, two byte arrays, and an unsigned integer as parameters. It sets variables based on the current state of the cipher and XORs input data to produce output data. If the input data is longer than the remaining counter bytes, it generates new counter bytes using the GOST cipher and continues until all input data is processed.

The second function takes in a pointer to a byte array, a pointer to another byte array, the length of the second byte array, and an integer indicating the maximum number of bytes that can be copied from the second byte array to the first byte array. It checks if the length of the second byte array is greater than the maximum number of bytes that can be copied and returns 1 if it is. It then XORs the first byte of the second byte array with a byte from the first byte array and stores the result in the first byte of the first byte array. If the length of the second byte array is not greater than the maximum number of bytes that can be copied plus one, it sets a value in the first byte array to indicate the number of bytes that were successfully copied and returns 1."
openssl-101u,O3,mips,gost_cipher_init,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost_cipher_init@0061e0a8.c,"The function takes in three parameters: param_1, param_2, and param_3. It checks if a certain value at address (param_1 + 0x54) is equal to 0. If it is not, the function jumps to a label called LAB_0061e0e4, which skips some initialization steps. If it is 0, the function proceeds with initialization. The function then calls a function called get_gost_engine_param(0) to retrieve a parameter. If the parameter is null or an empty string, it sets some variables to values from a predefined list. If the parameter is not null, it converts the parameter to an integer using the function PTR_OBJ_txt2nid_006a6f5c, and then searches through the predefined list for a matching integer value. If a match is found, it sets some variables to the corresponding values from the list. Finally, the function sets some values in an array at address."
openssl-101u,O3,mips,GOST_CIPHER_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O3_extraction/GOST_CIPHER_PARAMS_new@0061c2c0.c,"The function creates a new instance of the GOST_CIPHER_PARAMS data structure using the ASN1_item_new function, which is called using a function pointer stored in a variable. The resulting instance is then returned."
openssl-101u,O3,mips,gost_imit_final,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost_imit_final@0061de10.c,"The function retrieves values from memory and checks if certain values are equal to 0. If they are, it calls an error function and jumps to a label. It also assigns values to local variables and sets other variables based on conditions."
openssl-101u,O3,mips,gost_imit_init_cpa,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost_imit_init_cpa@0061cdfc.c,The function initializes parameters for the GOST 28147-89 encryption algorithm with the CryptoPro parameter set A. It sets various values to 0 and initializes the key schedule using the gost_init function with the provided parameters. It returns a value of 1 to indicate successful initialization.
openssl-101u,O3,mips,GOST_KEY_PARAMS_new,./data/decomp/openssl-101u_mips_gcc_O3_extraction/GOST_KEY_PARAMS_new@0061c260.c,The function creates a new instance of GOST_KEY_PARAMS using ASN1_item_new and retrieves the code pointer using PTR_ASN1_item_new_006a8654 macro before returning without further actions.
openssl-101u,O3,mips,GOST_KEY_TRANSPORT_free,./data/decomp/openssl-101u_mips_gcc_O3_extraction/GOST_KEY_TRANSPORT_free@0061c158.c,The function takes in a 4-byte parameter and calls a function at PTR_ASN1_item_free_006a8658 with the parameter and a pointer to GOST_KEY_TRANSPORT_it structure to free memory. It warns about not being able to recover the jumptable at address 0x0061c168 and treats an indirect jump as a call.
openssl-101u,O3,mips,gost_param_free,./data/decomp/openssl-101u_mips_gcc_O3_extraction/gost_param_free@0061e380.c,"The function frees the memory allocated for GOST parameters by checking if the global variable ""gost_params"" is not equal to zero. If it is not zero, it calls a function pointer to free the memory and sets ""gost_params"" to zero."
openssl-101u,O3,mips,hash_step,./data/decomp/openssl-101u_mips_gcc_O3_extraction/hash_step@0061e560.c,"The first function takes in three parameters: an unsigned integer, and two pointers to unsigned integers. It performs XOR operations between the two pointers and stores the result in local variables if they are not aligned to 4-byte boundaries. If the pointers are aligned, it performs a series of XOR operations between the values pointed to by the two pointers and stores the results in local variables. It then calls the function ""gost_enc_with_key"" with the first parameter and the local variables as arguments. The function then performs a series of bitwise operations on the second pointer to extract specific bytes, combines them with other bytes from the same pointer, and performs XOR operations with bytes from other pointers to obtain a final result. The function then returns the final result as an unsigned integer.

The second function is performing bitwise operations on various variables and storing the results in local variables. It is difficult to determine the exact purpose of the function without more context, but it appears to be part of a larger program that is manipulating data in some way.

The third function is performing encryption using the GOST block cipher algorithm. It takes two parameters, a key and a plaintext message. It then performs several operations on the plaintext message using the key to produce a ciphertext message. The resulting ciphertext message is returned by the function.

The fourth function is a GOST encryption algorithm implementation. It takes three parameters, the plaintext to be encrypted, the key to use for encryption, and the output buffer for the encrypted data. First, the function initializes some local variables and performs some bitwise operations on the key. Then, it calls a function to encrypt the key with itself, which is used later in the encryption process. Next, the function performs a series of XOR and bit-shifting operations on the plaintext and key, using the encrypted key as a parameter. This process is repeated multiple times in a loop. After the encryption process is complete, the function XORs the encrypted plaintext with the encrypted key and stores the result in the output buffer. Finally, the function checks for a potential stack overflow and allocates memory if necessary.

The fifth function takes in two parameters, `param_1` and `param_2`. It initializes some local variables, including `local_2c`, `local_50`, `local_54`, and `local_58`. It checks if the value at `param_1[3]` is equal to `0`. If it is, it returns `0`. It sets `local_54"
openssl-101u,O3,mips,hwcrhk_init,./data/decomp/openssl-101u_mips_gcc_O3_extraction/hwcrhk_init@005d44b4.c,"The `hwcrhk_init` function initializes the `hwcrhk` library by loading the library and binding necessary functions. It sets function pointers and initializes a mutex if mutex callbacks are not disabled. It also sets a handle index for RSA keys if not already set. If unsuccessful, it sets an error code. The function returns 1 if initialization is successful, 0 otherwise."
openssl-101u,O3,mips,i2d_GOST_KEY_AGREEMENT_INFO,./data/decomp/openssl-101u_mips_gcc_O3_extraction/i2d_GOST_KEY_AGREEMENT_INFO@0061c1e8.c,"The function i2d_GOST_KEY_AGREEMENT_INFO takes two parameters, param_1 and param_2, both of type undefined4. It calls an indirect jump to the function pointed to by PTR_ASN1_item_i2d_006a8678, passing in param_1, param_2, and a constant value GOST_KEY_AGREEMENT_INFO_it. The function being called likely performs some sort of serialization or encoding of the GOST_KEY_AGREEMENT_INFO data structure. The serialized data is not returned, but is likely written to some output buffer or file."
openssl-101u,O3,mips,i2d_GOST_KEY_TRANSPORT,./data/decomp/openssl-101u_mips_gcc_O3_extraction/i2d_GOST_KEY_TRANSPORT@0061c128.c,The i2d_GOST_KEY_TRANSPORT function takes in two parameters of type undefined4 and converts a GOST_KEY_TRANSPORT structure into its DER-encoded representation using a pointer to a function stored in the global variable PTR_ASN1_item_i2d_006a8678. The encoded representation can be transmitted over a network or stored in a file.
openssl-101u,O3,mips,load_pkcs12.constprop.4,./data/decomp/openssl-101u_mips_gcc_O3_extraction/load_pkcs12.constprop.4@00459d08.c,"The load_pkcs12_constprop_4 function takes in seven parameters and initializes variables before attempting to load a PKCS12 file. It checks for successful loading and verifies the MAC of the file. If the MAC verification fails, it prints an error message and returns 0. If the MAC verification succeeds, it calls a password callback function to obtain a password for the file. If the password callback function returns an error, it prints an error message and returns 0. If the password callback function succeeds, it attempts to verify the MAC again using the obtained password. If the MAC verification fails, it prints an error message and returns 0."
openssl-101u,O3,mips,MOD_EXP_CTIME_COPY_FROM_PREBUF,./data/decomp/openssl-101u_mips_gcc_O3_extraction/MOD_EXP_CTIME_COPY_FROM_PREBUF@004efe10.c,"The function takes in a BIGNUM pointer, an integer, a uint pointer, and two uints as parameters. It expands the BIGNUM if necessary and performs a modular exponentiation operation using the input parameters. The operation is optimized using the Chinese Remainder Theorem and the sliding window method. The result is stored in the BIGNUM pointer and the function returns 1 if successful."
openssl-101u,O3,mips,param_copy_gost94,./data/decomp/openssl-101u_mips_gcc_O3_extraction/param_copy_gost94@00619b84.c,"The function takes two parameters of type undefined4 and returns an undefined4 value. It gets the base id of both parameters using EVP_PKEY_base_id and stores them in iVar3 and iVar4. If the base ids of both parameters are not the same, the function calls ERR_GOST_error with error codes 0x75 and 0x69 and returns 0. If the base id of the second parameter is 0, the function calls ERR_GOST_error with error codes 0x75 and 0x73 and returns 0. If the base id of the first parameter is 0, the function creates a new DSA object using DSA_new and assigns the base id of the second parameter and the new DSA object to the first parameter using EVP_PKEY_assign. The function then duplicates the values of three BigIntegers from the second parameter to the first parameter using BN_dup."
openssl-101u,O3,mips,param_print_gost01,./data/decomp/openssl-101u_mips_gcc_O3_extraction/param_print_gost01@0061a0f8.c,"This function takes in three parameters: param_1, param_2, and param_3. It retrieves the EVP_PKEY associated with param_2 and the EC_KEY associated with the EVP_PKEY. It then retrieves the curve name associated with the EC_GROUP of the EC_KEY. The function then indents the output to param_1 using param_3 as the indentation level. If the indentation is successful, it retrieves the long name associated with the curve name and prints it to param_1 with a message indicating the parameter set. The function returns 1 if the indentation was successful, 0 otherwise."
openssl-101u,O3,mips,param_print_gost94,./data/decomp/openssl-101u_mips_gcc_O3_extraction/param_print_gost94@0061a1ac.c,"These function summaries describe various functions related to cryptography and encryption using the GOST algorithm. They involve operations such as key generation, signing, and verification, as well as encoding and decoding of data and parameters. The functions also use external libraries such as OpenSSL and BIO, and include error handling code. Some of the functions are difficult to read and understand due to obfuscation techniques used by the original compiler. Overall, the functions appear to be performing various operations related to cryptography and printing output related to those operations."
openssl-101u,O3,mips,pkey_ctrl_gost,./data/decomp/openssl-101u_mips_gcc_O3_extraction/pkey_ctrl_gost@0061acd8.c,"The first function, `pkey_ctrl_gost`, is a switch statement that performs different actions based on the value of `param_2`. For case 1, it sets the algorithm parameters for a `PKCS7` signer info object. For case 2, it sets the algorithm parameters for a `PKCS7` recipient info object. For case 3, it sets the algorithm identifier for a `PKCS7` object to `0x329`. For case 5, it sets the algorithm parameters for a `CMS` signer info object.

The second function performs various operations related to encryption and decryption using GOST algorithms. It takes in several input parameters, including a private key, a message to be encrypted, and a buffer to store the encrypted message.

The third function retrieves the public key and group from an EVP_PKEY object, calculates the affine coordinates of the public key, and prints the public key and parameter set to a BIO object. If there are errors, it prints an error message and returns 0. If there are no errors, it returns 1."
openssl-101u,O3,mips,pkey_free_gost94,./data/decomp/openssl-101u_mips_gcc_O3_extraction/pkey_free_gost94@0061a0d4.c,"This function checks if a memory location pointed to by an integer parameter is not equal to 0. If it is not equal to 0, it jumps to an unknown function using a jumptable and treats it as a function call. If it is equal to 0, the function simply returns. The purpose of this function is to free the memory allocated for a GOST 94 public key."
openssl-101u,O3,mips,priv_encode_gost,./data/decomp/openssl-101u_mips_gcc_O3_extraction/priv_encode_gost@0061b118.c,"The first function encodes a GOST private key and writes information about it to a BIO object. It takes in three parameters: param_1 is a pointer to a PKCS8_PRIV_KEY_INFO structure, param_2 is a pointer to an EVP_PKEY structure representing the private key, and param_3 is a char pointer used for formatting output. The function first gets the base ID of the EVP_PKEY structure and uses it to get the corresponding NID object. It then calls the encode_gost_algor_params function to encode the GOST algorithm parameters. If the base ID is for an EC key, the function gets the private key and converts it to an ASN.1 INTEGER. It then calls i2d_ASN1_INTEGER to convert the INTEGER to a byte string and sets the result as the private key in the PKCS8_PRIV_KEY_INFO structure. The function then writes information about the private key and its corresponding public key to the BIO object.

The second function is an implementation of the OpenSSL ASN1_METHOD structure for GOST keys. It takes a pointer to an EVP_PKEY structure containing a GOST key and a BIO output stream, and writes the key information to the stream in ASN.1 format. The function first checks that the EVP_PKEY structure contains a GOST key, and returns an error if it does not. It then creates a BN_CTX object for use in performing mathematical operations, and initializes some variables. Next, the function extracts the public key and parameters from the EVP_PKEY structure, and performs some mathematical operations to convert them to the appropriate format for output. It then writes the key information to the BIO stream in ASN.1 format. If any errors occur during this process, the function returns 0. Otherwise, it returns 1."
openssl-101u,O3,mips,pub_encode_gost94,./data/decomp/openssl-101u_mips_gcc_O3_extraction/pub_encode_gost94@0061af08.c,"The first function, `pub_encode_gost94`, encodes a GOST 94 public key by getting the algorithm identifier and parameters from the public key, encoding the algorithm parameters, calculating the length of the encoded public key, encoding the public key, encoding the private key (if successful), printing it using `priv_print_gost94`, and returning the encoded public key or error code.

The second function takes an EVP_PKEY pointer as input and prints information about the key to a BIO object. It checks if the key is an EC key, gets the private key and checks if it is not null, prints the private key using BN_print(), gets the public key and the parameter set from the EVP_PKEY object, uses EC_POINT_get_affine_coordinates_GFp() to get the x and y coordinates of the public key, prints the x and y coordinates using BN_print(), and finally prints the parameter set using OBJ_nid2ln()."
openssl-101u,O3,mips,pub_print_gost94,./data/decomp/openssl-101u_mips_gcc_O3_extraction/pub_print_gost94@0061a314.c,"The first function takes three undefined4 arguments and returns a pointer to an integer. It initializes variables, retrieves values from function calls, prints information to the console, checks values, and calls more functions before returning a pointer to an integer.

The second function generates a GOST 2001 key pair using an EVP_PKEY structure and returns a pointer to an ASN1_STRING structure containing the encoded keys. It checks the type of the EVP_PKEY structure, generates a key pair, and encodes the keys.

The third function generates a key for a GOST cipher using an EVP_PKEY structure and returns a pointer to an integer. It checks if the EVP_PKEY structure is null, extracts parameters, generates random data, encodes algorithm parameters, and handles errors.

The fourth function extracts information about a private key from an EVP_PKEY structure and prints it to a BIO structure. It checks if the EVP_PKEY structure is null, extracts key type, encodes GOST key parameters, and extracts private key value.

The fifth function implements the OpenSSL GOST algorithm for asymmetric encryption using an EVP_PKEY structure and returns a pointer to an integer. It initializes variables, checks if the input pointer is null, retrieves the public key, parameter set, and group, computes public key coordinates, and prints them to a BIO object."
openssl-101u,O3,mips,RSA_padding_add_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O3_extraction/RSA_padding_add_PKCS1_PSS@006284c8.c,"The first function, RSA_padding_add_PKCS1_PSS, adds padding to a message for RSA signature generation using the PKCS1 PSS scheme. It takes in the RSA key, message hash, hash function, and salt length. The function initializes an EVP_MD_CTX structure, sets up the hash function, concatenates the padding, message hash, and salt (if any), applies the MGF1 mask generation function, and sets the last byte of the resulting padded message to 0xbc.

The second function takes in a message, message length, public key, hash value, and a variable. It performs checks and operations on the message, including XORing certain bytes with each other if a specific input parameter is equal to 0. If the input parameter is not equal to 0, the function sets the length of the message to 0 and jumps to a specific point in the code. The exact purpose of the function is unclear without more context or information about the specific algorithm being used."
openssl-101u,O3,mips,RSA_verify_PKCS1_PSS,./data/decomp/openssl-101u_mips_gcc_O3_extraction/RSA_verify_PKCS1_PSS@00627a10.c,"The functions RSA_verify_PKCS1_PSS and RSA-PSS signature verification algorithm both verify a signature using RSA encryption with the PKCS1 PSS padding scheme. They take in the RSA key, the hash of the message, the hash function used, the encrypted signature, and the length of the signature. They initialize an EVP_MD context and get the size of the hash function output. They check if the signature length is valid and check the first byte of the signature to ensure it has the correct padding. If the padding is correct, they extract the masked data and check the last byte of the masked data to ensure it has the correct value. If the masked data is valid, they perform the reverse operation of the PKCS1 PSS padding scheme to obtain the original message digest. They then hash the original message digest and compare it to the hash of the message. If they match, the signature is considered valid and the function returns 1. Otherwise, it returns an error."
openssl-101u,O3,mips,sha_block_data_order,./data/decomp/openssl-101u_mips_gcc_O3_extraction/sha_block_data_order@00620130.c,"These functions all involve some form of cryptographic operations, specifically hashing algorithms. They all involve bitwise operations such as shifting, XORing, ANDing, and adding values with constants. The input data is processed in chunks or blocks, with each block being manipulated using a loop that performs a series of operations. The final output is a fixed-size hash value. The specific operations and constants used in each function are based on the specific hashing algorithm being implemented."
openssl-101u,O3,mips,SHA_Final,./data/decomp/openssl-101u_mips_gcc_O3_extraction/SHA_Final@006215dc.c,"The function takes in a pointer to a buffer (md) and a pointer to a SHA_CTX structure (c) that contains the data to be hashed. The function appends a single 1 bit to the data and pads it with zeros until it is a multiple of 64 bytes. If the data is already a multiple of 64 bytes, an additional block of padding is added. The function sets the first 8 bytes of the padding to the total length of the data in bits, with the most significant byte first. It then processes the padded data in 64-byte blocks using the sha_block_data_order function. After processing all the blocks, the function sets the num field of the SHA_CTX structure to 0 and clears the data buffer using the OPENSSL_cleanse function. Finally, the function copies the 20-byte hash value from the SHA_CTX structure into the md buffer and returns 1 to indicate success."
openssl-101u,O3,mips,srp_verify_server_param,./data/decomp/openssl-101u_mips_gcc_O3_extraction/srp_verify_server_param@004bb9ec.c,"The function takes in an integer and a pointer to an undefined 4-byte variable. It compares two values stored at offsets +0x1ac and +0x1a8 from the integer parameter using a function pointer stored at PTR_BN_ucmp_006a7fb4. If the result is greater than or equal to -1, or if the second value has a null pointer, it sets the value at the pointer parameter to 0x2f and returns 0. If the first comparison fails, it checks if the number of bits in the value at offset +0x1a8 is less than the value stored at offset +0x1cc. If it is, it sets the value at the pointer parameter to 0x47 and returns 0. If the second comparison also fails, it checks if a function pointer stored at offset +0x19c is null. If it is not, it calls the function pointed to by the pointer."
openssl-101u,O3,mips,SSLv23_method,./data/decomp/openssl-101u_mips_gcc_O3_extraction/SSLv23_method@0048f230.c,"The SSLv23_method function returns a pointer to an SSL_METHOD structure, which is cast from a data variable named SSLv23_method_data_15784. Its purpose is to create an SSL/TLS connection that supports both SSLv2 and SSLv3 protocols."
openssl-101u,O3,mips,SSL_SESSION_free.part.2,./data/decomp/openssl-101u_mips_gcc_O3_extraction/SSL_SESSION_free.part.2@004ade34.c,"The function frees custom data, clears sensitive data from memory, frees memory associated with the session's certificate and X509 certificate, frees memory associated with the session's stack of SSL_SESSION_CERT_INFO structures, frees memory associated with various pointers within the session structure, clears the entire session structure from memory, and frees the session structure itself."
openssl-101u,O3,mips,start_hash,./data/decomp/openssl-101u_mips_gcc_O3_extraction/start_hash@0061f4c8.c,"The function takes a pointer to an array of four 32-bit integers as its parameter. It checks if the third element of the array is not equal to zero. If it is not zero, it clears the next 32 bytes (starting from the fourth element) and the next 32 bytes (starting from the twelfth element) using the memset function. It sets the third, second, and first elements to zero. Finally, it returns 1 if the third element was not zero, otherwise it returns 0."
openssl-101u,O3,mips,surewarehk_finish,./data/decomp/openssl-101u_mips_gcc_O3_extraction/surewarehk_finish@005d5b74.c,"This function checks if the SureWare library has been loaded and calls the SureWare function ""p_surewarehk_Finish()"" to clean up any resources used by the library. It also frees the memory used by the SureWare library and any resources used by the logging stream. If there was an error freeing the memory, it sets an error code and returns 0. Additionally, it resets all the function pointers to 0 and returns 1 if all steps were successful."
openssl-101u,O3,mips,sv_body,./data/decomp/openssl-101u_mips_gcc_O3_extraction/sv_body@00443438.c,"The functions are all related to SSL/TLS servers and handle incoming connections from clients. They involve setting up SSL contexts, sockets, and performing handshakes with clients. They also handle various errors and exceptions that may occur during SSL/TLS communication. Some of the functions also implement HTTP servers and handle SRP authentication for clients. Overall, the functions provide examples of how to implement SSL/TLS servers using OpenSSL."
openssl-101u,O3,mips,TLSv1_method,./data/decomp/openssl-101u_mips_gcc_O3_extraction/TLSv1_method@004913b0.c,"The function returns a pointer to an SSL_METHOD structure representing the TLSv1 protocol method. The implementation of the TLSv1 protocol is stored in a data object named TLSv1_method_data_15790, which is cast to an SSL_METHOD pointer and returned."
openssl-101u,O3,mips,__do_global_ctors_aux,./data/decomp/openssl-101u_mips_gcc_O3_extraction/__do_global_ctors_aux@00630f10.c,The function iterates through a linked list of function pointers (__CTOR_LIST__) that point to the constructors for each global object and executes them until it reaches the end of the list.
openssl-101u,O3,mips,__libc_csu_init,./data/decomp/openssl-101u_mips_gcc_O3_extraction/__libc_csu_init@00630e60.c,"The function __libc_csu_init initializes the C runtime environment by calling a function pointer, likely for setting up global variables and initializing other runtime components, before returning. A warning message suggests that there may be dead code that can be safely removed."
openssl-101u,O3,mips,__start,./data/decomp/openssl-101u_mips_gcc_O3_extraction/__start@00421520.c,"The function declares and initializes variables, calls the main function using __libc_start_main, and enters an infinite loop after the main function finishes executing."
openssl-101u,O3,mips,__udivdi3,./data/decomp/openssl-101u_mips_gcc_O3_extraction/__udivdi3@00630570.c,"The functions both involve performing division operations. 

The first function takes in four parameters: the high and low 32 bits of the dividend, the divisor, and the remainder of the high 32 bits of the dividend divided by the divisor. It checks if the divisor is zero and returns an error if it is. If the divisor is greater than or equal to the dividend, it returns zero. If the divisor is less than or equal to the remainder of the high 32 bits of the dividend divided by the divisor, it returns the maximum 64-bit unsigned integer value. Otherwise, the function performs long division using a series of shifts, multiplies, and subtractions. It returns the quotient.

The second function takes in four parameters: param_1, param_2, param_3, and param_4. It performs a series of bitwise operations on these parameters and then uses them to perform a division operation. First, it combines param_3 and param_4 using a bitwise OR operation and shifts the result to the right or left by a certain number of bits. This result is stored in uVar8. Next, the function checks if the upper 16 bits of uVar8 are equal to 0. If they are, the function calls the trap function with parameter 7. Otherwise, it performs a division operation between uVar2 (which is a combination of param_1 and param_2 using the same bitwise operations as before) and the upper 16 bits of uVar8. The result of this division is returned."
